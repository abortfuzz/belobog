{"jsonrpc":"2.0","id":1,"result":{"data":{"objectId":"0x0000000000000000000000000000000000000000000000000000000000000002","version":"43","digest":"8dUuccb1Gsgqe7dNKzaTprUYzrzQnHE3uSCoWmYS93pc","type":"package","owner":"Immutable","previousTransaction":"EJNkKVxNcdZ8ydvuFHGfSwMMXLgtypYjmGtabpaxktkd","storageRebate":"0","content":{"dataType":"package","disassembled":{"accumulator":"// Move bytecode v6\nmodule 2.accumulator {\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct AccumulatorRoot has key {\n\tid: UID\n}\n\nstruct U128 has store {\n\tvalue: u128\n}\n\nstruct Key<phantom Ty0> has copy, drop, store {\n\taddress: address\n}\n\ncreate(Arg0: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[1](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: Call object::sui_accumulator_root_object_id(): UID\n\t9: Pack[0](AccumulatorRoot)\n\t10: Call transfer::share_object<AccumulatorRoot>(AccumulatorRoot)\n\t11: Ret\n}\n\npublic(friend) root_id(Arg0: &AccumulatorRoot): &UID {\nB0:\n\t0: MoveLoc[0](Arg0: &AccumulatorRoot)\n\t1: ImmBorrowField[0](AccumulatorRoot.id: UID)\n\t2: Ret\n}\n\npublic(friend) root_id_mut(Arg0: &mut AccumulatorRoot): &mut UID {\nB0:\n\t0: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: MutBorrowField[0](AccumulatorRoot.id: UID)\n\t2: Ret\n}\n\npublic(friend) create_u128(Arg0: u128): U128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: Pack[1](U128)\n\t2: Ret\n}\n\npublic(friend) destroy_u128(Arg0: U128) {\nB0:\n\t0: MoveLoc[0](Arg0: U128)\n\t1: Unpack[1](U128)\n\t2: Pop\n\t3: Ret\n}\n\npublic(friend) update_u128(Arg0: &mut U128, Arg1: u128, Arg2: u128) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut U128)\n\t1: ImmBorrowField[1](U128.value: u128)\n\t2: ReadRef\n\t3: MoveLoc[1](Arg1: u128)\n\t4: Add\n\t5: MoveLoc[2](Arg2: u128)\n\t6: Sub\n\t7: MoveLoc[0](Arg0: &mut U128)\n\t8: MutBorrowField[1](U128.value: u128)\n\t9: WriteRef\n\t10: Ret\n}\n\npublic(friend) is_zero_u128(Arg0: &U128): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &U128)\n\t1: ImmBorrowField[1](U128.value: u128)\n\t2: ReadRef\n\t3: LdU128(0)\n\t4: Eq\n\t5: Ret\n}\n\npublic(friend) accumulator_key<Ty0>(Arg0: address): Key<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: address)\n\t1: PackGeneric[0](Key<Ty0>)\n\t2: Ret\n}\n\npublic(friend) accumulator_address<Ty0>(Arg0: address): address {\nL1:\tloc0: Key<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: address)\n\t1: PackGeneric[0](Key<Ty0>)\n\t2: StLoc[1](loc0: Key<Ty0>)\n\t3: Call object::sui_accumulator_root_address(): address\n\t4: MoveLoc[1](loc0: Key<Ty0>)\n\t5: Call dynamic_field::hash_type_and_key<Key<Ty0>>(address, Key<Ty0>): address\n\t6: Ret\n}\n\npublic(friend) root_has_accumulator<Ty0, Ty1: store>(Arg0: &AccumulatorRoot, Arg1: Key<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &AccumulatorRoot)\n\t1: ImmBorrowField[0](AccumulatorRoot.id: UID)\n\t2: MoveLoc[1](Arg1: Key<Ty0>)\n\t3: Call dynamic_field::exists_with_type<Key<Ty0>, Ty1>(&UID, Key<Ty0>): bool\n\t4: Ret\n}\n\npublic(friend) root_add_accumulator<Ty0, Ty1: store>(Arg0: &mut AccumulatorRoot, Arg1: Key<Ty0>, Arg2: Ty1) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: MutBorrowField[0](AccumulatorRoot.id: UID)\n\t2: MoveLoc[1](Arg1: Key<Ty0>)\n\t3: MoveLoc[2](Arg2: Ty1)\n\t4: Call dynamic_field::add<Key<Ty0>, Ty1>(&mut UID, Key<Ty0>, Ty1)\n\t5: Ret\n}\n\npublic(friend) root_borrow_accumulator_mut<Ty0, Ty1: store>(Arg0: &mut AccumulatorRoot, Arg1: Key<Ty0>): &mut Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: MutBorrowField[0](AccumulatorRoot.id: UID)\n\t2: MoveLoc[1](Arg1: Key<Ty0>)\n\t3: Call dynamic_field::borrow_mut<Key<Ty0>, Ty1>(&mut UID, Key<Ty0>): &mut Ty1\n\t4: Ret\n}\n\npublic(friend) root_remove_accumulator<Ty0, Ty1: store>(Arg0: &mut AccumulatorRoot, Arg1: Key<Ty0>): Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: MutBorrowField[0](AccumulatorRoot.id: UID)\n\t2: MoveLoc[1](Arg1: Key<Ty0>)\n\t3: Call dynamic_field::remove<Key<Ty0>, Ty1>(&mut UID, Key<Ty0>): Ty1\n\t4: Ret\n}\n\nnative public(friend) emit_deposit_event<Ty0>(Arg0: address, Arg1: address, Arg2: u64);\n\nnative public(friend) emit_withdraw_event<Ty0>(Arg0: address, Arg1: address, Arg2: u64);\n\nConstants [\n\t0 => u64: 0\n\t1 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","accumulator_metadata":"// Move bytecode v6\nmodule 2.accumulator_metadata {\nuse 0000000000000000000000000000000000000000000000000000000000000002::accumulator;\nuse 0000000000000000000000000000000000000000000000000000000000000002::bag;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct OwnerKey has copy, drop, store {\n\towner: address\n}\n\nstruct Owner has store {\n\tbalances: Bag,\n\towner: address\n}\n\nstruct MetadataKey<phantom Ty0> has copy, drop, store {\n\tdummy_field: bool\n}\n\nstruct Metadata<phantom Ty0> has store {\n\tfields: Bag\n}\n\naccumulator_root_owner_exists(Arg0: &AccumulatorRoot, Arg1: address): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &AccumulatorRoot)\n\t1: Call accumulator::root_id(&AccumulatorRoot): &UID\n\t2: MoveLoc[1](Arg1: address)\n\t3: Pack[0](OwnerKey)\n\t4: Call dynamic_field::exists_with_type<OwnerKey, Owner>(&UID, OwnerKey): bool\n\t5: Ret\n}\n\naccumulator_root_borrow_owner_mut(Arg0: &mut AccumulatorRoot, Arg1: address): &mut Owner {\nB0:\n\t0: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: Call accumulator::root_id_mut(&mut AccumulatorRoot): &mut UID\n\t2: MoveLoc[1](Arg1: address)\n\t3: Pack[0](OwnerKey)\n\t4: Call dynamic_field::borrow_mut<OwnerKey, Owner>(&mut UID, OwnerKey): &mut Owner\n\t5: Ret\n}\n\naccumulator_root_attach_owner(Arg0: &mut AccumulatorRoot, Arg1: Owner) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: Call accumulator::root_id_mut(&mut AccumulatorRoot): &mut UID\n\t2: ImmBorrowLoc[1](Arg1: Owner)\n\t3: ImmBorrowField[0](Owner.owner: address)\n\t4: ReadRef\n\t5: Pack[0](OwnerKey)\n\t6: MoveLoc[1](Arg1: Owner)\n\t7: Call dynamic_field::add<OwnerKey, Owner>(&mut UID, OwnerKey, Owner)\n\t8: Ret\n}\n\naccumulator_root_detach_owner(Arg0: &mut AccumulatorRoot, Arg1: address): Owner {\nB0:\n\t0: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: Call accumulator::root_id_mut(&mut AccumulatorRoot): &mut UID\n\t2: MoveLoc[1](Arg1: address)\n\t3: Pack[0](OwnerKey)\n\t4: Call dynamic_field::remove<OwnerKey, Owner>(&mut UID, OwnerKey): Owner\n\t5: Ret\n}\n\npublic(friend) create_accumulator_metadata<Ty0>(Arg0: &mut AccumulatorRoot, Arg1: address, Arg2: &mut TxContext) {\nL3:\tloc0: &mut Owner\nL4:\tloc1: Owner\nL5:\tloc2: Metadata<Ty0>\nB0:\n\t0: CopyLoc[2](Arg2: &mut TxContext)\n\t1: Call bag::new(&mut TxContext): Bag\n\t2: PackGeneric[0](Metadata<Ty0>)\n\t3: StLoc[5](loc2: Metadata<Ty0>)\n\t4: CopyLoc[0](Arg0: &mut AccumulatorRoot)\n\t5: FreezeRef\n\t6: CopyLoc[1](Arg1: address)\n\t7: Call accumulator_root_owner_exists(&AccumulatorRoot, address): bool\n\t8: BrFalse(30)\nB1:\n\t9: MoveLoc[2](Arg2: &mut TxContext)\n\t10: Pop\n\t11: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t12: CopyLoc[1](Arg1: address)\n\t13: Call accumulator_root_borrow_owner_mut(&mut AccumulatorRoot, address): &mut Owner\n\t14: StLoc[3](loc0: &mut Owner)\n\t15: CopyLoc[3](loc0: &mut Owner)\n\t16: ImmBorrowField[0](Owner.owner: address)\n\t17: ReadRef\n\t18: MoveLoc[1](Arg1: address)\n\t19: Eq\n\t20: BrFalse(22)\nB2:\n\t21: Branch(26)\nB3:\n\t22: MoveLoc[3](loc0: &mut Owner)\n\t23: Pop\n\t24: LdConst[0](u64: 0)\n\t25: Abort\nB4:\n\t26: MoveLoc[3](loc0: &mut Owner)\n\t27: MoveLoc[5](loc2: Metadata<Ty0>)\n\t28: Call accumulator_owner_attach_metadata<Ty0>(&mut Owner, Metadata<Ty0>)\n\t29: Branch(41)\nB5:\n\t30: MoveLoc[2](Arg2: &mut TxContext)\n\t31: Call bag::new(&mut TxContext): Bag\n\t32: MoveLoc[1](Arg1: address)\n\t33: Pack[1](Owner)\n\t34: StLoc[4](loc1: Owner)\n\t35: MutBorrowLoc[4](loc1: Owner)\n\t36: MoveLoc[5](loc2: Metadata<Ty0>)\n\t37: Call accumulator_owner_attach_metadata<Ty0>(&mut Owner, Metadata<Ty0>)\n\t38: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t39: MoveLoc[4](loc1: Owner)\n\t40: Call accumulator_root_attach_owner(&mut AccumulatorRoot, Owner)\nB6:\n\t41: Ret\n}\n\npublic(friend) remove_accumulator_metadata<Ty0>(Arg0: &mut AccumulatorRoot, Arg1: address) {\nL2:\tloc0: &mut Owner\nB0:\n\t0: CopyLoc[0](Arg0: &mut AccumulatorRoot)\n\t1: CopyLoc[1](Arg1: address)\n\t2: Call accumulator_root_borrow_owner_mut(&mut AccumulatorRoot, address): &mut Owner\n\t3: StLoc[2](loc0: &mut Owner)\n\t4: CopyLoc[2](loc0: &mut Owner)\n\t5: Call accumulator_owner_detach_metadata<Ty0>(&mut Owner): Metadata<Ty0>\n\t6: UnpackGeneric[0](Metadata<Ty0>)\n\t7: Call bag::destroy_empty(Bag)\n\t8: MoveLoc[2](loc0: &mut Owner)\n\t9: ImmBorrowField[1](Owner.balances: Bag)\n\t10: Call bag::is_empty(&Bag): bool\n\t11: BrFalse(17)\nB1:\n\t12: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t13: MoveLoc[1](Arg1: address)\n\t14: Call accumulator_root_detach_owner(&mut AccumulatorRoot, address): Owner\n\t15: Call accumulator_owner_destroy(Owner)\n\t16: Branch(19)\nB2:\n\t17: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t18: Pop\nB3:\n\t19: Ret\n}\n\naccumulator_owner_attach_metadata<Ty0>(Arg0: &mut Owner, Arg1: Metadata<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Owner)\n\t1: MutBorrowField[1](Owner.balances: Bag)\n\t2: LdFalse\n\t3: PackGeneric[1](MetadataKey<Ty0>)\n\t4: MoveLoc[1](Arg1: Metadata<Ty0>)\n\t5: Call bag::add<MetadataKey<Ty0>, Metadata<Ty0>>(&mut Bag, MetadataKey<Ty0>, Metadata<Ty0>)\n\t6: Ret\n}\n\naccumulator_owner_detach_metadata<Ty0>(Arg0: &mut Owner): Metadata<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Owner)\n\t1: MutBorrowField[1](Owner.balances: Bag)\n\t2: LdFalse\n\t3: PackGeneric[1](MetadataKey<Ty0>)\n\t4: Call bag::remove<MetadataKey<Ty0>, Metadata<Ty0>>(&mut Bag, MetadataKey<Ty0>): Metadata<Ty0>\n\t5: Ret\n}\n\naccumulator_owner_destroy(Arg0: Owner) {\nB0:\n\t0: MoveLoc[0](Arg0: Owner)\n\t1: Unpack[1](Owner)\n\t2: Pop\n\t3: Call bag::destroy_empty(Bag)\n\t4: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n","accumulator_settlement":"// Move bytecode v6\nmodule 2.accumulator_settlement {\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::accumulator;\nuse 0000000000000000000000000000000000000000000000000000000000000002::accumulator_metadata;\nuse 0000000000000000000000000000000000000000000000000000000000000002::bcs;\nuse 0000000000000000000000000000000000000000000000000000000000000002::hash;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct EventStreamHead has store {\n\tmmr: vector<u256>,\n\tcheckpoint_seq: u64,\n\tnum_events: u64\n}\n\nsettlement_prologue(Arg0: u64, Arg1: u64, Arg2: u64, Arg3: u64, Arg4: u64, Arg5: &TxContext) {\nB0:\n\t0: MoveLoc[5](Arg5: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[2](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: MoveLoc[3](Arg3: u64)\n\t9: MoveLoc[4](Arg4: u64)\n\t10: Call record_settlement_sui_conservation(u64, u64)\n\t11: Ret\n}\n\nsettle_u128<Ty0>(Arg0: &mut AccumulatorRoot, Arg1: address, Arg2: u128, Arg3: u128, Arg4: &mut TxContext) {\nL5:\tloc0: Key<Ty0>\nL6:\tloc1: &mut U128\nL7:\tloc2: U128\nB0:\n\t0: CopyLoc[4](Arg4: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::sender(&TxContext): address\n\t3: LdConst[2](address: 0x00..)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(13)\nB2:\n\t7: MoveLoc[4](Arg4: &mut TxContext)\n\t8: Pop\n\t9: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: CopyLoc[2](Arg2: u128)\n\t14: LdU128(0)\n\t15: Eq\n\t16: CopyLoc[3](Arg3: u128)\n\t17: LdU128(0)\n\t18: Eq\n\t19: Neq\n\t20: BrFalse(22)\nB4:\n\t21: Branch(28)\nB5:\n\t22: MoveLoc[4](Arg4: &mut TxContext)\n\t23: Pop\n\t24: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t25: Pop\n\t26: LdConst[1](u64: 1)\n\t27: Abort\nB6:\n\t28: CopyLoc[1](Arg1: address)\n\t29: Call accumulator::accumulator_key<Ty0>(address): Key<Ty0>\n\t30: StLoc[5](loc0: Key<Ty0>)\n\t31: CopyLoc[0](Arg0: &mut AccumulatorRoot)\n\t32: FreezeRef\n\t33: CopyLoc[5](loc0: Key<Ty0>)\n\t34: Call accumulator::root_has_accumulator<Ty0, U128>(&AccumulatorRoot, Key<Ty0>): bool\n\t35: BrFalse(61)\nB7:\n\t36: MoveLoc[4](Arg4: &mut TxContext)\n\t37: Pop\n\t38: CopyLoc[0](Arg0: &mut AccumulatorRoot)\n\t39: CopyLoc[5](loc0: Key<Ty0>)\n\t40: Call accumulator::root_borrow_accumulator_mut<Ty0, U128>(&mut AccumulatorRoot, Key<Ty0>): &mut U128\n\t41: StLoc[6](loc1: &mut U128)\n\t42: CopyLoc[6](loc1: &mut U128)\n\t43: MoveLoc[2](Arg2: u128)\n\t44: MoveLoc[3](Arg3: u128)\n\t45: Call accumulator::update_u128(&mut U128, u128, u128)\n\t46: MoveLoc[6](loc1: &mut U128)\n\t47: FreezeRef\n\t48: Call accumulator::is_zero_u128(&U128): bool\n\t49: BrFalse(58)\nB8:\n\t50: CopyLoc[0](Arg0: &mut AccumulatorRoot)\n\t51: MoveLoc[5](loc0: Key<Ty0>)\n\t52: Call accumulator::root_remove_accumulator<Ty0, U128>(&mut AccumulatorRoot, Key<Ty0>): U128\n\t53: Call accumulator::destroy_u128(U128)\n\t54: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t55: MoveLoc[1](Arg1: address)\n\t56: Call accumulator_metadata::remove_accumulator_metadata<Ty0>(&mut AccumulatorRoot, address)\n\t57: Branch(83)\nB9:\n\t58: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t59: Pop\n\t60: Branch(83)\nB10:\n\t61: MoveLoc[3](Arg3: u128)\n\t62: LdU128(0)\n\t63: Eq\n\t64: BrFalse(66)\nB11:\n\t65: Branch(72)\nB12:\n\t66: MoveLoc[4](Arg4: &mut TxContext)\n\t67: Pop\n\t68: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t69: Pop\n\t70: LdConst[1](u64: 1)\n\t71: Abort\nB13:\n\t72: MoveLoc[2](Arg2: u128)\n\t73: Call accumulator::create_u128(u128): U128\n\t74: StLoc[7](loc2: U128)\n\t75: CopyLoc[0](Arg0: &mut AccumulatorRoot)\n\t76: MoveLoc[5](loc0: Key<Ty0>)\n\t77: MoveLoc[7](loc2: U128)\n\t78: Call accumulator::root_add_accumulator<Ty0, U128>(&mut AccumulatorRoot, Key<Ty0>, U128)\n\t79: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t80: MoveLoc[1](Arg1: address)\n\t81: MoveLoc[4](Arg4: &mut TxContext)\n\t82: Call accumulator_metadata::create_accumulator_metadata<Ty0>(&mut AccumulatorRoot, address, &mut TxContext)\nB14:\n\t83: Ret\n}\n\nnative record_settlement_sui_conservation(Arg0: u64, Arg1: u64);\n\nadd_to_mmr(Arg0: u256, Arg1: &mut vector<u256>) {\nL2:\tloc0: u256\nL3:\tloc1: u64\nL4:\tloc2: &mut u256\nB0:\n\t0: LdU64(0)\n\t1: StLoc[3](loc1: u64)\n\t2: MoveLoc[0](Arg0: u256)\n\t3: StLoc[2](loc0: u256)\nB1:\n\t4: CopyLoc[3](loc1: u64)\n\t5: CopyLoc[1](Arg1: &mut vector<u256>)\n\t6: FreezeRef\n\t7: VecLen(6)\n\t8: Lt\n\t9: BrFalse(39)\nB2:\n\t10: Branch(11)\nB3:\n\t11: CopyLoc[1](Arg1: &mut vector<u256>)\n\t12: CopyLoc[3](loc1: u64)\n\t13: VecMutBorrow(6)\n\t14: StLoc[4](loc2: &mut u256)\n\t15: CopyLoc[4](loc2: &mut u256)\n\t16: ReadRef\n\t17: LdU256(0)\n\t18: Eq\n\t19: BrFalse(26)\nB4:\n\t20: MoveLoc[1](Arg1: &mut vector<u256>)\n\t21: Pop\n\t22: MoveLoc[2](loc0: u256)\n\t23: MoveLoc[4](loc2: &mut u256)\n\t24: WriteRef\n\t25: Ret\nB5:\n\t26: CopyLoc[4](loc2: &mut u256)\n\t27: ReadRef\n\t28: MoveLoc[2](loc0: u256)\n\t29: Call hash_two_to_one_u256(u256, u256): u256\n\t30: StLoc[2](loc0: u256)\n\t31: LdU256(0)\n\t32: MoveLoc[4](loc2: &mut u256)\n\t33: WriteRef\n\t34: MoveLoc[3](loc1: u64)\n\t35: LdU64(1)\n\t36: Add\n\t37: StLoc[3](loc1: u64)\n\t38: Branch(4)\nB6:\n\t39: MoveLoc[1](Arg1: &mut vector<u256>)\n\t40: MoveLoc[2](loc0: u256)\n\t41: VecPushBack(6)\n\t42: Ret\n}\n\nu256_from_bytes(Arg0: vector<u8>): u256 {\nL1:\tloc0: BCS\nB0:\n\t0: MoveLoc[0](Arg0: vector<u8>)\n\t1: Call bcs::new(vector<u8>): BCS\n\t2: StLoc[1](loc0: BCS)\n\t3: MutBorrowLoc[1](loc0: BCS)\n\t4: Call bcs::peel_u256(&mut BCS): u256\n\t5: Ret\n}\n\nhash_two_to_one_u256(Arg0: u256, Arg1: u256): u256 {\nL2:\tloc0: vector<u8>\nL3:\tloc1: vector<u8>\nL4:\tloc2: vector<u8>\nB0:\n\t0: ImmBorrowLoc[0](Arg0: u256)\n\t1: Call bcs::to_bytes<u256>(&u256): vector<u8>\n\t2: StLoc[3](loc1: vector<u8>)\n\t3: ImmBorrowLoc[1](Arg1: u256)\n\t4: Call bcs::to_bytes<u256>(&u256): vector<u8>\n\t5: StLoc[4](loc2: vector<u8>)\n\t6: MoveLoc[3](loc1: vector<u8>)\n\t7: StLoc[2](loc0: vector<u8>)\n\t8: MutBorrowLoc[2](loc0: vector<u8>)\n\t9: MoveLoc[4](loc2: vector<u8>)\n\t10: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\n\t11: ImmBorrowLoc[2](loc0: vector<u8>)\n\t12: Call hash::blake2b256(&vector<u8>): vector<u8>\n\t13: Call u256_from_bytes(vector<u8>): u256\n\t14: Ret\n}\n\nnew_stream_head(Arg0: u256, Arg1: u64, Arg2: u64): EventStreamHead {\nL3:\tloc0: vector<u256>\nB0:\n\t0: VecPack(6, 0)\n\t1: StLoc[3](loc0: vector<u256>)\n\t2: MoveLoc[0](Arg0: u256)\n\t3: MutBorrowLoc[3](loc0: vector<u256>)\n\t4: Call add_to_mmr(u256, &mut vector<u256>)\n\t5: MoveLoc[3](loc0: vector<u256>)\n\t6: MoveLoc[2](Arg2: u64)\n\t7: MoveLoc[1](Arg1: u64)\n\t8: Pack[0](EventStreamHead)\n\t9: Ret\n}\n\nsettle_events(Arg0: &mut AccumulatorRoot, Arg1: address, Arg2: u256, Arg3: u64, Arg4: u64, Arg5: &TxContext) {\nL6:\tloc0: &mut EventStreamHead\nL7:\tloc1: EventStreamHead\nL8:\tloc2: Key<EventStreamHead>\nB0:\n\t0: MoveLoc[5](Arg5: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[2](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t7: Pop\n\t8: LdConst[0](u64: 0)\n\t9: Abort\nB3:\n\t10: MoveLoc[1](Arg1: address)\n\t11: Call accumulator::accumulator_key<EventStreamHead>(address): Key<EventStreamHead>\n\t12: StLoc[8](loc2: Key<EventStreamHead>)\n\t13: CopyLoc[0](Arg0: &mut AccumulatorRoot)\n\t14: FreezeRef\n\t15: CopyLoc[8](loc2: Key<EventStreamHead>)\n\t16: Call accumulator::root_has_accumulator<EventStreamHead, EventStreamHead>(&AccumulatorRoot, Key<EventStreamHead>): bool\n\t17: BrFalse(39)\nB4:\n\t18: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t19: MoveLoc[8](loc2: Key<EventStreamHead>)\n\t20: Call accumulator::root_borrow_accumulator_mut<EventStreamHead, EventStreamHead>(&mut AccumulatorRoot, Key<EventStreamHead>): &mut EventStreamHead\n\t21: StLoc[6](loc0: &mut EventStreamHead)\n\t22: MoveLoc[2](Arg2: u256)\n\t23: CopyLoc[6](loc0: &mut EventStreamHead)\n\t24: MutBorrowField[0](EventStreamHead.mmr: vector<u256>)\n\t25: Call add_to_mmr(u256, &mut vector<u256>)\n\t26: CopyLoc[6](loc0: &mut EventStreamHead)\n\t27: ImmBorrowField[1](EventStreamHead.num_events: u64)\n\t28: ReadRef\n\t29: MoveLoc[3](Arg3: u64)\n\t30: Add\n\t31: CopyLoc[6](loc0: &mut EventStreamHead)\n\t32: MutBorrowField[1](EventStreamHead.num_events: u64)\n\t33: WriteRef\n\t34: MoveLoc[4](Arg4: u64)\n\t35: MoveLoc[6](loc0: &mut EventStreamHead)\n\t36: MutBorrowField[2](EventStreamHead.checkpoint_seq: u64)\n\t37: WriteRef\n\t38: Branch(48)\nB5:\n\t39: MoveLoc[2](Arg2: u256)\n\t40: MoveLoc[3](Arg3: u64)\n\t41: MoveLoc[4](Arg4: u64)\n\t42: Call new_stream_head(u256, u64, u64): EventStreamHead\n\t43: StLoc[7](loc1: EventStreamHead)\n\t44: MoveLoc[0](Arg0: &mut AccumulatorRoot)\n\t45: MoveLoc[8](loc2: Key<EventStreamHead>)\n\t46: MoveLoc[7](loc1: EventStreamHead)\n\t47: Call accumulator::root_add_accumulator<EventStreamHead, EventStreamHead>(&mut AccumulatorRoot, Key<EventStreamHead>, EventStreamHead)\nB6:\n\t48: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","address":"// Move bytecode v6\nmodule 2.address {\nuse 0000000000000000000000000000000000000000000000000000000000000001::ascii;\nuse 0000000000000000000000000000000000000000000000000000000000000001::bcs;\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000002::hex;\n\nnative public to_u256(Arg0: address): u256;\n\nnative public from_u256(Arg0: u256): address;\n\nnative public from_bytes(Arg0: vector<u8>): address;\n\npublic to_bytes(Arg0: address): vector<u8> {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: address)\n\t1: Call bcs::to_bytes<address>(&address): vector<u8>\n\t2: Ret\n}\n\npublic to_ascii_string(Arg0: address): String {\nB0:\n\t0: MoveLoc[0](Arg0: address)\n\t1: Call to_bytes(address): vector<u8>\n\t2: Call hex::encode(vector<u8>): vector<u8>\n\t3: Call ascii::string(vector<u8>): String\n\t4: Ret\n}\n\npublic to_string(Arg0: address): String {\nB0:\n\t0: MoveLoc[0](Arg0: address)\n\t1: Call to_ascii_string(address): String\n\t2: Call string::from_ascii(String): String\n\t3: Ret\n}\n\npublic from_ascii_bytes(Arg0: &vector<u8>): address {\nL1:\tloc0: vector<u8>\nL2:\tloc1: u8\nL3:\tloc2: u64\nL4:\tloc3: u8\nB0:\n\t0: CopyLoc[0](Arg0: &vector<u8>)\n\t1: VecLen(6)\n\t2: LdU64(64)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &vector<u8>)\n\t7: Pop\n\t8: LdConst[2](u64: 0)\n\t9: Abort\nB3:\n\t10: LdConst[3](vector<u8>: \"\" /..)\n\t11: StLoc[1](loc0: vector<u8>)\n\t12: LdU64(0)\n\t13: StLoc[3](loc2: u64)\nB4:\n\t14: CopyLoc[3](loc2: u64)\n\t15: LdU64(64)\n\t16: Lt\n\t17: BrFalse(44)\nB5:\n\t18: CopyLoc[0](Arg0: &vector<u8>)\n\t19: CopyLoc[3](loc2: u64)\n\t20: VecImmBorrow(6)\n\t21: ReadRef\n\t22: Call hex_char_value(u8): u8\n\t23: StLoc[2](loc1: u8)\n\t24: CopyLoc[0](Arg0: &vector<u8>)\n\t25: CopyLoc[3](loc2: u64)\n\t26: LdU64(1)\n\t27: Add\n\t28: VecImmBorrow(6)\n\t29: ReadRef\n\t30: Call hex_char_value(u8): u8\n\t31: StLoc[4](loc3: u8)\n\t32: MutBorrowLoc[1](loc0: vector<u8>)\n\t33: MoveLoc[2](loc1: u8)\n\t34: LdU8(4)\n\t35: Shl\n\t36: MoveLoc[4](loc3: u8)\n\t37: BitOr\n\t38: VecPushBack(6)\n\t39: MoveLoc[3](loc2: u64)\n\t40: LdU64(2)\n\t41: Add\n\t42: StLoc[3](loc2: u64)\n\t43: Branch(14)\nB6:\n\t44: MoveLoc[0](Arg0: &vector<u8>)\n\t45: Pop\n\t46: MoveLoc[1](loc0: vector<u8>)\n\t47: Call from_bytes(vector<u8>): address\n\t48: Ret\n}\n\nhex_char_value(Arg0: u8): u8 {\nL1:\tloc0: bool\nL2:\tloc1: bool\nL3:\tloc2: bool\nL4:\tloc3: u8\nL5:\tloc4: u8\nB0:\n\t0: CopyLoc[0](Arg0: u8)\n\t1: LdU8(48)\n\t2: Ge\n\t3: BrFalse(9)\nB1:\n\t4: CopyLoc[0](Arg0: u8)\n\t5: LdU8(57)\n\t6: Le\n\t7: StLoc[1](loc0: bool)\n\t8: Branch(11)\nB2:\n\t9: LdFalse\n\t10: StLoc[1](loc0: bool)\nB3:\n\t11: MoveLoc[1](loc0: bool)\n\t12: BrFalse(18)\nB4:\n\t13: MoveLoc[0](Arg0: u8)\n\t14: LdU8(48)\n\t15: Sub\n\t16: StLoc[5](loc4: u8)\n\t17: Branch(58)\nB5:\n\t18: CopyLoc[0](Arg0: u8)\n\t19: LdU8(65)\n\t20: Ge\n\t21: BrFalse(27)\nB6:\n\t22: CopyLoc[0](Arg0: u8)\n\t23: LdU8(70)\n\t24: Le\n\t25: StLoc[2](loc1: bool)\n\t26: Branch(29)\nB7:\n\t27: LdFalse\n\t28: StLoc[2](loc1: bool)\nB8:\n\t29: MoveLoc[2](loc1: bool)\n\t30: BrFalse(36)\nB9:\n\t31: MoveLoc[0](Arg0: u8)\n\t32: LdU8(55)\n\t33: Sub\n\t34: StLoc[4](loc3: u8)\n\t35: Branch(56)\nB10:\n\t36: CopyLoc[0](Arg0: u8)\n\t37: LdU8(97)\n\t38: Ge\n\t39: BrFalse(45)\nB11:\n\t40: CopyLoc[0](Arg0: u8)\n\t41: LdU8(102)\n\t42: Le\n\t43: StLoc[3](loc2: bool)\n\t44: Branch(47)\nB12:\n\t45: LdFalse\n\t46: StLoc[3](loc2: bool)\nB13:\n\t47: MoveLoc[3](loc2: bool)\n\t48: BrFalse(50)\nB14:\n\t49: Branch(52)\nB15:\n\t50: LdConst[2](u64: 0)\n\t51: Abort\nB16:\n\t52: MoveLoc[0](Arg0: u8)\n\t53: LdU8(87)\n\t54: Sub\n\t55: StLoc[4](loc3: u8)\nB17:\n\t56: MoveLoc[4](loc3: u8)\n\t57: StLoc[5](loc4: u8)\nB18:\n\t58: MoveLoc[5](loc4: u8)\n\t59: Ret\n}\n\npublic length(): u64 {\nB0:\n\t0: LdConst[0](u64: 32)\n\t1: Ret\n}\n\npublic max(): u256 {\nB0:\n\t0: LdConst[1](u256: 1157..)\n\t1: Ret\n}\n\nConstants [\n\t0 => u64: 32\n\t1 => u256: 115792089237316195423570985008687907853269984665640564039457584007913129639935\n\t2 => u64: 0\n\t3 => vector<u8>: \"\" // interpreted as UTF8 string\n]\n}\n","authenticator_state":"// Move bytecode v6\nmodule 2.authenticator_state {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000001::u64;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct AuthenticatorState has key {\n\tid: UID,\n\tversion: u64\n}\n\nstruct AuthenticatorStateInner has store {\n\tversion: u64,\n\tactive_jwks: vector<ActiveJwk>\n}\n\nstruct JWK has copy, drop, store {\n\tkty: String,\n\te: String,\n\tn: String,\n\talg: String\n}\n\nstruct JwkId has copy, drop, store {\n\tiss: String,\n\tkid: String\n}\n\nstruct ActiveJwk has copy, drop, store {\n\tjwk_id: JwkId,\n\tjwk: JWK,\n\tepoch: u64\n}\n\nactive_jwk_equal(Arg0: &ActiveJwk, Arg1: &ActiveJwk): bool {\nL2:\tloc0: bool\nB0:\n\t0: CopyLoc[0](Arg0: &ActiveJwk)\n\t1: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t2: CopyLoc[1](Arg1: &ActiveJwk)\n\t3: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t4: Call jwk_equal(&JWK, &JWK): bool\n\t5: BrFalse(13)\nB1:\n\t6: MoveLoc[0](Arg0: &ActiveJwk)\n\t7: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t8: MoveLoc[1](Arg1: &ActiveJwk)\n\t9: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t10: Call jwk_id_equal(&JwkId, &JwkId): bool\n\t11: StLoc[2](loc0: bool)\n\t12: Branch(19)\nB2:\n\t13: MoveLoc[1](Arg1: &ActiveJwk)\n\t14: Pop\n\t15: MoveLoc[0](Arg0: &ActiveJwk)\n\t16: Pop\n\t17: LdFalse\n\t18: StLoc[2](loc0: bool)\nB3:\n\t19: MoveLoc[2](loc0: bool)\n\t20: Ret\n}\n\njwk_equal(Arg0: &JWK, Arg1: &JWK): bool {\nL2:\tloc0: bool\nB0:\n\t0: CopyLoc[0](Arg0: &JWK)\n\t1: ImmBorrowField[2](JWK.kty: String)\n\t2: CopyLoc[1](Arg1: &JWK)\n\t3: ImmBorrowField[2](JWK.kty: String)\n\t4: Eq\n\t5: BrFalse(39)\nB1:\n\t6: CopyLoc[0](Arg0: &JWK)\n\t7: ImmBorrowField[3](JWK.e: String)\n\t8: CopyLoc[1](Arg1: &JWK)\n\t9: ImmBorrowField[3](JWK.e: String)\n\t10: Eq\n\t11: BrFalse(32)\nB2:\n\t12: CopyLoc[0](Arg0: &JWK)\n\t13: ImmBorrowField[4](JWK.n: String)\n\t14: CopyLoc[1](Arg1: &JWK)\n\t15: ImmBorrowField[4](JWK.n: String)\n\t16: Eq\n\t17: BrFalse(25)\nB3:\n\t18: MoveLoc[0](Arg0: &JWK)\n\t19: ImmBorrowField[5](JWK.alg: String)\n\t20: MoveLoc[1](Arg1: &JWK)\n\t21: ImmBorrowField[5](JWK.alg: String)\n\t22: Eq\n\t23: StLoc[2](loc0: bool)\n\t24: Branch(45)\nB4:\n\t25: MoveLoc[1](Arg1: &JWK)\n\t26: Pop\n\t27: MoveLoc[0](Arg0: &JWK)\n\t28: Pop\n\t29: LdFalse\n\t30: StLoc[2](loc0: bool)\n\t31: Branch(45)\nB5:\n\t32: MoveLoc[1](Arg1: &JWK)\n\t33: Pop\n\t34: MoveLoc[0](Arg0: &JWK)\n\t35: Pop\n\t36: LdFalse\n\t37: StLoc[2](loc0: bool)\n\t38: Branch(45)\nB6:\n\t39: MoveLoc[1](Arg1: &JWK)\n\t40: Pop\n\t41: MoveLoc[0](Arg0: &JWK)\n\t42: Pop\n\t43: LdFalse\n\t44: StLoc[2](loc0: bool)\nB7:\n\t45: MoveLoc[2](loc0: bool)\n\t46: Ret\n}\n\njwk_id_equal(Arg0: &JwkId, Arg1: &JwkId): bool {\nL2:\tloc0: bool\nB0:\n\t0: CopyLoc[0](Arg0: &JwkId)\n\t1: ImmBorrowField[6](JwkId.iss: String)\n\t2: CopyLoc[1](Arg1: &JwkId)\n\t3: ImmBorrowField[6](JwkId.iss: String)\n\t4: Eq\n\t5: BrFalse(13)\nB1:\n\t6: MoveLoc[0](Arg0: &JwkId)\n\t7: ImmBorrowField[7](JwkId.kid: String)\n\t8: MoveLoc[1](Arg1: &JwkId)\n\t9: ImmBorrowField[7](JwkId.kid: String)\n\t10: Eq\n\t11: StLoc[2](loc0: bool)\n\t12: Branch(19)\nB2:\n\t13: MoveLoc[1](Arg1: &JwkId)\n\t14: Pop\n\t15: MoveLoc[0](Arg0: &JwkId)\n\t16: Pop\n\t17: LdFalse\n\t18: StLoc[2](loc0: bool)\nB3:\n\t19: MoveLoc[2](loc0: bool)\n\t20: Ret\n}\n\nstring_bytes_lt(Arg0: &String, Arg1: &String): bool {\nL2:\tloc0: bool\nL3:\tloc1: bool\nL4:\tloc2: u8\nL5:\tloc3: &vector<u8>\nL6:\tloc4: u8\nL7:\tloc5: &vector<u8>\nL8:\tloc6: u64\nB0:\n\t0: MoveLoc[0](Arg0: &String)\n\t1: Call string::as_bytes(&String): &vector<u8>\n\t2: StLoc[5](loc3: &vector<u8>)\n\t3: MoveLoc[1](Arg1: &String)\n\t4: Call string::as_bytes(&String): &vector<u8>\n\t5: StLoc[7](loc5: &vector<u8>)\n\t6: CopyLoc[5](loc3: &vector<u8>)\n\t7: VecLen(19)\n\t8: CopyLoc[7](loc5: &vector<u8>)\n\t9: VecLen(19)\n\t10: Lt\n\t11: BrFalse(19)\nB1:\n\t12: MoveLoc[7](loc5: &vector<u8>)\n\t13: Pop\n\t14: MoveLoc[5](loc3: &vector<u8>)\n\t15: Pop\n\t16: LdTrue\n\t17: StLoc[3](loc1: bool)\n\t18: Branch(83)\nB2:\n\t19: CopyLoc[5](loc3: &vector<u8>)\n\t20: VecLen(19)\n\t21: CopyLoc[7](loc5: &vector<u8>)\n\t22: VecLen(19)\n\t23: Gt\n\t24: BrFalse(32)\nB3:\n\t25: MoveLoc[7](loc5: &vector<u8>)\n\t26: Pop\n\t27: MoveLoc[5](loc3: &vector<u8>)\n\t28: Pop\n\t29: LdFalse\n\t30: StLoc[2](loc0: bool)\n\t31: Branch(81)\nB4:\n\t32: LdU64(0)\n\t33: StLoc[8](loc6: u64)\nB5:\n\t34: CopyLoc[8](loc6: u64)\n\t35: CopyLoc[5](loc3: &vector<u8>)\n\t36: VecLen(19)\n\t37: Lt\n\t38: BrFalse(75)\nB6:\n\t39: Branch(40)\nB7:\n\t40: CopyLoc[5](loc3: &vector<u8>)\n\t41: CopyLoc[8](loc6: u64)\n\t42: VecImmBorrow(19)\n\t43: ReadRef\n\t44: StLoc[4](loc2: u8)\n\t45: CopyLoc[7](loc5: &vector<u8>)\n\t46: CopyLoc[8](loc6: u64)\n\t47: VecImmBorrow(19)\n\t48: ReadRef\n\t49: StLoc[6](loc4: u8)\n\t50: CopyLoc[4](loc2: u8)\n\t51: CopyLoc[6](loc4: u8)\n\t52: Lt\n\t53: BrFalse(60)\nB8:\n\t54: MoveLoc[7](loc5: &vector<u8>)\n\t55: Pop\n\t56: MoveLoc[5](loc3: &vector<u8>)\n\t57: Pop\n\t58: LdTrue\n\t59: Ret\nB9:\n\t60: MoveLoc[4](loc2: u8)\n\t61: MoveLoc[6](loc4: u8)\n\t62: Gt\n\t63: BrFalse(70)\nB10:\n\t64: MoveLoc[7](loc5: &vector<u8>)\n\t65: Pop\n\t66: MoveLoc[5](loc3: &vector<u8>)\n\t67: Pop\n\t68: LdFalse\n\t69: Ret\nB11:\n\t70: MoveLoc[8](loc6: u64)\n\t71: LdU64(1)\n\t72: Add\n\t73: StLoc[8](loc6: u64)\n\t74: Branch(34)\nB12:\n\t75: MoveLoc[7](loc5: &vector<u8>)\n\t76: Pop\n\t77: MoveLoc[5](loc3: &vector<u8>)\n\t78: Pop\n\t79: LdFalse\n\t80: StLoc[2](loc0: bool)\nB13:\n\t81: MoveLoc[2](loc0: bool)\n\t82: StLoc[3](loc1: bool)\nB14:\n\t83: MoveLoc[3](loc1: bool)\n\t84: Ret\n}\n\njwk_lt(Arg0: &ActiveJwk, Arg1: &ActiveJwk): bool {\nB0:\n\t0: CopyLoc[0](Arg0: &ActiveJwk)\n\t1: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t2: ImmBorrowField[6](JwkId.iss: String)\n\t3: CopyLoc[1](Arg1: &ActiveJwk)\n\t4: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t5: ImmBorrowField[6](JwkId.iss: String)\n\t6: Neq\n\t7: BrFalse(16)\nB1:\n\t8: MoveLoc[0](Arg0: &ActiveJwk)\n\t9: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t10: ImmBorrowField[6](JwkId.iss: String)\n\t11: MoveLoc[1](Arg1: &ActiveJwk)\n\t12: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t13: ImmBorrowField[6](JwkId.iss: String)\n\t14: Call string_bytes_lt(&String, &String): bool\n\t15: Ret\nB2:\n\t16: CopyLoc[0](Arg0: &ActiveJwk)\n\t17: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t18: ImmBorrowField[7](JwkId.kid: String)\n\t19: CopyLoc[1](Arg1: &ActiveJwk)\n\t20: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t21: ImmBorrowField[7](JwkId.kid: String)\n\t22: Neq\n\t23: BrFalse(32)\nB3:\n\t24: MoveLoc[0](Arg0: &ActiveJwk)\n\t25: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t26: ImmBorrowField[7](JwkId.kid: String)\n\t27: MoveLoc[1](Arg1: &ActiveJwk)\n\t28: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t29: ImmBorrowField[7](JwkId.kid: String)\n\t30: Call string_bytes_lt(&String, &String): bool\n\t31: Ret\nB4:\n\t32: CopyLoc[0](Arg0: &ActiveJwk)\n\t33: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t34: ImmBorrowField[2](JWK.kty: String)\n\t35: CopyLoc[1](Arg1: &ActiveJwk)\n\t36: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t37: ImmBorrowField[2](JWK.kty: String)\n\t38: Neq\n\t39: BrFalse(48)\nB5:\n\t40: MoveLoc[0](Arg0: &ActiveJwk)\n\t41: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t42: ImmBorrowField[2](JWK.kty: String)\n\t43: MoveLoc[1](Arg1: &ActiveJwk)\n\t44: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t45: ImmBorrowField[2](JWK.kty: String)\n\t46: Call string_bytes_lt(&String, &String): bool\n\t47: Ret\nB6:\n\t48: CopyLoc[0](Arg0: &ActiveJwk)\n\t49: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t50: ImmBorrowField[3](JWK.e: String)\n\t51: CopyLoc[1](Arg1: &ActiveJwk)\n\t52: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t53: ImmBorrowField[3](JWK.e: String)\n\t54: Neq\n\t55: BrFalse(64)\nB7:\n\t56: MoveLoc[0](Arg0: &ActiveJwk)\n\t57: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t58: ImmBorrowField[3](JWK.e: String)\n\t59: MoveLoc[1](Arg1: &ActiveJwk)\n\t60: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t61: ImmBorrowField[3](JWK.e: String)\n\t62: Call string_bytes_lt(&String, &String): bool\n\t63: Ret\nB8:\n\t64: CopyLoc[0](Arg0: &ActiveJwk)\n\t65: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t66: ImmBorrowField[4](JWK.n: String)\n\t67: CopyLoc[1](Arg1: &ActiveJwk)\n\t68: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t69: ImmBorrowField[4](JWK.n: String)\n\t70: Neq\n\t71: BrFalse(80)\nB9:\n\t72: MoveLoc[0](Arg0: &ActiveJwk)\n\t73: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t74: ImmBorrowField[4](JWK.n: String)\n\t75: MoveLoc[1](Arg1: &ActiveJwk)\n\t76: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t77: ImmBorrowField[4](JWK.n: String)\n\t78: Call string_bytes_lt(&String, &String): bool\n\t79: Ret\nB10:\n\t80: MoveLoc[0](Arg0: &ActiveJwk)\n\t81: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t82: ImmBorrowField[5](JWK.alg: String)\n\t83: MoveLoc[1](Arg1: &ActiveJwk)\n\t84: ImmBorrowField[0](ActiveJwk.jwk: JWK)\n\t85: ImmBorrowField[5](JWK.alg: String)\n\t86: Call string_bytes_lt(&String, &String): bool\n\t87: Ret\n}\n\ncreate(Arg0: &TxContext) {\nL1:\tloc0: AuthenticatorStateInner\nL2:\tloc1: AuthenticatorState\nL3:\tloc2: u64\nB0:\n\t0: MoveLoc[0](Arg0: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[3](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: LdConst[1](u64: 1)\n\t9: StLoc[3](loc2: u64)\n\t10: CopyLoc[3](loc2: u64)\n\t11: VecPack(22, 0)\n\t12: Pack[1](AuthenticatorStateInner)\n\t13: StLoc[1](loc0: AuthenticatorStateInner)\n\t14: Call object::authenticator_state(): UID\n\t15: CopyLoc[3](loc2: u64)\n\t16: Pack[0](AuthenticatorState)\n\t17: StLoc[2](loc1: AuthenticatorState)\n\t18: MutBorrowLoc[2](loc1: AuthenticatorState)\n\t19: MutBorrowField[8](AuthenticatorState.id: UID)\n\t20: MoveLoc[3](loc2: u64)\n\t21: MoveLoc[1](loc0: AuthenticatorStateInner)\n\t22: Call dynamic_field::add<u64, AuthenticatorStateInner>(&mut UID, u64, AuthenticatorStateInner)\n\t23: MoveLoc[2](loc1: AuthenticatorState)\n\t24: Call transfer::share_object<AuthenticatorState>(AuthenticatorState)\n\t25: Ret\n}\n\nload_inner_mut(Arg0: &mut AuthenticatorState): &mut AuthenticatorStateInner {\nL1:\tloc0: &mut AuthenticatorStateInner\nL2:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut AuthenticatorState)\n\t1: ImmBorrowField[9](AuthenticatorState.version: u64)\n\t2: ReadRef\n\t3: StLoc[2](loc1: u64)\n\t4: CopyLoc[2](loc1: u64)\n\t5: LdConst[1](u64: 1)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut AuthenticatorState)\n\t10: Pop\n\t11: LdConst[1](u64: 1)\n\t12: Abort\nB3:\n\t13: CopyLoc[0](Arg0: &mut AuthenticatorState)\n\t14: MutBorrowField[8](AuthenticatorState.id: UID)\n\t15: MoveLoc[0](Arg0: &mut AuthenticatorState)\n\t16: ImmBorrowField[9](AuthenticatorState.version: u64)\n\t17: ReadRef\n\t18: Call dynamic_field::borrow_mut<u64, AuthenticatorStateInner>(&mut UID, u64): &mut AuthenticatorStateInner\n\t19: StLoc[1](loc0: &mut AuthenticatorStateInner)\n\t20: CopyLoc[1](loc0: &mut AuthenticatorStateInner)\n\t21: ImmBorrowField[10](AuthenticatorStateInner.version: u64)\n\t22: ReadRef\n\t23: MoveLoc[2](loc1: u64)\n\t24: Eq\n\t25: BrFalse(27)\nB4:\n\t26: Branch(31)\nB5:\n\t27: MoveLoc[1](loc0: &mut AuthenticatorStateInner)\n\t28: Pop\n\t29: LdConst[1](u64: 1)\n\t30: Abort\nB6:\n\t31: MoveLoc[1](loc0: &mut AuthenticatorStateInner)\n\t32: Ret\n}\n\nload_inner(Arg0: &AuthenticatorState): &AuthenticatorStateInner {\nL1:\tloc0: &AuthenticatorStateInner\nL2:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &AuthenticatorState)\n\t1: ImmBorrowField[9](AuthenticatorState.version: u64)\n\t2: ReadRef\n\t3: StLoc[2](loc1: u64)\n\t4: CopyLoc[2](loc1: u64)\n\t5: LdConst[1](u64: 1)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &AuthenticatorState)\n\t10: Pop\n\t11: LdConst[1](u64: 1)\n\t12: Abort\nB3:\n\t13: CopyLoc[0](Arg0: &AuthenticatorState)\n\t14: ImmBorrowField[8](AuthenticatorState.id: UID)\n\t15: MoveLoc[0](Arg0: &AuthenticatorState)\n\t16: ImmBorrowField[9](AuthenticatorState.version: u64)\n\t17: ReadRef\n\t18: Call dynamic_field::borrow<u64, AuthenticatorStateInner>(&UID, u64): &AuthenticatorStateInner\n\t19: StLoc[1](loc0: &AuthenticatorStateInner)\n\t20: CopyLoc[1](loc0: &AuthenticatorStateInner)\n\t21: ImmBorrowField[10](AuthenticatorStateInner.version: u64)\n\t22: ReadRef\n\t23: MoveLoc[2](loc1: u64)\n\t24: Eq\n\t25: BrFalse(27)\nB4:\n\t26: Branch(31)\nB5:\n\t27: MoveLoc[1](loc0: &AuthenticatorStateInner)\n\t28: Pop\n\t29: LdConst[1](u64: 1)\n\t30: Abort\nB6:\n\t31: MoveLoc[1](loc0: &AuthenticatorStateInner)\n\t32: Ret\n}\n\ncheck_sorted(Arg0: &vector<ActiveJwk>) {\nL1:\tloc0: &ActiveJwk\nL2:\tloc1: &ActiveJwk\nL3:\tloc2: u64\nB0:\n\t0: LdU64(0)\n\t1: StLoc[3](loc2: u64)\nB1:\n\t2: CopyLoc[3](loc2: u64)\n\t3: CopyLoc[0](Arg0: &vector<ActiveJwk>)\n\t4: VecLen(22)\n\t5: LdU64(1)\n\t6: Sub\n\t7: Lt\n\t8: BrFalse(34)\nB2:\n\t9: Branch(10)\nB3:\n\t10: CopyLoc[0](Arg0: &vector<ActiveJwk>)\n\t11: CopyLoc[3](loc2: u64)\n\t12: VecImmBorrow(22)\n\t13: StLoc[1](loc0: &ActiveJwk)\n\t14: CopyLoc[0](Arg0: &vector<ActiveJwk>)\n\t15: CopyLoc[3](loc2: u64)\n\t16: LdU64(1)\n\t17: Add\n\t18: VecImmBorrow(22)\n\t19: StLoc[2](loc1: &ActiveJwk)\n\t20: MoveLoc[1](loc0: &ActiveJwk)\n\t21: MoveLoc[2](loc1: &ActiveJwk)\n\t22: Call jwk_lt(&ActiveJwk, &ActiveJwk): bool\n\t23: BrFalse(25)\nB4:\n\t24: Branch(29)\nB5:\n\t25: MoveLoc[0](Arg0: &vector<ActiveJwk>)\n\t26: Pop\n\t27: LdConst[2](u64: 2)\n\t28: Abort\nB6:\n\t29: MoveLoc[3](loc2: u64)\n\t30: LdU64(1)\n\t31: Add\n\t32: StLoc[3](loc2: u64)\n\t33: Branch(2)\nB7:\n\t34: MoveLoc[0](Arg0: &vector<ActiveJwk>)\n\t35: Pop\n\t36: Ret\n}\n\nupdate_authenticator_state(Arg0: &mut AuthenticatorState, Arg1: vector<ActiveJwk>, Arg2: &TxContext) {\nL3:\tloc0: bool\nL4:\tloc1: u64\nL5:\tloc2: u64\nL6:\tloc3: &mut AuthenticatorStateInner\nL7:\tloc4: u64\nL8:\tloc5: ActiveJwk\nL9:\tloc6: vector<ActiveJwk>\nL10:\tloc7: u64\nL11:\tloc8: &ActiveJwk\nL12:\tloc9: &ActiveJwk\nL13:\tloc10: vector<ActiveJwk>\nB0:\n\t0: MoveLoc[2](Arg2: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[3](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &mut AuthenticatorState)\n\t7: Pop\n\t8: LdConst[0](u64: 0)\n\t9: Abort\nB3:\n\t10: ImmBorrowLoc[1](Arg1: vector<ActiveJwk>)\n\t11: Call check_sorted(&vector<ActiveJwk>)\n\t12: MoveLoc[1](Arg1: vector<ActiveJwk>)\n\t13: Call deduplicate(vector<ActiveJwk>): vector<ActiveJwk>\n\t14: StLoc[9](loc6: vector<ActiveJwk>)\n\t15: MoveLoc[0](Arg0: &mut AuthenticatorState)\n\t16: Call load_inner_mut(&mut AuthenticatorState): &mut AuthenticatorStateInner\n\t17: StLoc[6](loc3: &mut AuthenticatorStateInner)\n\t18: VecPack(22, 0)\n\t19: StLoc[13](loc10: vector<ActiveJwk>)\n\t20: LdU64(0)\n\t21: StLoc[5](loc2: u64)\n\t22: LdU64(0)\n\t23: StLoc[7](loc4: u64)\n\t24: CopyLoc[6](loc3: &mut AuthenticatorStateInner)\n\t25: ImmBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t26: VecLen(22)\n\t27: StLoc[4](loc1: u64)\n\t28: ImmBorrowLoc[9](loc6: vector<ActiveJwk>)\n\t29: VecLen(22)\n\t30: StLoc[10](loc7: u64)\nB4:\n\t31: CopyLoc[5](loc2: u64)\n\t32: CopyLoc[4](loc1: u64)\n\t33: Lt\n\t34: BrFalse(40)\nB5:\n\t35: CopyLoc[7](loc4: u64)\n\t36: CopyLoc[10](loc7: u64)\n\t37: Lt\n\t38: StLoc[3](loc0: bool)\n\t39: Branch(42)\nB6:\n\t40: LdFalse\n\t41: StLoc[3](loc0: bool)\nB7:\n\t42: MoveLoc[3](loc0: bool)\n\t43: BrFalse(129)\nB8:\n\t44: CopyLoc[6](loc3: &mut AuthenticatorStateInner)\n\t45: ImmBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t46: CopyLoc[5](loc2: u64)\n\t47: VecImmBorrow(22)\n\t48: StLoc[12](loc9: &ActiveJwk)\n\t49: ImmBorrowLoc[9](loc6: vector<ActiveJwk>)\n\t50: CopyLoc[7](loc4: u64)\n\t51: VecImmBorrow(22)\n\t52: StLoc[11](loc8: &ActiveJwk)\n\t53: CopyLoc[12](loc9: &ActiveJwk)\n\t54: CopyLoc[11](loc8: &ActiveJwk)\n\t55: Call active_jwk_equal(&ActiveJwk, &ActiveJwk): bool\n\t56: BrFalse(82)\nB9:\n\t57: CopyLoc[12](loc9: &ActiveJwk)\n\t58: ReadRef\n\t59: StLoc[8](loc5: ActiveJwk)\n\t60: MoveLoc[12](loc9: &ActiveJwk)\n\t61: ImmBorrowField[12](ActiveJwk.epoch: u64)\n\t62: ReadRef\n\t63: MoveLoc[11](loc8: &ActiveJwk)\n\t64: ImmBorrowField[12](ActiveJwk.epoch: u64)\n\t65: ReadRef\n\t66: Call u64::max(u64, u64): u64\n\t67: MutBorrowLoc[8](loc5: ActiveJwk)\n\t68: MutBorrowField[12](ActiveJwk.epoch: u64)\n\t69: WriteRef\n\t70: MutBorrowLoc[13](loc10: vector<ActiveJwk>)\n\t71: MoveLoc[8](loc5: ActiveJwk)\n\t72: VecPushBack(22)\n\t73: MoveLoc[5](loc2: u64)\n\t74: LdU64(1)\n\t75: Add\n\t76: StLoc[5](loc2: u64)\n\t77: MoveLoc[7](loc4: u64)\n\t78: LdU64(1)\n\t79: Add\n\t80: StLoc[7](loc4: u64)\n\t81: Branch(31)\nB10:\n\t82: CopyLoc[12](loc9: &ActiveJwk)\n\t83: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t84: CopyLoc[11](loc8: &ActiveJwk)\n\t85: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t86: Call jwk_id_equal(&JwkId, &JwkId): bool\n\t87: BrFalse(103)\nB11:\n\t88: MoveLoc[11](loc8: &ActiveJwk)\n\t89: Pop\n\t90: MutBorrowLoc[13](loc10: vector<ActiveJwk>)\n\t91: MoveLoc[12](loc9: &ActiveJwk)\n\t92: ReadRef\n\t93: VecPushBack(22)\n\t94: MoveLoc[5](loc2: u64)\n\t95: LdU64(1)\n\t96: Add\n\t97: StLoc[5](loc2: u64)\n\t98: MoveLoc[7](loc4: u64)\n\t99: LdU64(1)\n\t100: Add\n\t101: StLoc[7](loc4: u64)\n\t102: Branch(31)\nB12:\n\t103: CopyLoc[12](loc9: &ActiveJwk)\n\t104: CopyLoc[11](loc8: &ActiveJwk)\n\t105: Call jwk_lt(&ActiveJwk, &ActiveJwk): bool\n\t106: BrFalse(118)\nB13:\n\t107: MoveLoc[11](loc8: &ActiveJwk)\n\t108: Pop\n\t109: MutBorrowLoc[13](loc10: vector<ActiveJwk>)\n\t110: MoveLoc[12](loc9: &ActiveJwk)\n\t111: ReadRef\n\t112: VecPushBack(22)\n\t113: MoveLoc[5](loc2: u64)\n\t114: LdU64(1)\n\t115: Add\n\t116: StLoc[5](loc2: u64)\n\t117: Branch(31)\nB14:\n\t118: MoveLoc[12](loc9: &ActiveJwk)\n\t119: Pop\n\t120: MutBorrowLoc[13](loc10: vector<ActiveJwk>)\n\t121: MoveLoc[11](loc8: &ActiveJwk)\n\t122: ReadRef\n\t123: VecPushBack(22)\n\t124: MoveLoc[7](loc4: u64)\n\t125: LdU64(1)\n\t126: Add\n\t127: StLoc[7](loc4: u64)\n\t128: Branch(31)\nB15:\n\t129: CopyLoc[5](loc2: u64)\n\t130: CopyLoc[4](loc1: u64)\n\t131: Lt\n\t132: BrFalse(145)\nB16:\n\t133: MutBorrowLoc[13](loc10: vector<ActiveJwk>)\n\t134: CopyLoc[6](loc3: &mut AuthenticatorStateInner)\n\t135: ImmBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t136: CopyLoc[5](loc2: u64)\n\t137: VecImmBorrow(22)\n\t138: ReadRef\n\t139: VecPushBack(22)\n\t140: MoveLoc[5](loc2: u64)\n\t141: LdU64(1)\n\t142: Add\n\t143: StLoc[5](loc2: u64)\n\t144: Branch(129)\nB17:\n\t145: CopyLoc[7](loc4: u64)\n\t146: CopyLoc[10](loc7: u64)\n\t147: Lt\n\t148: BrFalse(160)\nB18:\n\t149: MutBorrowLoc[13](loc10: vector<ActiveJwk>)\n\t150: ImmBorrowLoc[9](loc6: vector<ActiveJwk>)\n\t151: CopyLoc[7](loc4: u64)\n\t152: VecImmBorrow(22)\n\t153: ReadRef\n\t154: VecPushBack(22)\n\t155: MoveLoc[7](loc4: u64)\n\t156: LdU64(1)\n\t157: Add\n\t158: StLoc[7](loc4: u64)\n\t159: Branch(145)\nB19:\n\t160: MoveLoc[13](loc10: vector<ActiveJwk>)\n\t161: MoveLoc[6](loc3: &mut AuthenticatorStateInner)\n\t162: MutBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t163: WriteRef\n\t164: Ret\n}\n\ndeduplicate(Arg0: vector<ActiveJwk>): vector<ActiveJwk> {\nL1:\tloc0: u64\nL2:\tloc1: &ActiveJwk\nL3:\tloc2: Option<JwkId>\nL4:\tloc3: vector<ActiveJwk>\nB0:\n\t0: VecPack(22, 0)\n\t1: StLoc[4](loc3: vector<ActiveJwk>)\n\t2: LdU64(0)\n\t3: StLoc[1](loc0: u64)\n\t4: Call option::none<JwkId>(): Option<JwkId>\n\t5: StLoc[3](loc2: Option<JwkId>)\nB1:\n\t6: CopyLoc[1](loc0: u64)\n\t7: ImmBorrowLoc[0](Arg0: vector<ActiveJwk>)\n\t8: VecLen(22)\n\t9: Lt\n\t10: BrFalse(53)\nB2:\n\t11: Branch(12)\nB3:\n\t12: ImmBorrowLoc[0](Arg0: vector<ActiveJwk>)\n\t13: CopyLoc[1](loc0: u64)\n\t14: VecImmBorrow(22)\n\t15: StLoc[2](loc1: &ActiveJwk)\n\t16: ImmBorrowLoc[3](loc2: Option<JwkId>)\n\t17: Call option::is_none<JwkId>(&Option<JwkId>): bool\n\t18: BrFalse(25)\nB4:\n\t19: MutBorrowLoc[3](loc2: Option<JwkId>)\n\t20: CopyLoc[2](loc1: &ActiveJwk)\n\t21: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t22: ReadRef\n\t23: Call option::fill<JwkId>(&mut Option<JwkId>, JwkId)\n\t24: Branch(44)\nB5:\n\t25: ImmBorrowLoc[3](loc2: Option<JwkId>)\n\t26: Call option::borrow<JwkId>(&Option<JwkId>): &JwkId\n\t27: CopyLoc[2](loc1: &ActiveJwk)\n\t28: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t29: Call jwk_id_equal(&JwkId, &JwkId): bool\n\t30: BrFalse(38)\nB6:\n\t31: MoveLoc[2](loc1: &ActiveJwk)\n\t32: Pop\n\t33: MoveLoc[1](loc0: u64)\n\t34: LdU64(1)\n\t35: Add\n\t36: StLoc[1](loc0: u64)\n\t37: Branch(6)\nB7:\n\t38: CopyLoc[2](loc1: &ActiveJwk)\n\t39: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t40: ReadRef\n\t41: MutBorrowLoc[3](loc2: Option<JwkId>)\n\t42: Call option::borrow_mut<JwkId>(&mut Option<JwkId>): &mut JwkId\n\t43: WriteRef\nB8:\n\t44: MutBorrowLoc[4](loc3: vector<ActiveJwk>)\n\t45: MoveLoc[2](loc1: &ActiveJwk)\n\t46: ReadRef\n\t47: VecPushBack(22)\n\t48: MoveLoc[1](loc0: u64)\n\t49: LdU64(1)\n\t50: Add\n\t51: StLoc[1](loc0: u64)\n\t52: Branch(6)\nB9:\n\t53: MoveLoc[4](loc3: vector<ActiveJwk>)\n\t54: Ret\n}\n\nexpire_jwks(Arg0: &mut AuthenticatorState, Arg1: u64, Arg2: &TxContext) {\nL3:\tloc0: bool\nL4:\tloc1: u64\nL5:\tloc2: &ActiveJwk\nL6:\tloc3: &String\nL7:\tloc4: &String\nL8:\tloc5: u64\nL9:\tloc6: u64\nL10:\tloc7: &mut AuthenticatorStateInner\nL11:\tloc8: vector<u64>\nL12:\tloc9: u64\nL13:\tloc10: &ActiveJwk\nL14:\tloc11: u64\nL15:\tloc12: vector<ActiveJwk>\nL16:\tloc13: Option<String>\nL17:\tloc14: Option<String>\nL18:\tloc15: &mut u64\nB0:\n\t0: MoveLoc[2](Arg2: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[3](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &mut AuthenticatorState)\n\t7: Pop\n\t8: LdConst[0](u64: 0)\n\t9: Abort\nB3:\n\t10: MoveLoc[0](Arg0: &mut AuthenticatorState)\n\t11: Call load_inner_mut(&mut AuthenticatorState): &mut AuthenticatorStateInner\n\t12: StLoc[10](loc7: &mut AuthenticatorStateInner)\n\t13: CopyLoc[10](loc7: &mut AuthenticatorStateInner)\n\t14: ImmBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t15: VecLen(22)\n\t16: StLoc[14](loc11: u64)\n\t17: LdConst[4](vector<u64>: 00)\n\t18: StLoc[11](loc8: vector<u64>)\n\t19: LdU64(0)\n\t20: StLoc[8](loc5: u64)\n\t21: Call option::none<String>(): Option<String>\n\t22: StLoc[16](loc13: Option<String>)\nB4:\n\t23: CopyLoc[8](loc5: u64)\n\t24: CopyLoc[14](loc11: u64)\n\t25: Lt\n\t26: BrFalse(90)\nB5:\n\t27: CopyLoc[10](loc7: &mut AuthenticatorStateInner)\n\t28: ImmBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t29: CopyLoc[8](loc5: u64)\n\t30: VecImmBorrow(22)\n\t31: StLoc[5](loc2: &ActiveJwk)\n\t32: CopyLoc[5](loc2: &ActiveJwk)\n\t33: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t34: ImmBorrowField[6](JwkId.iss: String)\n\t35: StLoc[6](loc3: &String)\n\t36: ImmBorrowLoc[16](loc13: Option<String>)\n\t37: Call option::is_none<String>(&Option<String>): bool\n\t38: BrFalse(50)\nB6:\n\t39: Branch(40)\nB7:\n\t40: MutBorrowLoc[16](loc13: Option<String>)\n\t41: MoveLoc[6](loc3: &String)\n\t42: ReadRef\n\t43: Call option::fill<String>(&mut Option<String>, String)\n\t44: MutBorrowLoc[11](loc8: vector<u64>)\n\t45: MoveLoc[5](loc2: &ActiveJwk)\n\t46: ImmBorrowField[12](ActiveJwk.epoch: u64)\n\t47: ReadRef\n\t48: VecPushBack(37)\n\t49: Branch(85)\nB8:\n\t50: CopyLoc[6](loc3: &String)\n\t51: ImmBorrowLoc[16](loc13: Option<String>)\n\t52: Call option::borrow<String>(&Option<String>): &String\n\t53: Eq\n\t54: BrFalse(75)\nB9:\n\t55: MoveLoc[6](loc3: &String)\n\t56: Pop\n\t57: ImmBorrowLoc[11](loc8: vector<u64>)\n\t58: VecLen(37)\n\t59: LdU64(1)\n\t60: Sub\n\t61: StLoc[4](loc1: u64)\n\t62: MutBorrowLoc[11](loc8: vector<u64>)\n\t63: MoveLoc[4](loc1: u64)\n\t64: VecMutBorrow(37)\n\t65: StLoc[18](loc15: &mut u64)\n\t66: CopyLoc[18](loc15: &mut u64)\n\t67: ReadRef\n\t68: MoveLoc[5](loc2: &ActiveJwk)\n\t69: ImmBorrowField[12](ActiveJwk.epoch: u64)\n\t70: ReadRef\n\t71: Call u64::max(u64, u64): u64\n\t72: MoveLoc[18](loc15: &mut u64)\n\t73: WriteRef\n\t74: Branch(85)\nB10:\n\t75: MoveLoc[6](loc3: &String)\n\t76: ReadRef\n\t77: MutBorrowLoc[16](loc13: Option<String>)\n\t78: Call option::borrow_mut<String>(&mut Option<String>): &mut String\n\t79: WriteRef\n\t80: MutBorrowLoc[11](loc8: vector<u64>)\n\t81: MoveLoc[5](loc2: &ActiveJwk)\n\t82: ImmBorrowField[12](ActiveJwk.epoch: u64)\n\t83: ReadRef\n\t84: VecPushBack(37)\nB11:\n\t85: MoveLoc[8](loc5: u64)\n\t86: LdU64(1)\n\t87: Add\n\t88: StLoc[8](loc5: u64)\n\t89: Branch(23)\nB12:\n\t90: VecPack(22, 0)\n\t91: StLoc[15](loc12: vector<ActiveJwk>)\n\t92: Call option::none<String>(): Option<String>\n\t93: StLoc[17](loc14: Option<String>)\n\t94: LdU64(0)\n\t95: StLoc[9](loc6: u64)\n\t96: LdU64(0)\n\t97: StLoc[12](loc9: u64)\nB13:\n\t98: CopyLoc[9](loc6: u64)\n\t99: CopyLoc[14](loc11: u64)\n\t100: Lt\n\t101: BrFalse(166)\nB14:\n\t102: CopyLoc[10](loc7: &mut AuthenticatorStateInner)\n\t103: ImmBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t104: CopyLoc[9](loc6: u64)\n\t105: VecImmBorrow(22)\n\t106: StLoc[13](loc10: &ActiveJwk)\n\t107: CopyLoc[13](loc10: &ActiveJwk)\n\t108: ImmBorrowField[1](ActiveJwk.jwk_id: JwkId)\n\t109: ImmBorrowField[6](JwkId.iss: String)\n\t110: StLoc[7](loc4: &String)\n\t111: ImmBorrowLoc[17](loc14: Option<String>)\n\t112: Call option::is_none<String>(&Option<String>): bool\n\t113: BrFalse(119)\nB15:\n\t114: MutBorrowLoc[17](loc14: Option<String>)\n\t115: MoveLoc[7](loc4: &String)\n\t116: ReadRef\n\t117: Call option::fill<String>(&mut Option<String>, String)\n\t118: Branch(136)\nB16:\n\t119: CopyLoc[7](loc4: &String)\n\t120: ImmBorrowLoc[17](loc14: Option<String>)\n\t121: Call option::borrow<String>(&Option<String>): &String\n\t122: Neq\n\t123: BrFalse(134)\nB17:\n\t124: MoveLoc[7](loc4: &String)\n\t125: ReadRef\n\t126: MutBorrowLoc[17](loc14: Option<String>)\n\t127: Call option::borrow_mut<String>(&mut Option<String>): &mut String\n\t128: WriteRef\n\t129: MoveLoc[12](loc9: u64)\n\t130: LdU64(1)\n\t131: Add\n\t132: StLoc[12](loc9: u64)\n\t133: Branch(136)\nB18:\n\t134: MoveLoc[7](loc4: &String)\n\t135: Pop\nB19:\n\t136: ImmBorrowLoc[11](loc8: vector<u64>)\n\t137: CopyLoc[12](loc9: u64)\n\t138: VecImmBorrow(37)\n\t139: ReadRef\n\t140: CopyLoc[1](Arg1: u64)\n\t141: Lt\n\t142: BrFalse(146)\nB20:\n\t143: LdTrue\n\t144: StLoc[3](loc0: bool)\n\t145: Branch(152)\nB21:\n\t146: CopyLoc[13](loc10: &ActiveJwk)\n\t147: ImmBorrowField[12](ActiveJwk.epoch: u64)\n\t148: ReadRef\n\t149: CopyLoc[1](Arg1: u64)\n\t150: Ge\n\t151: StLoc[3](loc0: bool)\nB22:\n\t152: MoveLoc[3](loc0: bool)\n\t153: BrFalse(159)\nB23:\n\t154: MutBorrowLoc[15](loc12: vector<ActiveJwk>)\n\t155: MoveLoc[13](loc10: &ActiveJwk)\n\t156: ReadRef\n\t157: VecPushBack(22)\n\t158: Branch(161)\nB24:\n\t159: MoveLoc[13](loc10: &ActiveJwk)\n\t160: Pop\nB25:\n\t161: MoveLoc[9](loc6: u64)\n\t162: LdU64(1)\n\t163: Add\n\t164: StLoc[9](loc6: u64)\n\t165: Branch(98)\nB26:\n\t166: MoveLoc[15](loc12: vector<ActiveJwk>)\n\t167: MoveLoc[10](loc7: &mut AuthenticatorStateInner)\n\t168: MutBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t169: WriteRef\n\t170: Ret\n}\n\nget_active_jwks(Arg0: &AuthenticatorState, Arg1: &TxContext): vector<ActiveJwk> {\nB0:\n\t0: MoveLoc[1](Arg1: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[3](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &AuthenticatorState)\n\t7: Pop\n\t8: LdConst[0](u64: 0)\n\t9: Abort\nB3:\n\t10: MoveLoc[0](Arg0: &AuthenticatorState)\n\t11: Call load_inner(&AuthenticatorState): &AuthenticatorStateInner\n\t12: ImmBorrowField[11](AuthenticatorStateInner.active_jwks: vector<ActiveJwk>)\n\t13: ReadRef\n\t14: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n\t4 => vector<u64>: 00\n]\n}\n","bag":"// Move bytecode v6\nmodule 2.bag {\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Bag has store, key {\n\tid: UID,\n\tsize: u64\n}\n\npublic new(Arg0: &mut TxContext): Bag {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: LdU64(0)\n\t3: Pack[0](Bag)\n\t4: Ret\n}\n\npublic add<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut Bag, Arg1: Ty0, Arg2: Ty1) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Bag)\n\t1: MutBorrowField[0](Bag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: MoveLoc[2](Arg2: Ty1)\n\t4: Call dynamic_field::add<Ty0, Ty1>(&mut UID, Ty0, Ty1)\n\t5: CopyLoc[0](Arg0: &mut Bag)\n\t6: ImmBorrowField[1](Bag.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Add\n\t10: MoveLoc[0](Arg0: &mut Bag)\n\t11: MutBorrowField[1](Bag.size: u64)\n\t12: WriteRef\n\t13: Ret\n}\n\npublic borrow<Ty0: copy + drop + store, Ty1: store>(Arg0: &Bag, Arg1: Ty0): &Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &Bag)\n\t1: ImmBorrowField[0](Bag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow<Ty0, Ty1>(&UID, Ty0): &Ty1\n\t4: Ret\n}\n\npublic borrow_mut<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut Bag, Arg1: Ty0): &mut Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Bag)\n\t1: MutBorrowField[0](Bag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow_mut<Ty0, Ty1>(&mut UID, Ty0): &mut Ty1\n\t4: Ret\n}\n\npublic remove<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut Bag, Arg1: Ty0): Ty1 {\nL2:\tloc0: Ty1\nB0:\n\t0: CopyLoc[0](Arg0: &mut Bag)\n\t1: MutBorrowField[0](Bag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::remove<Ty0, Ty1>(&mut UID, Ty0): Ty1\n\t4: StLoc[2](loc0: Ty1)\n\t5: CopyLoc[0](Arg0: &mut Bag)\n\t6: ImmBorrowField[1](Bag.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Sub\n\t10: MoveLoc[0](Arg0: &mut Bag)\n\t11: MutBorrowField[1](Bag.size: u64)\n\t12: WriteRef\n\t13: MoveLoc[2](loc0: Ty1)\n\t14: Ret\n}\n\npublic contains<Ty0: copy + drop + store>(Arg0: &Bag, Arg1: Ty0): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Bag)\n\t1: ImmBorrowField[0](Bag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::exists_<Ty0>(&UID, Ty0): bool\n\t4: Ret\n}\n\npublic contains_with_type<Ty0: copy + drop + store, Ty1: store>(Arg0: &Bag, Arg1: Ty0): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Bag)\n\t1: ImmBorrowField[0](Bag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::exists_with_type<Ty0, Ty1>(&UID, Ty0): bool\n\t4: Ret\n}\n\npublic length(Arg0: &Bag): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Bag)\n\t1: ImmBorrowField[1](Bag.size: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic is_empty(Arg0: &Bag): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Bag)\n\t1: ImmBorrowField[1](Bag.size: u64)\n\t2: ReadRef\n\t3: LdU64(0)\n\t4: Eq\n\t5: Ret\n}\n\npublic destroy_empty(Arg0: Bag) {\nL1:\tloc0: UID\nL2:\tloc1: u64\nB0:\n\t0: MoveLoc[0](Arg0: Bag)\n\t1: Unpack[0](Bag)\n\t2: StLoc[2](loc1: u64)\n\t3: StLoc[1](loc0: UID)\n\t4: MoveLoc[2](loc1: u64)\n\t5: LdU64(0)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(11)\nB2:\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[1](loc0: UID)\n\t12: Call object::delete(UID)\n\t13: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n","balance":"// Move bytecode v6\nmodule 2.balance {\nuse 0000000000000000000000000000000000000000000000000000000000000001::ascii;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::funds_accumulator;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Supply<phantom Ty0> has store {\n\tvalue: u64\n}\n\nstruct Balance<phantom Ty0> has store {\n\tvalue: u64\n}\n\npublic value<Ty0>(Arg0: &Balance<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Balance<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Balance.value: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic supply_value<Ty0>(Arg0: &Supply<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Supply<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](Supply.value: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic create_supply<Ty0: drop>(Arg0: Ty0): Supply<Ty0> {\nB0:\n\t0: LdU64(0)\n\t1: PackGeneric[0](Supply<Ty0>)\n\t2: Ret\n}\n\npublic increase_supply<Ty0>(Arg0: &mut Supply<Ty0>, Arg1: u64): Balance<Ty0> {\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: LdU64(18446744073709551615)\n\t2: CopyLoc[0](Arg0: &mut Supply<Ty0>)\n\t3: ImmBorrowFieldGeneric[1](Supply.value: u64)\n\t4: ReadRef\n\t5: Sub\n\t6: Lt\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut Supply<Ty0>)\n\t10: Pop\n\t11: LdConst[1](u64: 1)\n\t12: Abort\nB3:\n\t13: CopyLoc[0](Arg0: &mut Supply<Ty0>)\n\t14: ImmBorrowFieldGeneric[1](Supply.value: u64)\n\t15: ReadRef\n\t16: CopyLoc[1](Arg1: u64)\n\t17: Add\n\t18: MoveLoc[0](Arg0: &mut Supply<Ty0>)\n\t19: MutBorrowFieldGeneric[1](Supply.value: u64)\n\t20: WriteRef\n\t21: MoveLoc[1](Arg1: u64)\n\t22: PackGeneric[1](Balance<Ty0>)\n\t23: Ret\n}\n\npublic decrease_supply<Ty0>(Arg0: &mut Supply<Ty0>, Arg1: Balance<Ty0>): u64 {\nL2:\tloc0: u64\nB0:\n\t0: MoveLoc[1](Arg1: Balance<Ty0>)\n\t1: UnpackGeneric[1](Balance<Ty0>)\n\t2: StLoc[2](loc0: u64)\n\t3: CopyLoc[0](Arg0: &mut Supply<Ty0>)\n\t4: ImmBorrowFieldGeneric[1](Supply.value: u64)\n\t5: ReadRef\n\t6: CopyLoc[2](loc0: u64)\n\t7: Ge\n\t8: BrFalse(10)\nB1:\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[0](Arg0: &mut Supply<Ty0>)\n\t11: Pop\n\t12: LdConst[1](u64: 1)\n\t13: Abort\nB3:\n\t14: CopyLoc[0](Arg0: &mut Supply<Ty0>)\n\t15: ImmBorrowFieldGeneric[1](Supply.value: u64)\n\t16: ReadRef\n\t17: CopyLoc[2](loc0: u64)\n\t18: Sub\n\t19: MoveLoc[0](Arg0: &mut Supply<Ty0>)\n\t20: MutBorrowFieldGeneric[1](Supply.value: u64)\n\t21: WriteRef\n\t22: MoveLoc[2](loc0: u64)\n\t23: Ret\n}\n\npublic zero<Ty0>(): Balance<Ty0> {\nB0:\n\t0: LdU64(0)\n\t1: PackGeneric[1](Balance<Ty0>)\n\t2: Ret\n}\n\npublic join<Ty0>(Arg0: &mut Balance<Ty0>, Arg1: Balance<Ty0>): u64 {\nL2:\tloc0: u64\nB0:\n\t0: MoveLoc[1](Arg1: Balance<Ty0>)\n\t1: UnpackGeneric[1](Balance<Ty0>)\n\t2: StLoc[2](loc0: u64)\n\t3: CopyLoc[0](Arg0: &mut Balance<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](Balance.value: u64)\n\t5: ReadRef\n\t6: MoveLoc[2](loc0: u64)\n\t7: Add\n\t8: CopyLoc[0](Arg0: &mut Balance<Ty0>)\n\t9: MutBorrowFieldGeneric[0](Balance.value: u64)\n\t10: WriteRef\n\t11: MoveLoc[0](Arg0: &mut Balance<Ty0>)\n\t12: ImmBorrowFieldGeneric[0](Balance.value: u64)\n\t13: ReadRef\n\t14: Ret\n}\n\npublic split<Ty0>(Arg0: &mut Balance<Ty0>, Arg1: u64): Balance<Ty0> {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Balance<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Balance.value: u64)\n\t2: ReadRef\n\t3: CopyLoc[1](Arg1: u64)\n\t4: Ge\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut Balance<Ty0>)\n\t8: Pop\n\t9: LdConst[2](u64: 2)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut Balance<Ty0>)\n\t12: ImmBorrowFieldGeneric[0](Balance.value: u64)\n\t13: ReadRef\n\t14: CopyLoc[1](Arg1: u64)\n\t15: Sub\n\t16: MoveLoc[0](Arg0: &mut Balance<Ty0>)\n\t17: MutBorrowFieldGeneric[0](Balance.value: u64)\n\t18: WriteRef\n\t19: MoveLoc[1](Arg1: u64)\n\t20: PackGeneric[1](Balance<Ty0>)\n\t21: Ret\n}\n\npublic withdraw_all<Ty0>(Arg0: &mut Balance<Ty0>): Balance<Ty0> {\nL1:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut Balance<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Balance.value: u64)\n\t2: ReadRef\n\t3: StLoc[1](loc0: u64)\n\t4: MoveLoc[0](Arg0: &mut Balance<Ty0>)\n\t5: MoveLoc[1](loc0: u64)\n\t6: Call split<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t7: Ret\n}\n\npublic destroy_zero<Ty0>(Arg0: Balance<Ty0>) {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: Balance<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Balance.value: u64)\n\t2: ReadRef\n\t3: LdU64(0)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(9)\nB2:\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: MoveLoc[0](Arg0: Balance<Ty0>)\n\t10: UnpackGeneric[1](Balance<Ty0>)\n\t11: Pop\n\t12: Ret\n}\n\npublic(friend) send_funds<Ty0>(Arg0: Balance<Ty0>, Arg1: address) {\nB0:\n\t0: MoveLoc[0](Arg0: Balance<Ty0>)\n\t1: MoveLoc[1](Arg1: address)\n\t2: Call funds_accumulator::add_impl<Balance<Ty0>>(Balance<Ty0>, address)\n\t3: Ret\n}\n\npublic(friend) redeem_funds<Ty0>(Arg0: Withdrawal<Balance<Ty0>>): Balance<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: Withdrawal<Balance<Ty0>>)\n\t1: Call funds_accumulator::redeem<Balance<Ty0>>(Withdrawal<Balance<Ty0>>): Balance<Ty0>\n\t2: Ret\n}\n\npublic(friend) withdraw_funds_from_object<Ty0>(Arg0: &mut UID, Arg1: u64): Withdrawal<Balance<Ty0>> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: CastU256\n\t3: Call funds_accumulator::withdraw_from_object<Balance<Ty0>>(&mut UID, u256): Withdrawal<Balance<Ty0>>\n\t4: Ret\n}\n\npublic(friend) create_supply_internal<Ty0>(): Supply<Ty0> {\nB0:\n\t0: LdU64(0)\n\t1: PackGeneric[0](Supply<Ty0>)\n\t2: Ret\n}\n\ncreate_staking_rewards<Ty0>(Arg0: u64, Arg1: &TxContext): Balance<Ty0> {\nB0:\n\t0: MoveLoc[1](Arg1: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[6](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[3](u64: 3)\n\t7: Abort\nB3:\n\t8: Call type_name::with_defining_ids<Ty0>(): TypeName\n\t9: Call type_name::into_string(TypeName): String\n\t10: Call ascii::into_bytes(String): vector<u8>\n\t11: LdConst[5](vector<u8>: \"000..)\n\t12: Eq\n\t13: BrFalse(15)\nB4:\n\t14: Branch(17)\nB5:\n\t15: LdConst[4](u64: 4)\n\t16: Abort\nB6:\n\t17: MoveLoc[0](Arg0: u64)\n\t18: PackGeneric[1](Balance<Ty0>)\n\t19: Ret\n}\n\ndestroy_storage_rebates<Ty0>(Arg0: Balance<Ty0>, Arg1: &TxContext) {\nB0:\n\t0: MoveLoc[1](Arg1: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[6](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[3](u64: 3)\n\t7: Abort\nB3:\n\t8: Call type_name::with_defining_ids<Ty0>(): TypeName\n\t9: Call type_name::into_string(TypeName): String\n\t10: Call ascii::into_bytes(String): vector<u8>\n\t11: LdConst[5](vector<u8>: \"000..)\n\t12: Eq\n\t13: BrFalse(15)\nB4:\n\t14: Branch(17)\nB5:\n\t15: LdConst[4](u64: 4)\n\t16: Abort\nB6:\n\t17: MoveLoc[0](Arg0: Balance<Ty0>)\n\t18: UnpackGeneric[1](Balance<Ty0>)\n\t19: Pop\n\t20: Ret\n}\n\npublic(friend) destroy_supply<Ty0>(Arg0: Supply<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: Supply<Ty0>)\n\t1: UnpackGeneric[0](Supply<Ty0>)\n\t2: Ret\n}\n\nsend_to_account<Ty0>(Arg0: Balance<Ty0>, Arg1: address) {\nB0:\n\t0: MoveLoc[0](Arg0: Balance<Ty0>)\n\t1: MoveLoc[1](Arg1: address)\n\t2: Call send_funds<Ty0>(Balance<Ty0>, address)\n\t3: Ret\n}\n\nwithdraw_from_account<Ty0>(Arg0: u64, Arg1: &TxContext): Balance<Ty0> {\nB0:\n\t0: MoveLoc[1](Arg1: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: MoveLoc[0](Arg0: u64)\n\t3: CastU256\n\t4: Call funds_accumulator::create_withdrawal<Balance<Ty0>>(address, u256): Withdrawal<Balance<Ty0>>\n\t5: Call funds_accumulator::redeem<Balance<Ty0>>(Withdrawal<Balance<Ty0>>): Balance<Ty0>\n\t6: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => vector<u8>: \"0000000000000000000000000000000000000000000000000000000000000002::sui::SUI\" // interpreted as UTF8 string\n\t6 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","bcs":"// Move bytecode v6\nmodule 2.bcs {\nuse 0000000000000000000000000000000000000000000000000000000000000001::bcs as 1bcs;\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::address;\n\nstruct BCS has copy, drop, store {\n\tbytes: vector<u8>\n}\n\npublic to_bytes<Ty0>(Arg0: &Ty0): vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &Ty0)\n\t1: Call 1bcs::to_bytes<Ty0>(&Ty0): vector<u8>\n\t2: Ret\n}\n\npublic new(Arg0: vector<u8>): BCS {\nB0:\n\t0: MutBorrowLoc[0](Arg0: vector<u8>)\n\t1: Call vector::reverse<u8>(&mut vector<u8>)\n\t2: MoveLoc[0](Arg0: vector<u8>)\n\t3: Pack[0](BCS)\n\t4: Ret\n}\n\npublic into_remainder_bytes(Arg0: BCS): vector<u8> {\nL1:\tloc0: vector<u8>\nB0:\n\t0: MoveLoc[0](Arg0: BCS)\n\t1: Unpack[0](BCS)\n\t2: StLoc[1](loc0: vector<u8>)\n\t3: MutBorrowLoc[1](loc0: vector<u8>)\n\t4: Call vector::reverse<u8>(&mut vector<u8>)\n\t5: MoveLoc[1](loc0: vector<u8>)\n\t6: Ret\n}\n\npublic peel_address(Arg0: &mut BCS): address {\nL1:\tloc0: u64\nL2:\tloc1: u8\nL3:\tloc2: &mut vector<u8>\nL4:\tloc3: u64\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: vector<u8>\nB0:\n\t0: CopyLoc[0](Arg0: &mut BCS)\n\t1: ImmBorrowField[0](BCS.bytes: vector<u8>)\n\t2: VecLen(6)\n\t3: Call address::length(): u64\n\t4: Ge\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut BCS)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: LdConst[3](vector<u8>: \"\" /..)\n\t12: StLoc[7](loc6: vector<u8>)\n\t13: Call address::length(): u64\n\t14: StLoc[1](loc0: u64)\n\t15: LdU64(0)\n\t16: StLoc[5](loc4: u64)\n\t17: MoveLoc[1](loc0: u64)\n\t18: StLoc[6](loc5: u64)\nB4:\n\t19: CopyLoc[5](loc4: u64)\n\t20: CopyLoc[6](loc5: u64)\n\t21: Lt\n\t22: BrFalse(41)\nB5:\n\t23: CopyLoc[5](loc4: u64)\n\t24: StLoc[4](loc3: u64)\n\t25: MutBorrowLoc[7](loc6: vector<u8>)\n\t26: StLoc[3](loc2: &mut vector<u8>)\n\t27: MoveLoc[4](loc3: u64)\n\t28: Pop\n\t29: CopyLoc[0](Arg0: &mut BCS)\n\t30: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t31: VecPopBack(6)\n\t32: StLoc[2](loc1: u8)\n\t33: MoveLoc[3](loc2: &mut vector<u8>)\n\t34: MoveLoc[2](loc1: u8)\n\t35: VecPushBack(6)\n\t36: MoveLoc[5](loc4: u64)\n\t37: LdU64(1)\n\t38: Add\n\t39: StLoc[5](loc4: u64)\n\t40: Branch(19)\nB6:\n\t41: MoveLoc[0](Arg0: &mut BCS)\n\t42: Pop\n\t43: MoveLoc[7](loc6: vector<u8>)\n\t44: Call address::from_bytes(vector<u8>): address\n\t45: Ret\n}\n\npublic peel_bool(Arg0: &mut BCS): bool {\nL1:\tloc0: bool\nL2:\tloc1: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: Call peel_u8(&mut BCS): u8\n\t2: StLoc[2](loc1: u8)\n\t3: CopyLoc[2](loc1: u8)\n\t4: LdU8(0)\n\t5: Eq\n\t6: BrFalse(10)\nB1:\n\t7: LdFalse\n\t8: StLoc[1](loc0: bool)\n\t9: Branch(19)\nB2:\n\t10: MoveLoc[2](loc1: u8)\n\t11: LdU8(1)\n\t12: Eq\n\t13: BrFalse(15)\nB3:\n\t14: Branch(17)\nB4:\n\t15: LdConst[1](u64: 1)\n\t16: Abort\nB5:\n\t17: LdTrue\n\t18: StLoc[1](loc0: bool)\nB6:\n\t19: MoveLoc[1](loc0: bool)\n\t20: Ret\n}\n\npublic peel_u8(Arg0: &mut BCS): u8 {\nB0:\n\t0: CopyLoc[0](Arg0: &mut BCS)\n\t1: ImmBorrowField[0](BCS.bytes: vector<u8>)\n\t2: VecLen(6)\n\t3: LdU64(1)\n\t4: Ge\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut BCS)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[0](Arg0: &mut BCS)\n\t12: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t13: VecPopBack(6)\n\t14: Ret\n}\n\npublic peel_u16(Arg0: &mut BCS): u16 {\nL1:\tloc0: &mut BCS\nL2:\tloc1: u16\nL3:\tloc2: u8\nL4:\tloc3: u16\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[1](loc0: &mut BCS)\n\t2: CopyLoc[1](loc0: &mut BCS)\n\t3: ImmBorrowField[0](BCS.bytes: vector<u8>)\n\t4: VecLen(6)\n\t5: LdU64(2)\n\t6: Ge\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](loc0: &mut BCS)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: LdU16(0)\n\t14: StLoc[4](loc3: u16)\n\t15: LdU8(0)\n\t16: StLoc[3](loc2: u8)\nB4:\n\t17: CopyLoc[3](loc2: u8)\n\t18: LdU8(16)\n\t19: Lt\n\t20: BrFalse(38)\nB5:\n\t21: CopyLoc[1](loc0: &mut BCS)\n\t22: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t23: VecPopBack(6)\n\t24: CastU16\n\t25: StLoc[2](loc1: u16)\n\t26: MoveLoc[4](loc3: u16)\n\t27: MoveLoc[2](loc1: u16)\n\t28: CopyLoc[3](loc2: u8)\n\t29: CastU8\n\t30: Shl\n\t31: Add\n\t32: StLoc[4](loc3: u16)\n\t33: MoveLoc[3](loc2: u8)\n\t34: LdU8(8)\n\t35: Add\n\t36: StLoc[3](loc2: u8)\n\t37: Branch(17)\nB6:\n\t38: MoveLoc[1](loc0: &mut BCS)\n\t39: Pop\n\t40: MoveLoc[4](loc3: u16)\n\t41: Ret\n}\n\npublic peel_u32(Arg0: &mut BCS): u32 {\nL1:\tloc0: &mut BCS\nL2:\tloc1: u32\nL3:\tloc2: u8\nL4:\tloc3: u32\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[1](loc0: &mut BCS)\n\t2: CopyLoc[1](loc0: &mut BCS)\n\t3: ImmBorrowField[0](BCS.bytes: vector<u8>)\n\t4: VecLen(6)\n\t5: LdU64(4)\n\t6: Ge\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](loc0: &mut BCS)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: LdU32(0)\n\t14: StLoc[4](loc3: u32)\n\t15: LdU8(0)\n\t16: StLoc[3](loc2: u8)\nB4:\n\t17: CopyLoc[3](loc2: u8)\n\t18: LdU8(32)\n\t19: Lt\n\t20: BrFalse(38)\nB5:\n\t21: CopyLoc[1](loc0: &mut BCS)\n\t22: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t23: VecPopBack(6)\n\t24: CastU32\n\t25: StLoc[2](loc1: u32)\n\t26: MoveLoc[4](loc3: u32)\n\t27: MoveLoc[2](loc1: u32)\n\t28: CopyLoc[3](loc2: u8)\n\t29: CastU8\n\t30: Shl\n\t31: Add\n\t32: StLoc[4](loc3: u32)\n\t33: MoveLoc[3](loc2: u8)\n\t34: LdU8(8)\n\t35: Add\n\t36: StLoc[3](loc2: u8)\n\t37: Branch(17)\nB6:\n\t38: MoveLoc[1](loc0: &mut BCS)\n\t39: Pop\n\t40: MoveLoc[4](loc3: u32)\n\t41: Ret\n}\n\npublic peel_u64(Arg0: &mut BCS): u64 {\nL1:\tloc0: &mut BCS\nL2:\tloc1: u64\nL3:\tloc2: u8\nL4:\tloc3: u64\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[1](loc0: &mut BCS)\n\t2: CopyLoc[1](loc0: &mut BCS)\n\t3: ImmBorrowField[0](BCS.bytes: vector<u8>)\n\t4: VecLen(6)\n\t5: LdU64(8)\n\t6: Ge\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](loc0: &mut BCS)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: LdU64(0)\n\t14: StLoc[4](loc3: u64)\n\t15: LdU8(0)\n\t16: StLoc[3](loc2: u8)\nB4:\n\t17: CopyLoc[3](loc2: u8)\n\t18: LdU8(64)\n\t19: Lt\n\t20: BrFalse(38)\nB5:\n\t21: CopyLoc[1](loc0: &mut BCS)\n\t22: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t23: VecPopBack(6)\n\t24: CastU64\n\t25: StLoc[2](loc1: u64)\n\t26: MoveLoc[4](loc3: u64)\n\t27: MoveLoc[2](loc1: u64)\n\t28: CopyLoc[3](loc2: u8)\n\t29: CastU8\n\t30: Shl\n\t31: Add\n\t32: StLoc[4](loc3: u64)\n\t33: MoveLoc[3](loc2: u8)\n\t34: LdU8(8)\n\t35: Add\n\t36: StLoc[3](loc2: u8)\n\t37: Branch(17)\nB6:\n\t38: MoveLoc[1](loc0: &mut BCS)\n\t39: Pop\n\t40: MoveLoc[4](loc3: u64)\n\t41: Ret\n}\n\npublic peel_u128(Arg0: &mut BCS): u128 {\nL1:\tloc0: &mut BCS\nL2:\tloc1: u128\nL3:\tloc2: u8\nL4:\tloc3: u128\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[1](loc0: &mut BCS)\n\t2: CopyLoc[1](loc0: &mut BCS)\n\t3: ImmBorrowField[0](BCS.bytes: vector<u8>)\n\t4: VecLen(6)\n\t5: LdU64(16)\n\t6: Ge\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](loc0: &mut BCS)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: LdU128(0)\n\t14: StLoc[4](loc3: u128)\n\t15: LdU8(0)\n\t16: StLoc[3](loc2: u8)\nB4:\n\t17: CopyLoc[3](loc2: u8)\n\t18: LdU8(128)\n\t19: Lt\n\t20: BrFalse(38)\nB5:\n\t21: CopyLoc[1](loc0: &mut BCS)\n\t22: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t23: VecPopBack(6)\n\t24: CastU128\n\t25: StLoc[2](loc1: u128)\n\t26: MoveLoc[4](loc3: u128)\n\t27: MoveLoc[2](loc1: u128)\n\t28: CopyLoc[3](loc2: u8)\n\t29: CastU8\n\t30: Shl\n\t31: Add\n\t32: StLoc[4](loc3: u128)\n\t33: MoveLoc[3](loc2: u8)\n\t34: LdU8(8)\n\t35: Add\n\t36: StLoc[3](loc2: u8)\n\t37: Branch(17)\nB6:\n\t38: MoveLoc[1](loc0: &mut BCS)\n\t39: Pop\n\t40: MoveLoc[4](loc3: u128)\n\t41: Ret\n}\n\npublic peel_u256(Arg0: &mut BCS): u256 {\nL1:\tloc0: &mut BCS\nL2:\tloc1: u256\nL3:\tloc2: u16\nL4:\tloc3: u256\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[1](loc0: &mut BCS)\n\t2: CopyLoc[1](loc0: &mut BCS)\n\t3: ImmBorrowField[0](BCS.bytes: vector<u8>)\n\t4: VecLen(6)\n\t5: LdU64(32)\n\t6: Ge\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](loc0: &mut BCS)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: LdU256(0)\n\t14: StLoc[4](loc3: u256)\n\t15: LdU16(0)\n\t16: StLoc[3](loc2: u16)\nB4:\n\t17: CopyLoc[3](loc2: u16)\n\t18: LdU16(256)\n\t19: Lt\n\t20: BrFalse(38)\nB5:\n\t21: CopyLoc[1](loc0: &mut BCS)\n\t22: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t23: VecPopBack(6)\n\t24: CastU256\n\t25: StLoc[2](loc1: u256)\n\t26: MoveLoc[4](loc3: u256)\n\t27: MoveLoc[2](loc1: u256)\n\t28: CopyLoc[3](loc2: u16)\n\t29: CastU8\n\t30: Shl\n\t31: Add\n\t32: StLoc[4](loc3: u256)\n\t33: MoveLoc[3](loc2: u16)\n\t34: LdU16(8)\n\t35: Add\n\t36: StLoc[3](loc2: u16)\n\t37: Branch(17)\nB6:\n\t38: MoveLoc[1](loc0: &mut BCS)\n\t39: Pop\n\t40: MoveLoc[4](loc3: u256)\n\t41: Ret\n}\n\npublic peel_vec_length(Arg0: &mut BCS): u64 {\nL1:\tloc0: u64\nL2:\tloc1: u64\nL3:\tloc2: u8\nL4:\tloc3: u64\nB0:\n\t0: LdU64(0)\n\t1: LdU8(0)\n\t2: LdU64(0)\n\t3: StLoc[2](loc1: u64)\n\t4: StLoc[3](loc2: u8)\n\t5: StLoc[4](loc3: u64)\nB1:\n\t6: CopyLoc[2](loc1: u64)\n\t7: LdU64(4)\n\t8: Le\n\t9: BrFalse(11)\nB2:\n\t10: Branch(15)\nB3:\n\t11: MoveLoc[0](Arg0: &mut BCS)\n\t12: Pop\n\t13: LdConst[2](u64: 2)\n\t14: Abort\nB4:\n\t15: CopyLoc[0](Arg0: &mut BCS)\n\t16: MutBorrowField[0](BCS.bytes: vector<u8>)\n\t17: VecPopBack(6)\n\t18: CastU64\n\t19: StLoc[1](loc0: u64)\n\t20: MoveLoc[2](loc1: u64)\n\t21: LdU64(1)\n\t22: Add\n\t23: StLoc[2](loc1: u64)\n\t24: MoveLoc[4](loc3: u64)\n\t25: CopyLoc[1](loc0: u64)\n\t26: LdU64(127)\n\t27: BitAnd\n\t28: CopyLoc[3](loc2: u8)\n\t29: Shl\n\t30: BitOr\n\t31: StLoc[4](loc3: u64)\n\t32: MoveLoc[1](loc0: u64)\n\t33: LdU64(128)\n\t34: BitAnd\n\t35: LdU64(0)\n\t36: Eq\n\t37: BrFalse(39)\nB5:\n\t38: Branch(44)\nB6:\n\t39: MoveLoc[3](loc2: u8)\n\t40: LdU8(7)\n\t41: Add\n\t42: StLoc[3](loc2: u8)\n\t43: Branch(6)\nB7:\n\t44: MoveLoc[0](Arg0: &mut BCS)\n\t45: Pop\n\t46: MoveLoc[4](loc3: u64)\n\t47: Ret\n}\n\npublic peel_vec_address(Arg0: &mut BCS): vector<address> {\nL1:\tloc0: u64\nL2:\tloc1: address\nL3:\tloc2: &mut vector<address>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<address>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[4](vector<address>: 00)\n\t3: StLoc[8](loc7: vector<address>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<address>)\n\t18: StLoc[3](loc2: &mut vector<address>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_address(&mut BCS): address\n\t23: StLoc[2](loc1: address)\n\t24: MoveLoc[3](loc2: &mut vector<address>)\n\t25: MoveLoc[2](loc1: address)\n\t26: VecPushBack(4)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<address>)\n\t35: Ret\n}\n\npublic peel_vec_bool(Arg0: &mut BCS): vector<bool> {\nL1:\tloc0: u64\nL2:\tloc1: bool\nL3:\tloc2: &mut vector<bool>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<bool>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[5](vector<bool>: 00)\n\t3: StLoc[8](loc7: vector<bool>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<bool>)\n\t18: StLoc[3](loc2: &mut vector<bool>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_bool(&mut BCS): bool\n\t23: StLoc[2](loc1: bool)\n\t24: MoveLoc[3](loc2: &mut vector<bool>)\n\t25: MoveLoc[2](loc1: bool)\n\t26: VecPushBack(5)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<bool>)\n\t35: Ret\n}\n\npublic peel_vec_u8(Arg0: &mut BCS): vector<u8> {\nL1:\tloc0: u64\nL2:\tloc1: u8\nL3:\tloc2: &mut vector<u8>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<u8>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[3](vector<u8>: \"\" /..)\n\t3: StLoc[8](loc7: vector<u8>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<u8>)\n\t18: StLoc[3](loc2: &mut vector<u8>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_u8(&mut BCS): u8\n\t23: StLoc[2](loc1: u8)\n\t24: MoveLoc[3](loc2: &mut vector<u8>)\n\t25: MoveLoc[2](loc1: u8)\n\t26: VecPushBack(6)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<u8>)\n\t35: Ret\n}\n\npublic peel_vec_vec_u8(Arg0: &mut BCS): vector<vector<u8>> {\nL1:\tloc0: u64\nL2:\tloc1: vector<u8>\nL3:\tloc2: &mut vector<vector<u8>>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<vector<u8>>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[6](vector<vector<u8>>: 00)\n\t3: StLoc[8](loc7: vector<vector<u8>>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<vector<u8>>)\n\t18: StLoc[3](loc2: &mut vector<vector<u8>>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_vec_u8(&mut BCS): vector<u8>\n\t23: StLoc[2](loc1: vector<u8>)\n\t24: MoveLoc[3](loc2: &mut vector<vector<u8>>)\n\t25: MoveLoc[2](loc1: vector<u8>)\n\t26: VecPushBack(1)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<vector<u8>>)\n\t35: Ret\n}\n\npublic peel_vec_u16(Arg0: &mut BCS): vector<u16> {\nL1:\tloc0: u64\nL2:\tloc1: u16\nL3:\tloc2: &mut vector<u16>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<u16>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[7](vector<u16>: 00)\n\t3: StLoc[8](loc7: vector<u16>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<u16>)\n\t18: StLoc[3](loc2: &mut vector<u16>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_u16(&mut BCS): u16\n\t23: StLoc[2](loc1: u16)\n\t24: MoveLoc[3](loc2: &mut vector<u16>)\n\t25: MoveLoc[2](loc1: u16)\n\t26: VecPushBack(7)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<u16>)\n\t35: Ret\n}\n\npublic peel_vec_u32(Arg0: &mut BCS): vector<u32> {\nL1:\tloc0: u64\nL2:\tloc1: u32\nL3:\tloc2: &mut vector<u32>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<u32>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[8](vector<u32>: 00)\n\t3: StLoc[8](loc7: vector<u32>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<u32>)\n\t18: StLoc[3](loc2: &mut vector<u32>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_u32(&mut BCS): u32\n\t23: StLoc[2](loc1: u32)\n\t24: MoveLoc[3](loc2: &mut vector<u32>)\n\t25: MoveLoc[2](loc1: u32)\n\t26: VecPushBack(8)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<u32>)\n\t35: Ret\n}\n\npublic peel_vec_u64(Arg0: &mut BCS): vector<u64> {\nL1:\tloc0: u64\nL2:\tloc1: u64\nL3:\tloc2: &mut vector<u64>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<u64>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[9](vector<u64>: 00)\n\t3: StLoc[8](loc7: vector<u64>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<u64>)\n\t18: StLoc[3](loc2: &mut vector<u64>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_u64(&mut BCS): u64\n\t23: StLoc[2](loc1: u64)\n\t24: MoveLoc[3](loc2: &mut vector<u64>)\n\t25: MoveLoc[2](loc1: u64)\n\t26: VecPushBack(9)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<u64>)\n\t35: Ret\n}\n\npublic peel_vec_u128(Arg0: &mut BCS): vector<u128> {\nL1:\tloc0: u64\nL2:\tloc1: u128\nL3:\tloc2: &mut vector<u128>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<u128>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[10](vector<u128>: 00)\n\t3: StLoc[8](loc7: vector<u128>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<u128>)\n\t18: StLoc[3](loc2: &mut vector<u128>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_u128(&mut BCS): u128\n\t23: StLoc[2](loc1: u128)\n\t24: MoveLoc[3](loc2: &mut vector<u128>)\n\t25: MoveLoc[2](loc1: u128)\n\t26: VecPushBack(10)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<u128>)\n\t35: Ret\n}\n\npublic peel_vec_u256(Arg0: &mut BCS): vector<u256> {\nL1:\tloc0: u64\nL2:\tloc1: u256\nL3:\tloc2: &mut vector<u256>\nL4:\tloc3: &mut BCS\nL5:\tloc4: u64\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: vector<u256>\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[4](loc3: &mut BCS)\n\t2: LdConst[11](vector<u256>: 00)\n\t3: StLoc[8](loc7: vector<u256>)\n\t4: CopyLoc[4](loc3: &mut BCS)\n\t5: Call peel_vec_length(&mut BCS): u64\n\t6: StLoc[1](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc4: u64)\n\t9: MoveLoc[1](loc0: u64)\n\t10: StLoc[7](loc6: u64)\nB1:\n\t11: CopyLoc[5](loc4: u64)\n\t12: CopyLoc[7](loc6: u64)\n\t13: Lt\n\t14: BrFalse(32)\nB2:\n\t15: CopyLoc[5](loc4: u64)\n\t16: StLoc[6](loc5: u64)\n\t17: MutBorrowLoc[8](loc7: vector<u256>)\n\t18: StLoc[3](loc2: &mut vector<u256>)\n\t19: MoveLoc[6](loc5: u64)\n\t20: Pop\n\t21: CopyLoc[4](loc3: &mut BCS)\n\t22: Call peel_u256(&mut BCS): u256\n\t23: StLoc[2](loc1: u256)\n\t24: MoveLoc[3](loc2: &mut vector<u256>)\n\t25: MoveLoc[2](loc1: u256)\n\t26: VecPushBack(11)\n\t27: MoveLoc[5](loc4: u64)\n\t28: LdU64(1)\n\t29: Add\n\t30: StLoc[5](loc4: u64)\n\t31: Branch(11)\nB3:\n\t32: MoveLoc[4](loc3: &mut BCS)\n\t33: Pop\n\t34: MoveLoc[8](loc7: vector<u256>)\n\t35: Ret\n}\n\npublic peel_enum_tag(Arg0: &mut BCS): u32 {\nL1:\tloc0: u64\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: Call peel_vec_length(&mut BCS): u64\n\t2: StLoc[1](loc0: u64)\n\t3: CopyLoc[1](loc0: u64)\n\t4: LdU64(4294967295)\n\t5: Le\n\t6: BrFalse(8)\nB1:\n\t7: Branch(10)\nB2:\n\t8: LdConst[0](u64: 0)\n\t9: Abort\nB3:\n\t10: MoveLoc[1](loc0: u64)\n\t11: CastU32\n\t12: Ret\n}\n\npublic peel_option_address(Arg0: &mut BCS): Option<address> {\nL1:\tloc0: Option<address>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_address(&mut BCS): address\n\t7: Call option::some<address>(address): Option<address>\n\t8: StLoc[1](loc0: Option<address>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<address>(): Option<address>\n\t13: StLoc[1](loc0: Option<address>)\nB3:\n\t14: MoveLoc[1](loc0: Option<address>)\n\t15: Ret\n}\n\npublic peel_option_bool(Arg0: &mut BCS): Option<bool> {\nL1:\tloc0: Option<bool>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_bool(&mut BCS): bool\n\t7: Call option::some<bool>(bool): Option<bool>\n\t8: StLoc[1](loc0: Option<bool>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<bool>(): Option<bool>\n\t13: StLoc[1](loc0: Option<bool>)\nB3:\n\t14: MoveLoc[1](loc0: Option<bool>)\n\t15: Ret\n}\n\npublic peel_option_u8(Arg0: &mut BCS): Option<u8> {\nL1:\tloc0: Option<u8>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_u8(&mut BCS): u8\n\t7: Call option::some<u8>(u8): Option<u8>\n\t8: StLoc[1](loc0: Option<u8>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<u8>(): Option<u8>\n\t13: StLoc[1](loc0: Option<u8>)\nB3:\n\t14: MoveLoc[1](loc0: Option<u8>)\n\t15: Ret\n}\n\npublic peel_option_u16(Arg0: &mut BCS): Option<u16> {\nL1:\tloc0: Option<u16>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_u16(&mut BCS): u16\n\t7: Call option::some<u16>(u16): Option<u16>\n\t8: StLoc[1](loc0: Option<u16>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<u16>(): Option<u16>\n\t13: StLoc[1](loc0: Option<u16>)\nB3:\n\t14: MoveLoc[1](loc0: Option<u16>)\n\t15: Ret\n}\n\npublic peel_option_u32(Arg0: &mut BCS): Option<u32> {\nL1:\tloc0: Option<u32>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_u32(&mut BCS): u32\n\t7: Call option::some<u32>(u32): Option<u32>\n\t8: StLoc[1](loc0: Option<u32>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<u32>(): Option<u32>\n\t13: StLoc[1](loc0: Option<u32>)\nB3:\n\t14: MoveLoc[1](loc0: Option<u32>)\n\t15: Ret\n}\n\npublic peel_option_u64(Arg0: &mut BCS): Option<u64> {\nL1:\tloc0: Option<u64>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_u64(&mut BCS): u64\n\t7: Call option::some<u64>(u64): Option<u64>\n\t8: StLoc[1](loc0: Option<u64>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<u64>(): Option<u64>\n\t13: StLoc[1](loc0: Option<u64>)\nB3:\n\t14: MoveLoc[1](loc0: Option<u64>)\n\t15: Ret\n}\n\npublic peel_option_u128(Arg0: &mut BCS): Option<u128> {\nL1:\tloc0: Option<u128>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_u128(&mut BCS): u128\n\t7: Call option::some<u128>(u128): Option<u128>\n\t8: StLoc[1](loc0: Option<u128>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<u128>(): Option<u128>\n\t13: StLoc[1](loc0: Option<u128>)\nB3:\n\t14: MoveLoc[1](loc0: Option<u128>)\n\t15: Ret\n}\n\npublic peel_option_u256(Arg0: &mut BCS): Option<u256> {\nL1:\tloc0: Option<u256>\nL2:\tloc1: &mut BCS\nB0:\n\t0: MoveLoc[0](Arg0: &mut BCS)\n\t1: StLoc[2](loc1: &mut BCS)\n\t2: CopyLoc[2](loc1: &mut BCS)\n\t3: Call peel_bool(&mut BCS): bool\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[2](loc1: &mut BCS)\n\t6: Call peel_u256(&mut BCS): u256\n\t7: Call option::some<u256>(u256): Option<u256>\n\t8: StLoc[1](loc0: Option<u256>)\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](loc1: &mut BCS)\n\t11: Pop\n\t12: Call option::none<u256>(): Option<u256>\n\t13: StLoc[1](loc0: Option<u256>)\nB3:\n\t14: MoveLoc[1](loc0: Option<u256>)\n\t15: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => vector<u8>: \"\" // interpreted as UTF8 string\n\t4 => vector<address>: 00\n\t5 => vector<bool>: 00\n\t6 => vector<vector<u8>>: 00\n\t7 => vector<u16>: 00\n\t8 => vector<u32>: 00\n\t9 => vector<u64>: 00\n\t10 => vector<u128>: 00\n\t11 => vector<u256>: 00\n]\n}\n","bls12381":"// Move bytecode v6\nmodule 2.bls12381 {\nuse 0000000000000000000000000000000000000000000000000000000000000002::group_ops;\n\nstruct Scalar {\n\tdummy_field: bool\n}\n\nstruct G1 {\n\tdummy_field: bool\n}\n\nstruct G2 {\n\tdummy_field: bool\n}\n\nstruct GT {\n\tdummy_field: bool\n}\n\nstruct UncompressedG1 {\n\tdummy_field: bool\n}\n\nnative public bls12381_min_sig_verify(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>): bool;\n\nnative public bls12381_min_pk_verify(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>): bool;\n\npublic scalar_from_bytes(Arg0: &vector<u8>): Element<Scalar> {\nB0:\n\t0: LdConst[8](u8: 0)\n\t1: MoveLoc[0](Arg0: &vector<u8>)\n\t2: LdFalse\n\t3: Call group_ops::from_bytes<Scalar>(u8, &vector<u8>, bool): Element<Scalar>\n\t4: Ret\n}\n\npublic scalar_from_u64(Arg0: u64): Element<Scalar> {\nL1:\tloc0: vector<u8>\nB0:\n\t0: LdConst[0](vector<u8>: \"\u0000\u0000\u0000..)\n\t1: StLoc[1](loc0: vector<u8>)\n\t2: MoveLoc[0](Arg0: u64)\n\t3: LdTrue\n\t4: MutBorrowLoc[1](loc0: vector<u8>)\n\t5: Call group_ops::set_as_prefix(u64, bool, &mut vector<u8>)\n\t6: LdConst[8](u8: 0)\n\t7: ImmBorrowLoc[1](loc0: vector<u8>)\n\t8: LdTrue\n\t9: Call group_ops::from_bytes<Scalar>(u8, &vector<u8>, bool): Element<Scalar>\n\t10: Ret\n}\n\npublic scalar_zero(): Element<Scalar> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[0](vector<u8>: \"\u0000\u0000\u0000..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[8](u8: 0)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<Scalar>(u8, &vector<u8>, bool): Element<Scalar>\n\t6: Ret\n}\n\npublic scalar_one(): Element<Scalar> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[1](vector<u8>: \"\u0000\u0000\u0000..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[8](u8: 0)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<Scalar>(u8, &vector<u8>, bool): Element<Scalar>\n\t6: Ret\n}\n\npublic scalar_add(Arg0: &Element<Scalar>, Arg1: &Element<Scalar>): Element<Scalar> {\nB0:\n\t0: LdConst[8](u8: 0)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<Scalar>)\n\t3: Call group_ops::add<Scalar>(u8, &Element<Scalar>, &Element<Scalar>): Element<Scalar>\n\t4: Ret\n}\n\npublic scalar_sub(Arg0: &Element<Scalar>, Arg1: &Element<Scalar>): Element<Scalar> {\nB0:\n\t0: LdConst[8](u8: 0)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<Scalar>)\n\t3: Call group_ops::sub<Scalar>(u8, &Element<Scalar>, &Element<Scalar>): Element<Scalar>\n\t4: Ret\n}\n\npublic scalar_mul(Arg0: &Element<Scalar>, Arg1: &Element<Scalar>): Element<Scalar> {\nB0:\n\t0: LdConst[8](u8: 0)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<Scalar>)\n\t3: Call group_ops::mul<Scalar, Scalar>(u8, &Element<Scalar>, &Element<Scalar>): Element<Scalar>\n\t4: Ret\n}\n\npublic scalar_div(Arg0: &Element<Scalar>, Arg1: &Element<Scalar>): Element<Scalar> {\nB0:\n\t0: LdConst[8](u8: 0)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<Scalar>)\n\t3: Call group_ops::div<Scalar, Scalar>(u8, &Element<Scalar>, &Element<Scalar>): Element<Scalar>\n\t4: Ret\n}\n\npublic scalar_neg(Arg0: &Element<Scalar>): Element<Scalar> {\nL1:\tloc0: Element<Scalar>\nB0:\n\t0: Call scalar_zero(): Element<Scalar>\n\t1: StLoc[1](loc0: Element<Scalar>)\n\t2: ImmBorrowLoc[1](loc0: Element<Scalar>)\n\t3: MoveLoc[0](Arg0: &Element<Scalar>)\n\t4: Call scalar_sub(&Element<Scalar>, &Element<Scalar>): Element<Scalar>\n\t5: Ret\n}\n\npublic scalar_inv(Arg0: &Element<Scalar>): Element<Scalar> {\nL1:\tloc0: Element<Scalar>\nL2:\tloc1: &Element<Scalar>\nB0:\n\t0: MoveLoc[0](Arg0: &Element<Scalar>)\n\t1: StLoc[2](loc1: &Element<Scalar>)\n\t2: Call scalar_one(): Element<Scalar>\n\t3: StLoc[1](loc0: Element<Scalar>)\n\t4: MoveLoc[2](loc1: &Element<Scalar>)\n\t5: ImmBorrowLoc[1](loc0: Element<Scalar>)\n\t6: Call scalar_div(&Element<Scalar>, &Element<Scalar>): Element<Scalar>\n\t7: Ret\n}\n\npublic g1_from_bytes(Arg0: &vector<u8>): Element<G1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &vector<u8>)\n\t2: LdFalse\n\t3: Call group_ops::from_bytes<G1>(u8, &vector<u8>, bool): Element<G1>\n\t4: Ret\n}\n\npublic g1_identity(): Element<G1> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[2](vector<u8>: 30c0..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[9](u8: 1)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<G1>(u8, &vector<u8>, bool): Element<G1>\n\t6: Ret\n}\n\npublic g1_generator(): Element<G1> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[3](vector<u8>: 3097..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[9](u8: 1)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<G1>(u8, &vector<u8>, bool): Element<G1>\n\t6: Ret\n}\n\npublic g1_add(Arg0: &Element<G1>, Arg1: &Element<G1>): Element<G1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &Element<G1>)\n\t2: MoveLoc[1](Arg1: &Element<G1>)\n\t3: Call group_ops::add<G1>(u8, &Element<G1>, &Element<G1>): Element<G1>\n\t4: Ret\n}\n\npublic g1_sub(Arg0: &Element<G1>, Arg1: &Element<G1>): Element<G1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &Element<G1>)\n\t2: MoveLoc[1](Arg1: &Element<G1>)\n\t3: Call group_ops::sub<G1>(u8, &Element<G1>, &Element<G1>): Element<G1>\n\t4: Ret\n}\n\npublic g1_mul(Arg0: &Element<Scalar>, Arg1: &Element<G1>): Element<G1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<G1>)\n\t3: Call group_ops::mul<Scalar, G1>(u8, &Element<Scalar>, &Element<G1>): Element<G1>\n\t4: Ret\n}\n\npublic g1_div(Arg0: &Element<Scalar>, Arg1: &Element<G1>): Element<G1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<G1>)\n\t3: Call group_ops::div<Scalar, G1>(u8, &Element<Scalar>, &Element<G1>): Element<G1>\n\t4: Ret\n}\n\npublic g1_neg(Arg0: &Element<G1>): Element<G1> {\nL1:\tloc0: Element<G1>\nB0:\n\t0: Call g1_identity(): Element<G1>\n\t1: StLoc[1](loc0: Element<G1>)\n\t2: ImmBorrowLoc[1](loc0: Element<G1>)\n\t3: MoveLoc[0](Arg0: &Element<G1>)\n\t4: Call g1_sub(&Element<G1>, &Element<G1>): Element<G1>\n\t5: Ret\n}\n\npublic hash_to_g1(Arg0: &vector<u8>): Element<G1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &vector<u8>)\n\t2: Call group_ops::hash_to<G1>(u8, &vector<u8>): Element<G1>\n\t3: Ret\n}\n\npublic g1_multi_scalar_multiplication(Arg0: &vector<Element<Scalar>>, Arg1: &vector<Element<G1>>): Element<G1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &vector<Element<Scalar>>)\n\t2: MoveLoc[1](Arg1: &vector<Element<G1>>)\n\t3: Call group_ops::multi_scalar_multiplication<Scalar, G1>(u8, &vector<Element<Scalar>>, &vector<Element<G1>>): Element<G1>\n\t4: Ret\n}\n\npublic g1_to_uncompressed_g1(Arg0: &Element<G1>): Element<UncompressedG1> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: LdConst[12](u8: 4)\n\t2: MoveLoc[0](Arg0: &Element<G1>)\n\t3: Call group_ops::convert<G1, UncompressedG1>(u8, u8, &Element<G1>): Element<UncompressedG1>\n\t4: Ret\n}\n\npublic g2_from_bytes(Arg0: &vector<u8>): Element<G2> {\nB0:\n\t0: LdConst[10](u8: 2)\n\t1: MoveLoc[0](Arg0: &vector<u8>)\n\t2: LdFalse\n\t3: Call group_ops::from_bytes<G2>(u8, &vector<u8>, bool): Element<G2>\n\t4: Ret\n}\n\npublic g2_identity(): Element<G2> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[4](vector<u8>: 60c0..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[10](u8: 2)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<G2>(u8, &vector<u8>, bool): Element<G2>\n\t6: Ret\n}\n\npublic g2_generator(): Element<G2> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[5](vector<u8>: 6093..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[10](u8: 2)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<G2>(u8, &vector<u8>, bool): Element<G2>\n\t6: Ret\n}\n\npublic g2_add(Arg0: &Element<G2>, Arg1: &Element<G2>): Element<G2> {\nB0:\n\t0: LdConst[10](u8: 2)\n\t1: MoveLoc[0](Arg0: &Element<G2>)\n\t2: MoveLoc[1](Arg1: &Element<G2>)\n\t3: Call group_ops::add<G2>(u8, &Element<G2>, &Element<G2>): Element<G2>\n\t4: Ret\n}\n\npublic g2_sub(Arg0: &Element<G2>, Arg1: &Element<G2>): Element<G2> {\nB0:\n\t0: LdConst[10](u8: 2)\n\t1: MoveLoc[0](Arg0: &Element<G2>)\n\t2: MoveLoc[1](Arg1: &Element<G2>)\n\t3: Call group_ops::sub<G2>(u8, &Element<G2>, &Element<G2>): Element<G2>\n\t4: Ret\n}\n\npublic g2_mul(Arg0: &Element<Scalar>, Arg1: &Element<G2>): Element<G2> {\nB0:\n\t0: LdConst[10](u8: 2)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<G2>)\n\t3: Call group_ops::mul<Scalar, G2>(u8, &Element<Scalar>, &Element<G2>): Element<G2>\n\t4: Ret\n}\n\npublic g2_div(Arg0: &Element<Scalar>, Arg1: &Element<G2>): Element<G2> {\nB0:\n\t0: LdConst[10](u8: 2)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<G2>)\n\t3: Call group_ops::div<Scalar, G2>(u8, &Element<Scalar>, &Element<G2>): Element<G2>\n\t4: Ret\n}\n\npublic g2_neg(Arg0: &Element<G2>): Element<G2> {\nL1:\tloc0: Element<G2>\nB0:\n\t0: Call g2_identity(): Element<G2>\n\t1: StLoc[1](loc0: Element<G2>)\n\t2: ImmBorrowLoc[1](loc0: Element<G2>)\n\t3: MoveLoc[0](Arg0: &Element<G2>)\n\t4: Call g2_sub(&Element<G2>, &Element<G2>): Element<G2>\n\t5: Ret\n}\n\npublic hash_to_g2(Arg0: &vector<u8>): Element<G2> {\nB0:\n\t0: LdConst[10](u8: 2)\n\t1: MoveLoc[0](Arg0: &vector<u8>)\n\t2: Call group_ops::hash_to<G2>(u8, &vector<u8>): Element<G2>\n\t3: Ret\n}\n\npublic g2_multi_scalar_multiplication(Arg0: &vector<Element<Scalar>>, Arg1: &vector<Element<G2>>): Element<G2> {\nB0:\n\t0: LdConst[10](u8: 2)\n\t1: MoveLoc[0](Arg0: &vector<Element<Scalar>>)\n\t2: MoveLoc[1](Arg1: &vector<Element<G2>>)\n\t3: Call group_ops::multi_scalar_multiplication<Scalar, G2>(u8, &vector<Element<Scalar>>, &vector<Element<G2>>): Element<G2>\n\t4: Ret\n}\n\npublic gt_identity(): Element<GT> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[6](vector<u8>: \"\u0000\u0000\u0000..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[11](u8: 3)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<GT>(u8, &vector<u8>, bool): Element<GT>\n\t6: Ret\n}\n\npublic gt_generator(): Element<GT> {\nL0:\tloc0: vector<u8>\nB0:\n\t0: LdConst[7](vector<u8>: c004..)\n\t1: StLoc[0](loc0: vector<u8>)\n\t2: LdConst[11](u8: 3)\n\t3: ImmBorrowLoc[0](loc0: vector<u8>)\n\t4: LdTrue\n\t5: Call group_ops::from_bytes<GT>(u8, &vector<u8>, bool): Element<GT>\n\t6: Ret\n}\n\npublic gt_add(Arg0: &Element<GT>, Arg1: &Element<GT>): Element<GT> {\nB0:\n\t0: LdConst[11](u8: 3)\n\t1: MoveLoc[0](Arg0: &Element<GT>)\n\t2: MoveLoc[1](Arg1: &Element<GT>)\n\t3: Call group_ops::add<GT>(u8, &Element<GT>, &Element<GT>): Element<GT>\n\t4: Ret\n}\n\npublic gt_sub(Arg0: &Element<GT>, Arg1: &Element<GT>): Element<GT> {\nB0:\n\t0: LdConst[11](u8: 3)\n\t1: MoveLoc[0](Arg0: &Element<GT>)\n\t2: MoveLoc[1](Arg1: &Element<GT>)\n\t3: Call group_ops::sub<GT>(u8, &Element<GT>, &Element<GT>): Element<GT>\n\t4: Ret\n}\n\npublic gt_mul(Arg0: &Element<Scalar>, Arg1: &Element<GT>): Element<GT> {\nB0:\n\t0: LdConst[11](u8: 3)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<GT>)\n\t3: Call group_ops::mul<Scalar, GT>(u8, &Element<Scalar>, &Element<GT>): Element<GT>\n\t4: Ret\n}\n\npublic gt_div(Arg0: &Element<Scalar>, Arg1: &Element<GT>): Element<GT> {\nB0:\n\t0: LdConst[11](u8: 3)\n\t1: MoveLoc[0](Arg0: &Element<Scalar>)\n\t2: MoveLoc[1](Arg1: &Element<GT>)\n\t3: Call group_ops::div<Scalar, GT>(u8, &Element<Scalar>, &Element<GT>): Element<GT>\n\t4: Ret\n}\n\npublic gt_neg(Arg0: &Element<GT>): Element<GT> {\nL1:\tloc0: Element<GT>\nB0:\n\t0: Call gt_identity(): Element<GT>\n\t1: StLoc[1](loc0: Element<GT>)\n\t2: ImmBorrowLoc[1](loc0: Element<GT>)\n\t3: MoveLoc[0](Arg0: &Element<GT>)\n\t4: Call gt_sub(&Element<GT>, &Element<GT>): Element<GT>\n\t5: Ret\n}\n\npublic pairing(Arg0: &Element<G1>, Arg1: &Element<G2>): Element<GT> {\nB0:\n\t0: LdConst[9](u8: 1)\n\t1: MoveLoc[0](Arg0: &Element<G1>)\n\t2: MoveLoc[1](Arg1: &Element<G2>)\n\t3: Call group_ops::pairing<G1, G2, GT>(u8, &Element<G1>, &Element<G2>): Element<GT>\n\t4: Ret\n}\n\npublic uncompressed_g1_to_g1(Arg0: &Element<UncompressedG1>): Element<G1> {\nB0:\n\t0: LdConst[12](u8: 4)\n\t1: LdConst[9](u8: 1)\n\t2: MoveLoc[0](Arg0: &Element<UncompressedG1>)\n\t3: Call group_ops::convert<UncompressedG1, G1>(u8, u8, &Element<UncompressedG1>): Element<G1>\n\t4: Ret\n}\n\npublic uncompressed_g1_sum(Arg0: &vector<Element<UncompressedG1>>): Element<UncompressedG1> {\nB0:\n\t0: LdConst[12](u8: 4)\n\t1: MoveLoc[0](Arg0: &vector<Element<UncompressedG1>>)\n\t2: Call group_ops::sum<UncompressedG1>(u8, &vector<Element<UncompressedG1>>): Element<UncompressedG1>\n\t3: Ret\n}\n\nConstants [\n\t0 => vector<u8>: \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\" // interpreted as UTF8 string\n\t1 => vector<u8>: \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\" // interpreted as UTF8 string\n\t2 => vector<u8>: 30c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\t3 => vector<u8>: 3097f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\n\t4 => vector<u8>: 60c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\t5 => vector<u8>: 6093e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\n\t6 => vector<u8>: \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\" // interpreted as UTF8 string\n\t7 => vector<u8>: c0041250ebd871fc0a92a7b2d83168d0d727272d441befa15c503dd8e90ce98db3e7b6d194f60839c508a84305aaca1789b6089a1c5b46e5110b86750ec6a532348868a84045483c92b7af5af689452eafabf1a8943e50439f1d59882a98eaa0170f19f26337d205fb469cd6bd15c3d5a04dc88784fbb3d0b2dbdea54d43b2b73f2cbb12d58386a8703e0f948226e47ee89d06fba23eb7c5af0d9f80940ca771b6ffd5857baaf222eb95a7d2809d61bfe02e1bfd1b68ff02f0b8102ae1c2d5d5ab1a1368bb445c7c2d209703f239689ce34c0378a68e72a6b3b216da0e22a5031b54ddff57309396b38c881c4c849ec23e87193502b86edb8857c273fa075a50512937e0794e1e65a7617c90d8bd66065b1fffe51d7a579973b1315021ec3c19934f11b8b424cd48bf38fcef68083b0b0ec5c81a93b330ee1a677d0d15ff7b984e8978ef48881e32fac91b93b47333e2ba5703350f55a7aefcd3c31b4fcb6ce5771cc6a0e9786ab5973320c806ad360829107ba810c5a09ffdd9be2291a0c25a99a201b2f522473d171391125ba84dc4007cfbf2f8da752f7c74185203fcca589ac719c34dffbbaad8431dad1c1fb597aaa5018107154f25a764bd3c79937a45b84546da634b8f6be14a8061e55cceba478b23f7dacaa35c8ca78beae9624045b4b604c581234d086a9902249b64728ffd21a189e87935a954051c7cdba7b3872629a4fafc05066245cb9108f0242d0fe3ef0f41e58663bf08cf068672cbd01a7ec73baca4d72ca93544deff686bfd6df543d48eaa24afe47e1efde449383b676631\n\t8 => u8: 0\n\t9 => u8: 1\n\t10 => u8: 2\n\t11 => u8: 3\n\t12 => u8: 4\n]\n}\n","borrow":"// Move bytecode v6\nmodule 2.borrow {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Referent<Ty0: store + key> has store {\n\tid: address,\n\tvalue: Option<Ty0>\n}\n\nstruct Borrow {\n\tref: address,\n\tobj: ID\n}\n\npublic new<Ty0: store + key>(Arg0: Ty0, Arg1: &mut TxContext): Referent<Ty0> {\nB0:\n\t0: MoveLoc[1](Arg1: &mut TxContext)\n\t1: Call tx_context::fresh_object_address(&mut TxContext): address\n\t2: MoveLoc[0](Arg0: Ty0)\n\t3: Call option::some<Ty0>(Ty0): Option<Ty0>\n\t4: PackGeneric[0](Referent<Ty0>)\n\t5: Ret\n}\n\npublic borrow<Ty0: store + key>(Arg0: &mut Referent<Ty0>): Ty0 * Borrow {\nL1:\tloc0: ID\nL2:\tloc1: Ty0\nB0:\n\t0: CopyLoc[0](Arg0: &mut Referent<Ty0>)\n\t1: MutBorrowFieldGeneric[0](Referent.value: Option<Ty0>)\n\t2: Call option::extract<Ty0>(&mut Option<Ty0>): Ty0\n\t3: StLoc[2](loc1: Ty0)\n\t4: ImmBorrowLoc[2](loc1: Ty0)\n\t5: Call object::id<Ty0>(&Ty0): ID\n\t6: StLoc[1](loc0: ID)\n\t7: MoveLoc[2](loc1: Ty0)\n\t8: MoveLoc[0](Arg0: &mut Referent<Ty0>)\n\t9: ImmBorrowFieldGeneric[1](Referent.id: address)\n\t10: ReadRef\n\t11: MoveLoc[1](loc0: ID)\n\t12: Pack[1](Borrow)\n\t13: Ret\n}\n\npublic put_back<Ty0: store + key>(Arg0: &mut Referent<Ty0>, Arg1: Ty0, Arg2: Borrow) {\nL3:\tloc0: ID\nL4:\tloc1: address\nB0:\n\t0: MoveLoc[2](Arg2: Borrow)\n\t1: Unpack[1](Borrow)\n\t2: StLoc[3](loc0: ID)\n\t3: StLoc[4](loc1: address)\n\t4: ImmBorrowLoc[1](Arg1: Ty0)\n\t5: Call object::id<Ty0>(&Ty0): ID\n\t6: MoveLoc[3](loc0: ID)\n\t7: Eq\n\t8: BrFalse(10)\nB1:\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[0](Arg0: &mut Referent<Ty0>)\n\t11: Pop\n\t12: LdConst[1](u64: 1)\n\t13: Abort\nB3:\n\t14: CopyLoc[0](Arg0: &mut Referent<Ty0>)\n\t15: ImmBorrowFieldGeneric[1](Referent.id: address)\n\t16: ReadRef\n\t17: MoveLoc[4](loc1: address)\n\t18: Eq\n\t19: BrFalse(21)\nB4:\n\t20: Branch(25)\nB5:\n\t21: MoveLoc[0](Arg0: &mut Referent<Ty0>)\n\t22: Pop\n\t23: LdConst[0](u64: 0)\n\t24: Abort\nB6:\n\t25: MoveLoc[0](Arg0: &mut Referent<Ty0>)\n\t26: MutBorrowFieldGeneric[0](Referent.value: Option<Ty0>)\n\t27: MoveLoc[1](Arg1: Ty0)\n\t28: Call option::fill<Ty0>(&mut Option<Ty0>, Ty0)\n\t29: Ret\n}\n\npublic destroy<Ty0: store + key>(Arg0: Referent<Ty0>): Ty0 {\nL1:\tloc0: Option<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: Referent<Ty0>)\n\t1: UnpackGeneric[0](Referent<Ty0>)\n\t2: StLoc[1](loc0: Option<Ty0>)\n\t3: Pop\n\t4: MoveLoc[1](loc0: Option<Ty0>)\n\t5: Call option::destroy_some<Ty0>(Option<Ty0>): Ty0\n\t6: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n]\n}\n","clock":"// Move bytecode v6\nmodule 2.clock {\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Clock has key {\n\tid: UID,\n\ttimestamp_ms: u64\n}\n\npublic timestamp_ms(Arg0: &Clock): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Clock)\n\t1: ImmBorrowField[0](Clock.timestamp_ms: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\ncreate(Arg0: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[1](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: Call object::clock(): UID\n\t9: LdU64(0)\n\t10: Pack[0](Clock)\n\t11: Call transfer::share_object<Clock>(Clock)\n\t12: Ret\n}\n\nconsensus_commit_prologue(Arg0: &mut Clock, Arg1: u64, Arg2: &TxContext) {\nB0:\n\t0: MoveLoc[2](Arg2: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[1](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &mut Clock)\n\t7: Pop\n\t8: LdConst[0](u64: 0)\n\t9: Abort\nB3:\n\t10: MoveLoc[1](Arg1: u64)\n\t11: MoveLoc[0](Arg0: &mut Clock)\n\t12: MutBorrowField[0](Clock.timestamp_ms: u64)\n\t13: WriteRef\n\t14: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","coin":"// Move bytecode v6\nmodule 2.coin {\nuse 0000000000000000000000000000000000000000000000000000000000000001::ascii;\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::deny_list;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::types;\nuse 0000000000000000000000000000000000000000000000000000000000000002::url;\n\nstruct Coin<phantom Ty0> has store, key {\n\tid: UID,\n\tbalance: Balance<Ty0>\n}\n\nstruct CoinMetadata<phantom Ty0> has store, key {\n\tid: UID,\n\tdecimals: u8,\n\tname: String,\n\tsymbol: String,\n\tdescription: String,\n\ticon_url: Option<Url>\n}\n\nstruct RegulatedCoinMetadata<phantom Ty0> has key {\n\tid: UID,\n\tcoin_metadata_object: ID,\n\tdeny_cap_object: ID\n}\n\nstruct TreasuryCap<phantom Ty0> has store, key {\n\tid: UID,\n\ttotal_supply: Supply<Ty0>\n}\n\nstruct DenyCapV2<phantom Ty0> has store, key {\n\tid: UID,\n\tallow_global_pause: bool\n}\n\nstruct CurrencyCreated<phantom Ty0> has copy, drop {\n\tdecimals: u8\n}\n\nstruct DenyCap<phantom Ty0> has store, key {\n\tid: UID\n}\n\npublic total_supply<Ty0>(Arg0: &TreasuryCap<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &TreasuryCap<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](TreasuryCap.total_supply: Supply<Ty0>)\n\t2: Call balance::supply_value<Ty0>(&Supply<Ty0>): u64\n\t3: Ret\n}\n\npublic treasury_into_supply<Ty0>(Arg0: TreasuryCap<Ty0>): Supply<Ty0> {\nL1:\tloc0: Supply<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: TreasuryCap<Ty0>)\n\t1: UnpackGeneric[0](TreasuryCap<Ty0>)\n\t2: StLoc[1](loc0: Supply<Ty0>)\n\t3: Call object::delete(UID)\n\t4: MoveLoc[1](loc0: Supply<Ty0>)\n\t5: Ret\n}\n\npublic supply_immut<Ty0>(Arg0: &TreasuryCap<Ty0>): &Supply<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &TreasuryCap<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](TreasuryCap.total_supply: Supply<Ty0>)\n\t2: Ret\n}\n\npublic supply_mut<Ty0>(Arg0: &mut TreasuryCap<Ty0>): &mut Supply<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t1: MutBorrowFieldGeneric[0](TreasuryCap.total_supply: Supply<Ty0>)\n\t2: Ret\n}\n\npublic value<Ty0>(Arg0: &Coin<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Coin<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](Coin.balance: Balance<Ty0>)\n\t2: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t3: Ret\n}\n\npublic balance<Ty0>(Arg0: &Coin<Ty0>): &Balance<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &Coin<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](Coin.balance: Balance<Ty0>)\n\t2: Ret\n}\n\npublic balance_mut<Ty0>(Arg0: &mut Coin<Ty0>): &mut Balance<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t1: MutBorrowFieldGeneric[1](Coin.balance: Balance<Ty0>)\n\t2: Ret\n}\n\npublic from_balance<Ty0>(Arg0: Balance<Ty0>, Arg1: &mut TxContext): Coin<Ty0> {\nB0:\n\t0: MoveLoc[1](Arg1: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: MoveLoc[0](Arg0: Balance<Ty0>)\n\t3: PackGeneric[1](Coin<Ty0>)\n\t4: Ret\n}\n\npublic into_balance<Ty0>(Arg0: Coin<Ty0>): Balance<Ty0> {\nL1:\tloc0: Balance<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: Coin<Ty0>)\n\t1: UnpackGeneric[1](Coin<Ty0>)\n\t2: StLoc[1](loc0: Balance<Ty0>)\n\t3: Call object::delete(UID)\n\t4: MoveLoc[1](loc0: Balance<Ty0>)\n\t5: Ret\n}\n\npublic take<Ty0>(Arg0: &mut Balance<Ty0>, Arg1: u64, Arg2: &mut TxContext): Coin<Ty0> {\nB0:\n\t0: MoveLoc[2](Arg2: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: MoveLoc[0](Arg0: &mut Balance<Ty0>)\n\t3: MoveLoc[1](Arg1: u64)\n\t4: Call balance::split<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t5: PackGeneric[1](Coin<Ty0>)\n\t6: Ret\n}\n\npublic put<Ty0>(Arg0: &mut Balance<Ty0>, Arg1: Coin<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Balance<Ty0>)\n\t1: MoveLoc[1](Arg1: Coin<Ty0>)\n\t2: Call into_balance<Ty0>(Coin<Ty0>): Balance<Ty0>\n\t3: Call balance::join<Ty0>(&mut Balance<Ty0>, Balance<Ty0>): u64\n\t4: Pop\n\t5: Ret\n}\n\nentry public join<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: Coin<Ty0>) {\nL2:\tloc0: Balance<Ty0>\nB0:\n\t0: MoveLoc[1](Arg1: Coin<Ty0>)\n\t1: UnpackGeneric[1](Coin<Ty0>)\n\t2: StLoc[2](loc0: Balance<Ty0>)\n\t3: Call object::delete(UID)\n\t4: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t5: MutBorrowFieldGeneric[1](Coin.balance: Balance<Ty0>)\n\t6: MoveLoc[2](loc0: Balance<Ty0>)\n\t7: Call balance::join<Ty0>(&mut Balance<Ty0>, Balance<Ty0>): u64\n\t8: Pop\n\t9: Ret\n}\n\npublic split<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: u64, Arg2: &mut TxContext): Coin<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t1: MutBorrowFieldGeneric[1](Coin.balance: Balance<Ty0>)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: MoveLoc[2](Arg2: &mut TxContext)\n\t4: Call take<Ty0>(&mut Balance<Ty0>, u64, &mut TxContext): Coin<Ty0>\n\t5: Ret\n}\n\npublic divide_into_n<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: u64, Arg2: &mut TxContext): vector<Coin<Ty0>> {\nL3:\tloc0: u64\nL4:\tloc1: Coin<Ty0>\nL5:\tloc2: &mut vector<Coin<Ty0>>\nL6:\tloc3: u64\nL7:\tloc4: u64\nL8:\tloc5: u64\nL9:\tloc6: u64\nL10:\tloc7: vector<Coin<Ty0>>\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: LdU64(0)\n\t2: Gt\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t6: Pop\n\t7: MoveLoc[2](Arg2: &mut TxContext)\n\t8: Pop\n\t9: LdConst[1](u64: 1)\n\t10: Abort\nB3:\n\t11: CopyLoc[1](Arg1: u64)\n\t12: CopyLoc[0](Arg0: &mut Coin<Ty0>)\n\t13: FreezeRef\n\t14: Call value<Ty0>(&Coin<Ty0>): u64\n\t15: Le\n\t16: BrFalse(18)\nB4:\n\t17: Branch(24)\nB5:\n\t18: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t19: Pop\n\t20: MoveLoc[2](Arg2: &mut TxContext)\n\t21: Pop\n\t22: LdConst[2](u64: 2)\n\t23: Abort\nB6:\n\t24: CopyLoc[0](Arg0: &mut Coin<Ty0>)\n\t25: FreezeRef\n\t26: Call value<Ty0>(&Coin<Ty0>): u64\n\t27: CopyLoc[1](Arg1: u64)\n\t28: Div\n\t29: StLoc[8](loc5: u64)\n\t30: VecPack(12, 0)\n\t31: StLoc[10](loc7: vector<Coin<Ty0>>)\n\t32: MoveLoc[1](Arg1: u64)\n\t33: LdU64(1)\n\t34: Sub\n\t35: StLoc[3](loc0: u64)\n\t36: LdU64(0)\n\t37: StLoc[7](loc4: u64)\n\t38: MoveLoc[3](loc0: u64)\n\t39: StLoc[9](loc6: u64)\nB7:\n\t40: CopyLoc[7](loc4: u64)\n\t41: CopyLoc[9](loc6: u64)\n\t42: Lt\n\t43: BrFalse(63)\nB8:\n\t44: CopyLoc[7](loc4: u64)\n\t45: StLoc[6](loc3: u64)\n\t46: MutBorrowLoc[10](loc7: vector<Coin<Ty0>>)\n\t47: StLoc[5](loc2: &mut vector<Coin<Ty0>>)\n\t48: MoveLoc[6](loc3: u64)\n\t49: Pop\n\t50: CopyLoc[0](Arg0: &mut Coin<Ty0>)\n\t51: CopyLoc[8](loc5: u64)\n\t52: CopyLoc[2](Arg2: &mut TxContext)\n\t53: Call split<Ty0>(&mut Coin<Ty0>, u64, &mut TxContext): Coin<Ty0>\n\t54: StLoc[4](loc1: Coin<Ty0>)\n\t55: MoveLoc[5](loc2: &mut vector<Coin<Ty0>>)\n\t56: MoveLoc[4](loc1: Coin<Ty0>)\n\t57: VecPushBack(12)\n\t58: MoveLoc[7](loc4: u64)\n\t59: LdU64(1)\n\t60: Add\n\t61: StLoc[7](loc4: u64)\n\t62: Branch(40)\nB9:\n\t63: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t64: Pop\n\t65: MoveLoc[2](Arg2: &mut TxContext)\n\t66: Pop\n\t67: MoveLoc[10](loc7: vector<Coin<Ty0>>)\n\t68: Ret\n}\n\npublic zero<Ty0>(Arg0: &mut TxContext): Coin<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: Call balance::zero<Ty0>(): Balance<Ty0>\n\t3: PackGeneric[1](Coin<Ty0>)\n\t4: Ret\n}\n\npublic destroy_zero<Ty0>(Arg0: Coin<Ty0>) {\nL1:\tloc0: Balance<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: Coin<Ty0>)\n\t1: UnpackGeneric[1](Coin<Ty0>)\n\t2: StLoc[1](loc0: Balance<Ty0>)\n\t3: Call object::delete(UID)\n\t4: MoveLoc[1](loc0: Balance<Ty0>)\n\t5: Call balance::destroy_zero<Ty0>(Balance<Ty0>)\n\t6: Ret\n}\n\npublic create_currency<Ty0: drop>(Arg0: Ty0, Arg1: u8, Arg2: vector<u8>, Arg3: vector<u8>, Arg4: vector<u8>, Arg5: Option<Url>, Arg6: &mut TxContext): TreasuryCap<Ty0> * CoinMetadata<Ty0> {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: Ty0)\n\t1: Call types::is_one_time_witness<Ty0>(&Ty0): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(8)\nB2:\n\t4: MoveLoc[6](Arg6: &mut TxContext)\n\t5: Pop\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: CopyLoc[6](Arg6: &mut TxContext)\n\t9: Call object::new(&mut TxContext): UID\n\t10: MoveLoc[0](Arg0: Ty0)\n\t11: Call balance::create_supply<Ty0>(Ty0): Supply<Ty0>\n\t12: PackGeneric[0](TreasuryCap<Ty0>)\n\t13: MoveLoc[6](Arg6: &mut TxContext)\n\t14: Call object::new(&mut TxContext): UID\n\t15: MoveLoc[1](Arg1: u8)\n\t16: MoveLoc[3](Arg3: vector<u8>)\n\t17: Call string::utf8(vector<u8>): String\n\t18: MoveLoc[2](Arg2: vector<u8>)\n\t19: Call ascii::string(vector<u8>): String\n\t20: MoveLoc[4](Arg4: vector<u8>)\n\t21: Call string::utf8(vector<u8>): String\n\t22: MoveLoc[5](Arg5: Option<Url>)\n\t23: PackGeneric[2](CoinMetadata<Ty0>)\n\t24: Ret\n}\n\npublic create_regulated_currency_v2<Ty0: drop>(Arg0: Ty0, Arg1: u8, Arg2: vector<u8>, Arg3: vector<u8>, Arg4: vector<u8>, Arg5: Option<Url>, Arg6: bool, Arg7: &mut TxContext): TreasuryCap<Ty0> * DenyCapV2<Ty0> * CoinMetadata<Ty0> {\nL8:\tloc0: DenyCapV2<Ty0>\nL9:\tloc1: CoinMetadata<Ty0>\nL10:\tloc2: TreasuryCap<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: MoveLoc[1](Arg1: u8)\n\t2: MoveLoc[2](Arg2: vector<u8>)\n\t3: MoveLoc[3](Arg3: vector<u8>)\n\t4: MoveLoc[4](Arg4: vector<u8>)\n\t5: MoveLoc[5](Arg5: Option<Url>)\n\t6: CopyLoc[7](Arg7: &mut TxContext)\n\t7: Call create_currency<Ty0>(Ty0, u8, vector<u8>, vector<u8>, vector<u8>, Option<Url>, &mut TxContext): TreasuryCap<Ty0> * CoinMetadata<Ty0>\n\t8: StLoc[9](loc1: CoinMetadata<Ty0>)\n\t9: StLoc[10](loc2: TreasuryCap<Ty0>)\n\t10: CopyLoc[7](Arg7: &mut TxContext)\n\t11: Call object::new(&mut TxContext): UID\n\t12: MoveLoc[6](Arg6: bool)\n\t13: PackGeneric[3](DenyCapV2<Ty0>)\n\t14: StLoc[8](loc0: DenyCapV2<Ty0>)\n\t15: MoveLoc[7](Arg7: &mut TxContext)\n\t16: Call object::new(&mut TxContext): UID\n\t17: ImmBorrowLoc[9](loc1: CoinMetadata<Ty0>)\n\t18: Call object::id<CoinMetadata<Ty0>>(&CoinMetadata<Ty0>): ID\n\t19: ImmBorrowLoc[8](loc0: DenyCapV2<Ty0>)\n\t20: Call object::id<DenyCapV2<Ty0>>(&DenyCapV2<Ty0>): ID\n\t21: PackGeneric[4](RegulatedCoinMetadata<Ty0>)\n\t22: Call transfer::freeze_object<RegulatedCoinMetadata<Ty0>>(RegulatedCoinMetadata<Ty0>)\n\t23: MoveLoc[10](loc2: TreasuryCap<Ty0>)\n\t24: MoveLoc[8](loc0: DenyCapV2<Ty0>)\n\t25: MoveLoc[9](loc1: CoinMetadata<Ty0>)\n\t26: Ret\n}\n\npublic migrate_regulated_currency_to_v2<Ty0>(Arg0: &mut DenyList, Arg1: DenyCap<Ty0>, Arg2: bool, Arg3: &mut TxContext): DenyCapV2<Ty0> {\nL4:\tloc0: vector<u8>\nB0:\n\t0: MoveLoc[1](Arg1: DenyCap<Ty0>)\n\t1: UnpackGeneric[5](DenyCap<Ty0>)\n\t2: Call object::delete(UID)\n\t3: Call type_name::with_original_ids<Ty0>(): TypeName\n\t4: Call type_name::into_string(TypeName): String\n\t5: Call ascii::into_bytes(String): vector<u8>\n\t6: StLoc[4](loc0: vector<u8>)\n\t7: MoveLoc[0](Arg0: &mut DenyList)\n\t8: LdConst[0](u64: 0)\n\t9: MoveLoc[4](loc0: vector<u8>)\n\t10: CopyLoc[3](Arg3: &mut TxContext)\n\t11: Call deny_list::migrate_v1_to_v2(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t12: MoveLoc[3](Arg3: &mut TxContext)\n\t13: Call object::new(&mut TxContext): UID\n\t14: MoveLoc[2](Arg2: bool)\n\t15: PackGeneric[3](DenyCapV2<Ty0>)\n\t16: Ret\n}\n\npublic mint<Ty0>(Arg0: &mut TreasuryCap<Ty0>, Arg1: u64, Arg2: &mut TxContext): Coin<Ty0> {\nB0:\n\t0: MoveLoc[2](Arg2: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t3: MutBorrowFieldGeneric[0](TreasuryCap.total_supply: Supply<Ty0>)\n\t4: MoveLoc[1](Arg1: u64)\n\t5: Call balance::increase_supply<Ty0>(&mut Supply<Ty0>, u64): Balance<Ty0>\n\t6: PackGeneric[1](Coin<Ty0>)\n\t7: Ret\n}\n\npublic mint_balance<Ty0>(Arg0: &mut TreasuryCap<Ty0>, Arg1: u64): Balance<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t1: MutBorrowFieldGeneric[0](TreasuryCap.total_supply: Supply<Ty0>)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: Call balance::increase_supply<Ty0>(&mut Supply<Ty0>, u64): Balance<Ty0>\n\t4: Ret\n}\n\nentry public burn<Ty0>(Arg0: &mut TreasuryCap<Ty0>, Arg1: Coin<Ty0>): u64 {\nL2:\tloc0: Balance<Ty0>\nB0:\n\t0: MoveLoc[1](Arg1: Coin<Ty0>)\n\t1: UnpackGeneric[1](Coin<Ty0>)\n\t2: StLoc[2](loc0: Balance<Ty0>)\n\t3: Call object::delete(UID)\n\t4: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t5: MutBorrowFieldGeneric[0](TreasuryCap.total_supply: Supply<Ty0>)\n\t6: MoveLoc[2](loc0: Balance<Ty0>)\n\t7: Call balance::decrease_supply<Ty0>(&mut Supply<Ty0>, Balance<Ty0>): u64\n\t8: Ret\n}\n\npublic deny_list_v2_add<Ty0>(Arg0: &mut DenyList, Arg1: &mut DenyCapV2<Ty0>, Arg2: address, Arg3: &mut TxContext) {\nL4:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[4](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &mut DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[4](loc0: vector<u8>)\n\t7: MoveLoc[2](Arg2: address)\n\t8: MoveLoc[3](Arg3: &mut TxContext)\n\t9: Call deny_list::v2_add(&mut DenyList, u64, vector<u8>, address, &mut TxContext)\n\t10: Ret\n}\n\npublic deny_list_v2_remove<Ty0>(Arg0: &mut DenyList, Arg1: &mut DenyCapV2<Ty0>, Arg2: address, Arg3: &mut TxContext) {\nL4:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[4](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &mut DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[4](loc0: vector<u8>)\n\t7: MoveLoc[2](Arg2: address)\n\t8: MoveLoc[3](Arg3: &mut TxContext)\n\t9: Call deny_list::v2_remove(&mut DenyList, u64, vector<u8>, address, &mut TxContext)\n\t10: Ret\n}\n\npublic deny_list_v2_contains_current_epoch<Ty0>(Arg0: &DenyList, Arg1: address, Arg2: &TxContext): bool {\nL3:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[3](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[3](loc0: vector<u8>)\n\t7: MoveLoc[1](Arg1: address)\n\t8: MoveLoc[2](Arg2: &TxContext)\n\t9: Call deny_list::v2_contains_current_epoch(&DenyList, u64, vector<u8>, address, &TxContext): bool\n\t10: Ret\n}\n\npublic deny_list_v2_contains_next_epoch<Ty0>(Arg0: &DenyList, Arg1: address): bool {\nL2:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[2](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[2](loc0: vector<u8>)\n\t7: MoveLoc[1](Arg1: address)\n\t8: Call deny_list::v2_contains_next_epoch(&DenyList, u64, vector<u8>, address): bool\n\t9: Ret\n}\n\npublic deny_list_v2_enable_global_pause<Ty0>(Arg0: &mut DenyList, Arg1: &mut DenyCapV2<Ty0>, Arg2: &mut TxContext) {\nL3:\tloc0: vector<u8>\nB0:\n\t0: MoveLoc[1](Arg1: &mut DenyCapV2<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](DenyCapV2.allow_global_pause: bool)\n\t2: ReadRef\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut DenyList)\n\t6: Pop\n\t7: MoveLoc[2](Arg2: &mut TxContext)\n\t8: Pop\n\t9: LdConst[3](u64: 3)\n\t10: Abort\nB3:\n\t11: Call type_name::with_original_ids<Ty0>(): TypeName\n\t12: Call type_name::into_string(TypeName): String\n\t13: Call ascii::into_bytes(String): vector<u8>\n\t14: StLoc[3](loc0: vector<u8>)\n\t15: MoveLoc[0](Arg0: &mut DenyList)\n\t16: LdConst[0](u64: 0)\n\t17: MoveLoc[3](loc0: vector<u8>)\n\t18: MoveLoc[2](Arg2: &mut TxContext)\n\t19: Call deny_list::v2_enable_global_pause(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t20: Ret\n}\n\npublic deny_list_v2_disable_global_pause<Ty0>(Arg0: &mut DenyList, Arg1: &mut DenyCapV2<Ty0>, Arg2: &mut TxContext) {\nL3:\tloc0: vector<u8>\nB0:\n\t0: MoveLoc[1](Arg1: &mut DenyCapV2<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](DenyCapV2.allow_global_pause: bool)\n\t2: ReadRef\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut DenyList)\n\t6: Pop\n\t7: MoveLoc[2](Arg2: &mut TxContext)\n\t8: Pop\n\t9: LdConst[3](u64: 3)\n\t10: Abort\nB3:\n\t11: Call type_name::with_original_ids<Ty0>(): TypeName\n\t12: Call type_name::into_string(TypeName): String\n\t13: Call ascii::into_bytes(String): vector<u8>\n\t14: StLoc[3](loc0: vector<u8>)\n\t15: MoveLoc[0](Arg0: &mut DenyList)\n\t16: LdConst[0](u64: 0)\n\t17: MoveLoc[3](loc0: vector<u8>)\n\t18: MoveLoc[2](Arg2: &mut TxContext)\n\t19: Call deny_list::v2_disable_global_pause(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t20: Ret\n}\n\npublic deny_list_v2_is_global_pause_enabled_current_epoch<Ty0>(Arg0: &DenyList, Arg1: &TxContext): bool {\nL2:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[2](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[2](loc0: vector<u8>)\n\t7: MoveLoc[1](Arg1: &TxContext)\n\t8: Call deny_list::v2_is_global_pause_enabled_current_epoch(&DenyList, u64, vector<u8>, &TxContext): bool\n\t9: Ret\n}\n\npublic deny_list_v2_is_global_pause_enabled_next_epoch<Ty0>(Arg0: &DenyList): bool {\nL1:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[1](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[1](loc0: vector<u8>)\n\t7: Call deny_list::v2_is_global_pause_enabled_next_epoch(&DenyList, u64, vector<u8>): bool\n\t8: Ret\n}\n\nentry public mint_and_transfer<Ty0>(Arg0: &mut TreasuryCap<Ty0>, Arg1: u64, Arg2: address, Arg3: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: MoveLoc[3](Arg3: &mut TxContext)\n\t3: Call mint<Ty0>(&mut TreasuryCap<Ty0>, u64, &mut TxContext): Coin<Ty0>\n\t4: MoveLoc[2](Arg2: address)\n\t5: Call transfer::public_transfer<Coin<Ty0>>(Coin<Ty0>, address)\n\t6: Ret\n}\n\nentry public update_name<Ty0>(Arg0: &TreasuryCap<Ty0>, Arg1: &mut CoinMetadata<Ty0>, Arg2: String) {\nB0:\n\t0: MoveLoc[2](Arg2: String)\n\t1: MoveLoc[1](Arg1: &mut CoinMetadata<Ty0>)\n\t2: MutBorrowFieldGeneric[3](CoinMetadata.name: String)\n\t3: WriteRef\n\t4: Ret\n}\n\nentry public update_symbol<Ty0>(Arg0: &TreasuryCap<Ty0>, Arg1: &mut CoinMetadata<Ty0>, Arg2: String) {\nB0:\n\t0: MoveLoc[2](Arg2: String)\n\t1: MoveLoc[1](Arg1: &mut CoinMetadata<Ty0>)\n\t2: MutBorrowFieldGeneric[4](CoinMetadata.symbol: String)\n\t3: WriteRef\n\t4: Ret\n}\n\nentry public update_description<Ty0>(Arg0: &TreasuryCap<Ty0>, Arg1: &mut CoinMetadata<Ty0>, Arg2: String) {\nB0:\n\t0: MoveLoc[2](Arg2: String)\n\t1: MoveLoc[1](Arg1: &mut CoinMetadata<Ty0>)\n\t2: MutBorrowFieldGeneric[5](CoinMetadata.description: String)\n\t3: WriteRef\n\t4: Ret\n}\n\nentry public update_icon_url<Ty0>(Arg0: &TreasuryCap<Ty0>, Arg1: &mut CoinMetadata<Ty0>, Arg2: String) {\nB0:\n\t0: MoveLoc[2](Arg2: String)\n\t1: Call url::new_unsafe(String): Url\n\t2: Call option::some<Url>(Url): Option<Url>\n\t3: MoveLoc[1](Arg1: &mut CoinMetadata<Ty0>)\n\t4: MutBorrowFieldGeneric[6](CoinMetadata.icon_url: Option<Url>)\n\t5: WriteRef\n\t6: Ret\n}\n\npublic get_decimals<Ty0>(Arg0: &CoinMetadata<Ty0>): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: &CoinMetadata<Ty0>)\n\t1: ImmBorrowFieldGeneric[7](CoinMetadata.decimals: u8)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic get_name<Ty0>(Arg0: &CoinMetadata<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &CoinMetadata<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](CoinMetadata.name: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic get_symbol<Ty0>(Arg0: &CoinMetadata<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &CoinMetadata<Ty0>)\n\t1: ImmBorrowFieldGeneric[4](CoinMetadata.symbol: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic get_description<Ty0>(Arg0: &CoinMetadata<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &CoinMetadata<Ty0>)\n\t1: ImmBorrowFieldGeneric[5](CoinMetadata.description: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic get_icon_url<Ty0>(Arg0: &CoinMetadata<Ty0>): Option<Url> {\nB0:\n\t0: MoveLoc[0](Arg0: &CoinMetadata<Ty0>)\n\t1: ImmBorrowFieldGeneric[6](CoinMetadata.icon_url: Option<Url>)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic(friend) destroy_metadata<Ty0>(Arg0: CoinMetadata<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: CoinMetadata<Ty0>)\n\t1: UnpackGeneric[2](CoinMetadata<Ty0>)\n\t2: Pop\n\t3: Pop\n\t4: Pop\n\t5: Pop\n\t6: Pop\n\t7: Call object::delete(UID)\n\t8: Ret\n}\n\npublic(friend) deny_cap_id<Ty0>(Arg0: &RegulatedCoinMetadata<Ty0>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &RegulatedCoinMetadata<Ty0>)\n\t1: ImmBorrowFieldGeneric[8](RegulatedCoinMetadata.deny_cap_object: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic(friend) new_deny_cap_v2<Ty0>(Arg0: bool, Arg1: &mut TxContext): DenyCapV2<Ty0> {\nB0:\n\t0: MoveLoc[1](Arg1: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: MoveLoc[0](Arg0: bool)\n\t3: PackGeneric[3](DenyCapV2<Ty0>)\n\t4: Ret\n}\n\npublic(friend) new_treasury_cap<Ty0>(Arg0: &mut TxContext): TreasuryCap<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: Call balance::create_supply_internal<Ty0>(): Supply<Ty0>\n\t3: PackGeneric[0](TreasuryCap<Ty0>)\n\t4: Ret\n}\n\npublic(friend) allow_global_pause<Ty0>(Arg0: &DenyCapV2<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &DenyCapV2<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](DenyCapV2.allow_global_pause: bool)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic supply<Ty0>(Arg0: &mut TreasuryCap<Ty0>): &Supply<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](TreasuryCap.total_supply: Supply<Ty0>)\n\t2: Ret\n}\n\npublic create_regulated_currency<Ty0: drop>(Arg0: Ty0, Arg1: u8, Arg2: vector<u8>, Arg3: vector<u8>, Arg4: vector<u8>, Arg5: Option<Url>, Arg6: &mut TxContext): TreasuryCap<Ty0> * DenyCap<Ty0> * CoinMetadata<Ty0> {\nL7:\tloc0: DenyCap<Ty0>\nL8:\tloc1: CoinMetadata<Ty0>\nL9:\tloc2: TreasuryCap<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: MoveLoc[1](Arg1: u8)\n\t2: MoveLoc[2](Arg2: vector<u8>)\n\t3: MoveLoc[3](Arg3: vector<u8>)\n\t4: MoveLoc[4](Arg4: vector<u8>)\n\t5: MoveLoc[5](Arg5: Option<Url>)\n\t6: CopyLoc[6](Arg6: &mut TxContext)\n\t7: Call create_currency<Ty0>(Ty0, u8, vector<u8>, vector<u8>, vector<u8>, Option<Url>, &mut TxContext): TreasuryCap<Ty0> * CoinMetadata<Ty0>\n\t8: StLoc[8](loc1: CoinMetadata<Ty0>)\n\t9: StLoc[9](loc2: TreasuryCap<Ty0>)\n\t10: CopyLoc[6](Arg6: &mut TxContext)\n\t11: Call object::new(&mut TxContext): UID\n\t12: PackGeneric[5](DenyCap<Ty0>)\n\t13: StLoc[7](loc0: DenyCap<Ty0>)\n\t14: MoveLoc[6](Arg6: &mut TxContext)\n\t15: Call object::new(&mut TxContext): UID\n\t16: ImmBorrowLoc[8](loc1: CoinMetadata<Ty0>)\n\t17: Call object::id<CoinMetadata<Ty0>>(&CoinMetadata<Ty0>): ID\n\t18: ImmBorrowLoc[7](loc0: DenyCap<Ty0>)\n\t19: Call object::id<DenyCap<Ty0>>(&DenyCap<Ty0>): ID\n\t20: PackGeneric[4](RegulatedCoinMetadata<Ty0>)\n\t21: Call transfer::freeze_object<RegulatedCoinMetadata<Ty0>>(RegulatedCoinMetadata<Ty0>)\n\t22: MoveLoc[9](loc2: TreasuryCap<Ty0>)\n\t23: MoveLoc[7](loc0: DenyCap<Ty0>)\n\t24: MoveLoc[8](loc1: CoinMetadata<Ty0>)\n\t25: Ret\n}\n\npublic deny_list_add<Ty0>(Arg0: &mut DenyList, Arg1: &mut DenyCap<Ty0>, Arg2: address, Arg3: &mut TxContext) {\nL4:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::get_with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[4](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &mut DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[4](loc0: vector<u8>)\n\t7: MoveLoc[2](Arg2: address)\n\t8: Call deny_list::v1_add(&mut DenyList, u64, vector<u8>, address)\n\t9: Ret\n}\n\npublic deny_list_remove<Ty0>(Arg0: &mut DenyList, Arg1: &mut DenyCap<Ty0>, Arg2: address, Arg3: &mut TxContext) {\nL4:\tloc0: vector<u8>\nB0:\n\t0: Call type_name::get_with_original_ids<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: Call ascii::into_bytes(String): vector<u8>\n\t3: StLoc[4](loc0: vector<u8>)\n\t4: MoveLoc[0](Arg0: &mut DenyList)\n\t5: LdConst[0](u64: 0)\n\t6: MoveLoc[4](loc0: vector<u8>)\n\t7: MoveLoc[2](Arg2: address)\n\t8: Call deny_list::v1_remove(&mut DenyList, u64, vector<u8>, address)\n\t9: Ret\n}\n\npublic deny_list_contains<Ty0>(Arg0: &DenyList, Arg1: address): bool {\nL2:\tloc0: TypeName\nL3:\tloc1: vector<u8>\nB0:\n\t0: Call type_name::get_with_original_ids<Ty0>(): TypeName\n\t1: StLoc[2](loc0: TypeName)\n\t2: ImmBorrowLoc[2](loc0: TypeName)\n\t3: Call type_name::is_primitive(&TypeName): bool\n\t4: BrFalse(9)\nB1:\n\t5: MoveLoc[0](Arg0: &DenyList)\n\t6: Pop\n\t7: LdFalse\n\t8: Ret\nB2:\n\t9: MoveLoc[2](loc0: TypeName)\n\t10: Call type_name::into_string(TypeName): String\n\t11: Call ascii::into_bytes(String): vector<u8>\n\t12: StLoc[3](loc1: vector<u8>)\n\t13: MoveLoc[0](Arg0: &DenyList)\n\t14: LdConst[0](u64: 0)\n\t15: MoveLoc[3](loc1: vector<u8>)\n\t16: MoveLoc[1](Arg1: address)\n\t17: Call deny_list::v1_contains(&DenyList, u64, vector<u8>, address): bool\n\t18: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n]\n}\n","coin_registry":"// Move bytecode v7\nmodule 2.coin_registry {\nuse 0000000000000000000000000000000000000000000000000000000000000001::ascii;\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::bag;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::derived_object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::types;\nuse 0000000000000000000000000000000000000000000000000000000000000002::url;\nuse 0000000000000000000000000000000000000000000000000000000000000002::vec_map;\n\nstruct CoinRegistry has key {\n\tid: UID\n}\n\nstruct ExtraField has store {\n\tpos0: TypeName,\n\tpos1: vector<u8>\n}\n\nstruct CurrencyKey<phantom Ty0> has copy, drop, store {\n\tdummy_field: bool\n}\n\nstruct MetadataCap<phantom Ty0> has store, key {\n\tid: UID\n}\n\nstruct Currency<phantom Ty0> has key {\n\tid: UID,\n\tdecimals: u8,\n\tname: String,\n\tsymbol: String,\n\tdescription: String,\n\ticon_url: String,\n\tsupply: Option<SupplyState<Ty0>>,\n\tregulated: RegulatedState,\n\ttreasury_cap_id: Option<ID>,\n\tmetadata_cap_id: MetadataCapState,\n\textra_fields: VecMap<String, ExtraField>\n}\n\nstruct CurrencyInitializer<phantom Ty0> {\n\tcurrency: Currency<Ty0>,\n\textra_fields: Bag,\n\tis_otw: bool\n}\n\nenum SupplyState<phantom Ty0> has store {\n\tFixed { pos0: Supply<Ty0> },\n\tBurnOnly { pos0: Supply<Ty0> },\n\tUnknown {  }\n}\n\nenum RegulatedState has copy, drop, store {\n\tRegulated { cap: ID, allow_global_pause: Option<bool>, variant: u8 },\n\tUnregulated {  },\n\tUnknown {  }\n}\n\nenum MetadataCapState has copy, drop, store {\n\tClaimed { pos0: ID },\n\tUnclaimed {  },\n\tDeleted {  }\n}\n\npublic new_currency<Ty0: key>(Arg0: &mut CoinRegistry, Arg1: u8, Arg2: String, Arg3: String, Arg4: String, Arg5: String, Arg6: &mut TxContext): CurrencyInitializer<Ty0> * TreasuryCap<Ty0> {\nL7:\tloc0: u64\nL8:\tloc1: bool\nL9:\tloc2: Currency<Ty0>\nL10:\tloc3: Bag\nL11:\tloc4: u64\nL12:\tloc5: u64\nL13:\tloc6: u64\nL14:\tloc7: TreasuryCap<Ty0>\nL15:\tloc8: &vector<u8>\nB0:\n\t0: CopyLoc[0](Arg0: &mut CoinRegistry)\n\t1: FreezeRef\n\t2: Call exists<Ty0>(&CoinRegistry): bool\n\t3: Not\n\t4: BrFalse(6)\nB1:\n\t5: Branch(12)\nB2:\n\t6: MoveLoc[0](Arg0: &mut CoinRegistry)\n\t7: Pop\n\t8: MoveLoc[6](Arg6: &mut TxContext)\n\t9: Pop\n\t10: LdU64(13835621739675254789)\n\t11: Abort\nB3:\n\t12: ImmBorrowLoc[2](Arg2: String)\n\t13: Call string::as_bytes(&String): &vector<u8>\n\t14: StLoc[15](loc8: &vector<u8>)\n\t15: CopyLoc[15](loc8: &vector<u8>)\n\t16: VecLen(23)\n\t17: StLoc[7](loc0: u64)\n\t18: LdU64(0)\n\t19: StLoc[11](loc4: u64)\n\t20: MoveLoc[7](loc0: u64)\n\t21: StLoc[13](loc6: u64)\nB4:\n\t22: CopyLoc[11](loc4: u64)\n\t23: CopyLoc[13](loc6: u64)\n\t24: Lt\n\t25: BrFalse(45)\nB5:\n\t26: CopyLoc[11](loc4: u64)\n\t27: StLoc[12](loc5: u64)\n\t28: CopyLoc[15](loc8: &vector<u8>)\n\t29: MoveLoc[12](loc5: u64)\n\t30: VecImmBorrow(23)\n\t31: ReadRef\n\t32: Call ascii::is_printable_char(u8): bool\n\t33: Not\n\t34: BrFalse(40)\nB6:\n\t35: MoveLoc[15](loc8: &vector<u8>)\n\t36: Pop\n\t37: LdFalse\n\t38: StLoc[8](loc1: bool)\n\t39: Branch(49)\nB7:\n\t40: MoveLoc[11](loc4: u64)\n\t41: LdU64(1)\n\t42: Add\n\t43: StLoc[11](loc4: u64)\n\t44: Branch(22)\nB8:\n\t45: MoveLoc[15](loc8: &vector<u8>)\n\t46: Pop\n\t47: LdTrue\n\t48: StLoc[8](loc1: bool)\nB9:\n\t49: MoveLoc[8](loc1: bool)\n\t50: BrFalse(52)\nB10:\n\t51: Branch(58)\nB11:\n\t52: MoveLoc[0](Arg0: &mut CoinRegistry)\n\t53: Pop\n\t54: MoveLoc[6](Arg6: &mut TxContext)\n\t55: Pop\n\t56: LdU64(13836747643877589005)\n\t57: Abort\nB12:\n\t58: CopyLoc[6](Arg6: &mut TxContext)\n\t59: Call coin::new_treasury_cap<Ty0>(&mut TxContext): TreasuryCap<Ty0>\n\t60: StLoc[14](loc7: TreasuryCap<Ty0>)\n\t61: MoveLoc[0](Arg0: &mut CoinRegistry)\n\t62: MutBorrowField[0](CoinRegistry.id: UID)\n\t63: LdFalse\n\t64: PackGeneric[0](CurrencyKey<Ty0>)\n\t65: Call derived_object::claim<CurrencyKey<Ty0>>(&mut UID, CurrencyKey<Ty0>): UID\n\t66: MoveLoc[1](Arg1: u8)\n\t67: MoveLoc[3](Arg3: String)\n\t68: MoveLoc[2](Arg2: String)\n\t69: MoveLoc[4](Arg4: String)\n\t70: MoveLoc[5](Arg5: String)\n\t71: PackVariantGeneric(VariantInstantiationHandleIndex(0))\n\t72: Call option::some<SupplyState<Ty0>>(SupplyState<Ty0>): Option<SupplyState<Ty0>>\n\t73: PackVariant(VariantHandleIndex(0))\n\t74: ImmBorrowLoc[14](loc7: TreasuryCap<Ty0>)\n\t75: Call object::id<TreasuryCap<Ty0>>(&TreasuryCap<Ty0>): ID\n\t76: Call option::some<ID>(ID): Option<ID>\n\t77: PackVariant(VariantHandleIndex(1))\n\t78: Call vec_map::empty<String, ExtraField>(): VecMap<String, ExtraField>\n\t79: PackGeneric[1](Currency<Ty0>)\n\t80: StLoc[9](loc2: Currency<Ty0>)\n\t81: MoveLoc[6](Arg6: &mut TxContext)\n\t82: Call bag::new(&mut TxContext): Bag\n\t83: StLoc[10](loc3: Bag)\n\t84: MoveLoc[9](loc2: Currency<Ty0>)\n\t85: MoveLoc[10](loc3: Bag)\n\t86: LdFalse\n\t87: PackGeneric[2](CurrencyInitializer<Ty0>)\n\t88: MoveLoc[14](loc7: TreasuryCap<Ty0>)\n\t89: Ret\n}\n\npublic new_currency_with_otw<Ty0: drop>(Arg0: Ty0, Arg1: u8, Arg2: String, Arg3: String, Arg4: String, Arg5: String, Arg6: &mut TxContext): CurrencyInitializer<Ty0> * TreasuryCap<Ty0> {\nL7:\tloc0: u64\nL8:\tloc1: bool\nL9:\tloc2: Currency<Ty0>\nL10:\tloc3: Bag\nL11:\tloc4: u64\nL12:\tloc5: u64\nL13:\tloc6: u64\nL14:\tloc7: TreasuryCap<Ty0>\nL15:\tloc8: &vector<u8>\nB0:\n\t0: ImmBorrowLoc[0](Arg0: Ty0)\n\t1: Call types::is_one_time_witness<Ty0>(&Ty0): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(8)\nB2:\n\t4: MoveLoc[6](Arg6: &mut TxContext)\n\t5: Pop\n\t6: LdU64(13906835063401611263)\n\t7: Abort\nB3:\n\t8: ImmBorrowLoc[2](Arg2: String)\n\t9: Call string::as_bytes(&String): &vector<u8>\n\t10: StLoc[15](loc8: &vector<u8>)\n\t11: CopyLoc[15](loc8: &vector<u8>)\n\t12: VecLen(23)\n\t13: StLoc[7](loc0: u64)\n\t14: LdU64(0)\n\t15: StLoc[11](loc4: u64)\n\t16: MoveLoc[7](loc0: u64)\n\t17: StLoc[13](loc6: u64)\nB4:\n\t18: CopyLoc[11](loc4: u64)\n\t19: CopyLoc[13](loc6: u64)\n\t20: Lt\n\t21: BrFalse(41)\nB5:\n\t22: CopyLoc[11](loc4: u64)\n\t23: StLoc[12](loc5: u64)\n\t24: CopyLoc[15](loc8: &vector<u8>)\n\t25: MoveLoc[12](loc5: u64)\n\t26: VecImmBorrow(23)\n\t27: ReadRef\n\t28: Call ascii::is_printable_char(u8): bool\n\t29: Not\n\t30: BrFalse(36)\nB6:\n\t31: MoveLoc[15](loc8: &vector<u8>)\n\t32: Pop\n\t33: LdFalse\n\t34: StLoc[8](loc1: bool)\n\t35: Branch(45)\nB7:\n\t36: MoveLoc[11](loc4: u64)\n\t37: LdU64(1)\n\t38: Add\n\t39: StLoc[11](loc4: u64)\n\t40: Branch(18)\nB8:\n\t41: MoveLoc[15](loc8: &vector<u8>)\n\t42: Pop\n\t43: LdTrue\n\t44: StLoc[8](loc1: bool)\nB9:\n\t45: MoveLoc[8](loc1: bool)\n\t46: BrFalse(48)\nB10:\n\t47: Branch(52)\nB11:\n\t48: MoveLoc[6](Arg6: &mut TxContext)\n\t49: Pop\n\t50: LdU64(13836747794201444365)\n\t51: Abort\nB12:\n\t52: CopyLoc[6](Arg6: &mut TxContext)\n\t53: Call coin::new_treasury_cap<Ty0>(&mut TxContext): TreasuryCap<Ty0>\n\t54: StLoc[14](loc7: TreasuryCap<Ty0>)\n\t55: CopyLoc[6](Arg6: &mut TxContext)\n\t56: Call object::new(&mut TxContext): UID\n\t57: MoveLoc[1](Arg1: u8)\n\t58: MoveLoc[3](Arg3: String)\n\t59: MoveLoc[2](Arg2: String)\n\t60: MoveLoc[4](Arg4: String)\n\t61: MoveLoc[5](Arg5: String)\n\t62: PackVariantGeneric(VariantInstantiationHandleIndex(0))\n\t63: Call option::some<SupplyState<Ty0>>(SupplyState<Ty0>): Option<SupplyState<Ty0>>\n\t64: PackVariant(VariantHandleIndex(0))\n\t65: ImmBorrowLoc[14](loc7: TreasuryCap<Ty0>)\n\t66: Call object::id<TreasuryCap<Ty0>>(&TreasuryCap<Ty0>): ID\n\t67: Call option::some<ID>(ID): Option<ID>\n\t68: PackVariant(VariantHandleIndex(1))\n\t69: Call vec_map::empty<String, ExtraField>(): VecMap<String, ExtraField>\n\t70: PackGeneric[1](Currency<Ty0>)\n\t71: StLoc[9](loc2: Currency<Ty0>)\n\t72: MoveLoc[6](Arg6: &mut TxContext)\n\t73: Call bag::new(&mut TxContext): Bag\n\t74: StLoc[10](loc3: Bag)\n\t75: MoveLoc[9](loc2: Currency<Ty0>)\n\t76: MoveLoc[10](loc3: Bag)\n\t77: LdTrue\n\t78: PackGeneric[2](CurrencyInitializer<Ty0>)\n\t79: MoveLoc[14](loc7: TreasuryCap<Ty0>)\n\t80: Ret\n}\n\npublic claim_metadata_cap<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &TreasuryCap<Ty0>, Arg2: &mut TxContext): MetadataCap<Ty0> {\nL3:\tloc0: UID\nB0:\n\t0: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: FreezeRef\n\t2: Call is_metadata_cap_claimed<Ty0>(&Currency<Ty0>): bool\n\t3: Not\n\t4: BrFalse(6)\nB1:\n\t5: Branch(12)\nB2:\n\t6: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t7: Pop\n\t8: MoveLoc[2](Arg2: &mut TxContext)\n\t9: Pop\n\t10: LdU64(13835059073189412865)\n\t11: Abort\nB3:\n\t12: MoveLoc[2](Arg2: &mut TxContext)\n\t13: Call object::new(&mut TxContext): UID\n\t14: StLoc[3](loc0: UID)\n\t15: ImmBorrowLoc[3](loc0: UID)\n\t16: Call object::uid_to_inner(&UID): ID\n\t17: PackVariant(VariantHandleIndex(2))\n\t18: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t19: MutBorrowFieldGeneric[0](Currency.metadata_cap_id: MetadataCapState)\n\t20: WriteRef\n\t21: MoveLoc[3](loc0: UID)\n\t22: PackGeneric[3](MetadataCap<Ty0>)\n\t23: Ret\n}\n\npublic make_regulated<Ty0>(Arg0: &mut CurrencyInitializer<Ty0>, Arg1: bool, Arg2: &mut TxContext): DenyCapV2<Ty0> {\nL3:\tloc0: DenyCapV2<Ty0>\nB0:\n\t0: CopyLoc[0](Arg0: &mut CurrencyInitializer<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](CurrencyInitializer.currency: Currency<Ty0>)\n\t2: ImmBorrowFieldGeneric[2](Currency.regulated: RegulatedState)\n\t3: ReadRef\n\t4: PackVariant(VariantHandleIndex(0))\n\t5: Eq\n\t6: BrFalse(8)\nB1:\n\t7: Branch(14)\nB2:\n\t8: MoveLoc[0](Arg0: &mut CurrencyInitializer<Ty0>)\n\t9: Pop\n\t10: MoveLoc[2](Arg2: &mut TxContext)\n\t11: Pop\n\t12: LdU64(13837029479631683599)\n\t13: Abort\nB3:\n\t14: CopyLoc[1](Arg1: bool)\n\t15: MoveLoc[2](Arg2: &mut TxContext)\n\t16: Call coin::new_deny_cap_v2<Ty0>(bool, &mut TxContext): DenyCapV2<Ty0>\n\t17: StLoc[3](loc0: DenyCapV2<Ty0>)\n\t18: ImmBorrowLoc[3](loc0: DenyCapV2<Ty0>)\n\t19: Call object::id<DenyCapV2<Ty0>>(&DenyCapV2<Ty0>): ID\n\t20: MoveLoc[1](Arg1: bool)\n\t21: Call option::some<bool>(bool): Option<bool>\n\t22: LdConst[24](u8: 0)\n\t23: PackVariant(VariantHandleIndex(3))\n\t24: MoveLoc[0](Arg0: &mut CurrencyInitializer<Ty0>)\n\t25: MutBorrowFieldGeneric[1](CurrencyInitializer.currency: Currency<Ty0>)\n\t26: MutBorrowFieldGeneric[2](Currency.regulated: RegulatedState)\n\t27: WriteRef\n\t28: MoveLoc[3](loc0: DenyCapV2<Ty0>)\n\t29: Ret\n}\n\npublic make_supply_fixed_init<Ty0>(Arg0: &mut CurrencyInitializer<Ty0>, Arg1: TreasuryCap<Ty0>) {\nB0:\n\t0: ImmBorrowLoc[1](Arg1: TreasuryCap<Ty0>)\n\t1: Call coin::total_supply<Ty0>(&TreasuryCap<Ty0>): u64\n\t2: LdU64(0)\n\t3: Gt\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &mut CurrencyInitializer<Ty0>)\n\t7: Pop\n\t8: LdU64(13837592502599811091)\n\t9: Abort\nB3:\n\t10: MoveLoc[0](Arg0: &mut CurrencyInitializer<Ty0>)\n\t11: MutBorrowFieldGeneric[1](CurrencyInitializer.currency: Currency<Ty0>)\n\t12: MoveLoc[1](Arg1: TreasuryCap<Ty0>)\n\t13: Call make_supply_fixed<Ty0>(&mut Currency<Ty0>, TreasuryCap<Ty0>)\n\t14: Ret\n}\n\npublic make_supply_burn_only_init<Ty0>(Arg0: &mut CurrencyInitializer<Ty0>, Arg1: TreasuryCap<Ty0>) {\nB0:\n\t0: ImmBorrowLoc[1](Arg1: TreasuryCap<Ty0>)\n\t1: Call coin::total_supply<Ty0>(&TreasuryCap<Ty0>): u64\n\t2: LdU64(0)\n\t3: Gt\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &mut CurrencyInitializer<Ty0>)\n\t7: Pop\n\t8: LdU64(13837592541254516755)\n\t9: Abort\nB3:\n\t10: MoveLoc[0](Arg0: &mut CurrencyInitializer<Ty0>)\n\t11: MutBorrowFieldGeneric[1](CurrencyInitializer.currency: Currency<Ty0>)\n\t12: MoveLoc[1](Arg1: TreasuryCap<Ty0>)\n\t13: Call make_supply_burn_only<Ty0>(&mut Currency<Ty0>, TreasuryCap<Ty0>)\n\t14: Ret\n}\n\npublic make_supply_fixed<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: TreasuryCap<Ty0>) {\nL2:\tloc0: Supply<Ty0>\nL3:\tloc1: Supply<Ty0>\nL4:\tloc2: &SupplyState<Ty0>\nL5:\tloc3: SupplyState<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: MutBorrowFieldGeneric[3](Currency.supply: Option<SupplyState<Ty0>>)\n\t2: MoveLoc[1](Arg1: TreasuryCap<Ty0>)\n\t3: Call coin::treasury_into_supply<Ty0>(TreasuryCap<Ty0>): Supply<Ty0>\n\t4: PackVariantGeneric(VariantInstantiationHandleIndex(1))\n\t5: Call option::swap<SupplyState<Ty0>>(&mut Option<SupplyState<Ty0>>, SupplyState<Ty0>): SupplyState<Ty0>\n\t6: StLoc[5](loc3: SupplyState<Ty0>)\n\t7: ImmBorrowLoc[5](loc3: SupplyState<Ty0>)\n\t8: StLoc[4](loc2: &SupplyState<Ty0>)\n\t9: CopyLoc[4](loc2: &SupplyState<Ty0>)\n\t10: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t11: MoveLoc[4](loc2: &SupplyState<Ty0>)\n\t12: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(1))\n\t13: Pop\n\t14: MoveLoc[5](loc3: SupplyState<Ty0>)\n\t15: UnpackVariantGeneric(VariantInstantiationHandleIndex(1))\n\t16: StLoc[2](loc0: Supply<Ty0>)\n\t17: LdU64(13838155525567938583)\n\t18: Abort\nB2:\n\t19: MoveLoc[4](loc2: &SupplyState<Ty0>)\n\t20: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(2))\n\t21: Pop\n\t22: MoveLoc[5](loc3: SupplyState<Ty0>)\n\t23: UnpackVariantGeneric(VariantInstantiationHandleIndex(2))\n\t24: StLoc[3](loc1: Supply<Ty0>)\n\t25: LdU64(13838155525567938583)\n\t26: Abort\nB3:\n\t27: MoveLoc[4](loc2: &SupplyState<Ty0>)\n\t28: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(0))\n\t29: MoveLoc[5](loc3: SupplyState<Ty0>)\n\t30: UnpackVariantGeneric(VariantInstantiationHandleIndex(0))\n\t31: Ret\nJump tables:\n[0]:\tvariant_switch SupplyState {\n\t\tVariant0 => jump 11\n\t\tVariant1 => jump 19\n\t\tVariant2 => jump 27\n\t}\n}\n\npublic make_supply_burn_only<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: TreasuryCap<Ty0>) {\nL2:\tloc0: Supply<Ty0>\nL3:\tloc1: Supply<Ty0>\nL4:\tloc2: &SupplyState<Ty0>\nL5:\tloc3: SupplyState<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: MutBorrowFieldGeneric[3](Currency.supply: Option<SupplyState<Ty0>>)\n\t2: MoveLoc[1](Arg1: TreasuryCap<Ty0>)\n\t3: Call coin::treasury_into_supply<Ty0>(TreasuryCap<Ty0>): Supply<Ty0>\n\t4: PackVariantGeneric(VariantInstantiationHandleIndex(2))\n\t5: Call option::swap<SupplyState<Ty0>>(&mut Option<SupplyState<Ty0>>, SupplyState<Ty0>): SupplyState<Ty0>\n\t6: StLoc[5](loc3: SupplyState<Ty0>)\n\t7: ImmBorrowLoc[5](loc3: SupplyState<Ty0>)\n\t8: StLoc[4](loc2: &SupplyState<Ty0>)\n\t9: CopyLoc[4](loc2: &SupplyState<Ty0>)\n\t10: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t11: MoveLoc[4](loc2: &SupplyState<Ty0>)\n\t12: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(1))\n\t13: Pop\n\t14: MoveLoc[5](loc3: SupplyState<Ty0>)\n\t15: UnpackVariantGeneric(VariantInstantiationHandleIndex(1))\n\t16: StLoc[2](loc0: Supply<Ty0>)\n\t17: LdU64(13838155572812578839)\n\t18: Abort\nB2:\n\t19: MoveLoc[4](loc2: &SupplyState<Ty0>)\n\t20: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(2))\n\t21: Pop\n\t22: MoveLoc[5](loc3: SupplyState<Ty0>)\n\t23: UnpackVariantGeneric(VariantInstantiationHandleIndex(2))\n\t24: StLoc[3](loc1: Supply<Ty0>)\n\t25: LdU64(13838155572812578839)\n\t26: Abort\nB3:\n\t27: MoveLoc[4](loc2: &SupplyState<Ty0>)\n\t28: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(0))\n\t29: MoveLoc[5](loc3: SupplyState<Ty0>)\n\t30: UnpackVariantGeneric(VariantInstantiationHandleIndex(0))\n\t31: Ret\nJump tables:\n[0]:\tvariant_switch SupplyState {\n\t\tVariant0 => jump 11\n\t\tVariant1 => jump 19\n\t\tVariant2 => jump 27\n\t}\n}\n\npublic finalize<Ty0>(Arg0: CurrencyInitializer<Ty0>, Arg1: &mut TxContext): MetadataCap<Ty0> {\nL2:\tloc0: Currency<Ty0>\nL3:\tloc1: Bag\nL4:\tloc2: UID\nL5:\tloc3: bool\nB0:\n\t0: MoveLoc[0](Arg0: CurrencyInitializer<Ty0>)\n\t1: UnpackGeneric[2](CurrencyInitializer<Ty0>)\n\t2: StLoc[5](loc3: bool)\n\t3: StLoc[3](loc1: Bag)\n\t4: StLoc[2](loc0: Currency<Ty0>)\n\t5: MoveLoc[3](loc1: Bag)\n\t6: Call bag::destroy_empty(Bag)\n\t7: MoveLoc[1](Arg1: &mut TxContext)\n\t8: Call object::new(&mut TxContext): UID\n\t9: StLoc[4](loc2: UID)\n\t10: ImmBorrowLoc[4](loc2: UID)\n\t11: Call object::uid_to_inner(&UID): ID\n\t12: PackVariant(VariantHandleIndex(2))\n\t13: MutBorrowLoc[2](loc0: Currency<Ty0>)\n\t14: MutBorrowFieldGeneric[0](Currency.metadata_cap_id: MetadataCapState)\n\t15: WriteRef\n\t16: MoveLoc[5](loc3: bool)\n\t17: BrFalse(22)\nB1:\n\t18: MoveLoc[2](loc0: Currency<Ty0>)\n\t19: Call object::sui_coin_registry_address(): address\n\t20: Call transfer::transfer<Currency<Ty0>>(Currency<Ty0>, address)\n\t21: Branch(24)\nB2:\n\t22: MoveLoc[2](loc0: Currency<Ty0>)\n\t23: Call transfer::share_object<Currency<Ty0>>(Currency<Ty0>)\nB3:\n\t24: MoveLoc[4](loc2: UID)\n\t25: PackGeneric[3](MetadataCap<Ty0>)\n\t26: Ret\n}\n\npublic finalize_registration<Ty0>(Arg0: &mut CoinRegistry, Arg1: Receiving<Currency<Ty0>>, Arg2: &mut TxContext) {\nL3:\tloc0: u8\nL4:\tloc1: String\nL5:\tloc2: VecMap<String, ExtraField>\nL6:\tloc3: String\nL7:\tloc4: MetadataCapState\nL8:\tloc5: String\nL9:\tloc6: RegulatedState\nL10:\tloc7: Option<SupplyState<Ty0>>\nL11:\tloc8: String\nL12:\tloc9: Option<ID>\nB0:\n\t0: CopyLoc[0](Arg0: &mut CoinRegistry)\n\t1: MutBorrowField[0](CoinRegistry.id: UID)\n\t2: MoveLoc[1](Arg1: Receiving<Currency<Ty0>>)\n\t3: Call transfer::receive<Currency<Ty0>>(&mut UID, Receiving<Currency<Ty0>>): Currency<Ty0>\n\t4: UnpackGeneric[1](Currency<Ty0>)\n\t5: StLoc[5](loc2: VecMap<String, ExtraField>)\n\t6: StLoc[7](loc4: MetadataCapState)\n\t7: StLoc[12](loc9: Option<ID>)\n\t8: StLoc[9](loc6: RegulatedState)\n\t9: StLoc[10](loc7: Option<SupplyState<Ty0>>)\n\t10: StLoc[6](loc3: String)\n\t11: StLoc[4](loc1: String)\n\t12: StLoc[11](loc8: String)\n\t13: StLoc[8](loc5: String)\n\t14: StLoc[3](loc0: u8)\n\t15: Call object::delete(UID)\n\t16: MoveLoc[0](Arg0: &mut CoinRegistry)\n\t17: MutBorrowField[0](CoinRegistry.id: UID)\n\t18: LdFalse\n\t19: PackGeneric[0](CurrencyKey<Ty0>)\n\t20: Call derived_object::claim<CurrencyKey<Ty0>>(&mut UID, CurrencyKey<Ty0>): UID\n\t21: MoveLoc[3](loc0: u8)\n\t22: MoveLoc[8](loc5: String)\n\t23: MoveLoc[11](loc8: String)\n\t24: MoveLoc[4](loc1: String)\n\t25: MoveLoc[6](loc3: String)\n\t26: MoveLoc[10](loc7: Option<SupplyState<Ty0>>)\n\t27: MoveLoc[9](loc6: RegulatedState)\n\t28: MoveLoc[12](loc9: Option<ID>)\n\t29: MoveLoc[7](loc4: MetadataCapState)\n\t30: MoveLoc[5](loc2: VecMap<String, ExtraField>)\n\t31: PackGeneric[1](Currency<Ty0>)\n\t32: Call transfer::share_object<Currency<Ty0>>(Currency<Ty0>)\n\t33: Ret\n}\n\npublic delete_metadata_cap<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: MetadataCap<Ty0>) {\nL2:\tloc0: UID\nB0:\n\t0: MoveLoc[1](Arg1: MetadataCap<Ty0>)\n\t1: UnpackGeneric[3](MetadataCap<Ty0>)\n\t2: StLoc[2](loc0: UID)\n\t3: PackVariant(VariantHandleIndex(4))\n\t4: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t5: MutBorrowFieldGeneric[0](Currency.metadata_cap_id: MetadataCapState)\n\t6: WriteRef\n\t7: MoveLoc[2](loc0: UID)\n\t8: Call object::delete(UID)\n\t9: Ret\n}\n\npublic burn<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: Coin<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: MoveLoc[1](Arg1: Coin<Ty0>)\n\t2: Call coin::into_balance<Ty0>(Coin<Ty0>): Balance<Ty0>\n\t3: Call burn_balance<Ty0>(&mut Currency<Ty0>, Balance<Ty0>)\n\t4: Ret\n}\n\npublic burn_balance<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: Balance<Ty0>) {\nL2:\tloc0: &SupplyState<Ty0>\nL3:\tloc1: &mut SupplyState<Ty0>\nB0:\n\t0: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: FreezeRef\n\t2: Call is_supply_burn_only<Ty0>(&Currency<Ty0>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t6: Pop\n\t7: LdU64(13837874428548218901)\n\t8: Abort\nB3:\n\t9: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t10: MutBorrowFieldGeneric[3](Currency.supply: Option<SupplyState<Ty0>>)\n\t11: Call option::borrow_mut<SupplyState<Ty0>>(&mut Option<SupplyState<Ty0>>): &mut SupplyState<Ty0>\n\t12: StLoc[3](loc1: &mut SupplyState<Ty0>)\n\t13: CopyLoc[3](loc1: &mut SupplyState<Ty0>)\n\t14: FreezeRef\n\t15: StLoc[2](loc0: &SupplyState<Ty0>)\n\t16: CopyLoc[2](loc0: &SupplyState<Ty0>)\n\t17: VariantSwitch(VariantJumpTableIndex(0))\nB4:\n\t18: MoveLoc[3](loc1: &mut SupplyState<Ty0>)\n\t19: Pop\n\t20: MoveLoc[2](loc0: &SupplyState<Ty0>)\n\t21: Pop\n\t22: LdU64(13838155916409962519)\n\t23: Abort\nB5:\n\t24: MoveLoc[3](loc1: &mut SupplyState<Ty0>)\n\t25: Pop\n\t26: MoveLoc[2](loc0: &SupplyState<Ty0>)\n\t27: Pop\n\t28: LdU64(13838155916409962519)\n\t29: Abort\nB6:\n\t30: MoveLoc[2](loc0: &SupplyState<Ty0>)\n\t31: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(2))\n\t32: Pop\n\t33: MoveLoc[3](loc1: &mut SupplyState<Ty0>)\n\t34: UnpackVariantGenericMutRef(VariantInstantiationHandleIndex(2))\n\t35: MoveLoc[1](Arg1: Balance<Ty0>)\n\t36: Call balance::decrease_supply<Ty0>(&mut Supply<Ty0>, Balance<Ty0>): u64\n\t37: Pop\n\t38: Ret\nJump tables:\n[0]:\tvariant_switch SupplyState {\n\t\tVariant0 => jump 18\n\t\tVariant1 => jump 30\n\t\tVariant2 => jump 24\n\t}\n}\n\npublic set_name<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &MetadataCap<Ty0>, Arg2: String) {\nB0:\n\t0: MoveLoc[2](Arg2: String)\n\t1: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t2: MutBorrowFieldGeneric[4](Currency.name: String)\n\t3: WriteRef\n\t4: Ret\n}\n\npublic set_description<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &MetadataCap<Ty0>, Arg2: String) {\nB0:\n\t0: MoveLoc[2](Arg2: String)\n\t1: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t2: MutBorrowFieldGeneric[5](Currency.description: String)\n\t3: WriteRef\n\t4: Ret\n}\n\npublic set_icon_url<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &MetadataCap<Ty0>, Arg2: String) {\nB0:\n\t0: MoveLoc[2](Arg2: String)\n\t1: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t2: MutBorrowFieldGeneric[6](Currency.icon_url: String)\n\t3: WriteRef\n\t4: Ret\n}\n\npublic set_treasury_cap_id<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &TreasuryCap<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: MutBorrowFieldGeneric[7](Currency.treasury_cap_id: Option<ID>)\n\t2: MoveLoc[1](Arg1: &TreasuryCap<Ty0>)\n\t3: Call object::id<TreasuryCap<Ty0>>(&TreasuryCap<Ty0>): ID\n\t4: Call option::fill<ID>(&mut Option<ID>, ID)\n\t5: Ret\n}\n\npublic migrate_legacy_metadata<Ty0>(Arg0: &mut CoinRegistry, Arg1: &CoinMetadata<Ty0>, Arg2: &mut TxContext) {\nL3:\tloc0: u64\nL4:\tloc1: String\nL5:\tloc2: String\nL6:\tloc3: String\nL7:\tloc4: String\nL8:\tloc5: u8\nL9:\tloc6: UID\nL10:\tloc7: String\nL11:\tloc8: bool\nL12:\tloc9: Option<String>\nL13:\tloc10: String\nL14:\tloc11: u64\nL15:\tloc12: u64\nL16:\tloc13: Option<Url>\nL17:\tloc14: Option<String>\nL18:\tloc15: u64\nL19:\tloc16: Url\nL20:\tloc17: &vector<u8>\nB0:\n\t0: CopyLoc[0](Arg0: &mut CoinRegistry)\n\t1: FreezeRef\n\t2: Call exists<Ty0>(&CoinRegistry): bool\n\t3: Not\n\t4: BrFalse(6)\nB1:\n\t5: Branch(12)\nB2:\n\t6: MoveLoc[0](Arg0: &mut CoinRegistry)\n\t7: Pop\n\t8: MoveLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t9: Pop\n\t10: LdU64(13837311684752965649)\n\t11: Abort\nB3:\n\t12: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t13: Call coin::get_symbol<Ty0>(&CoinMetadata<Ty0>): String\n\t14: Call string::from_ascii(String): String\n\t15: StLoc[10](loc7: String)\n\t16: ImmBorrowLoc[10](loc7: String)\n\t17: Call string::as_bytes(&String): &vector<u8>\n\t18: StLoc[20](loc17: &vector<u8>)\n\t19: CopyLoc[20](loc17: &vector<u8>)\n\t20: VecLen(23)\n\t21: StLoc[3](loc0: u64)\n\t22: LdU64(0)\n\t23: StLoc[14](loc11: u64)\n\t24: MoveLoc[3](loc0: u64)\n\t25: StLoc[18](loc15: u64)\nB4:\n\t26: CopyLoc[14](loc11: u64)\n\t27: CopyLoc[18](loc15: u64)\n\t28: Lt\n\t29: BrFalse(49)\nB5:\n\t30: CopyLoc[14](loc11: u64)\n\t31: StLoc[15](loc12: u64)\n\t32: CopyLoc[20](loc17: &vector<u8>)\n\t33: MoveLoc[15](loc12: u64)\n\t34: VecImmBorrow(23)\n\t35: ReadRef\n\t36: Call ascii::is_printable_char(u8): bool\n\t37: Not\n\t38: BrFalse(44)\nB6:\n\t39: MoveLoc[20](loc17: &vector<u8>)\n\t40: Pop\n\t41: LdFalse\n\t42: StLoc[11](loc8: bool)\n\t43: Branch(53)\nB7:\n\t44: MoveLoc[14](loc11: u64)\n\t45: LdU64(1)\n\t46: Add\n\t47: StLoc[14](loc11: u64)\n\t48: Branch(26)\nB8:\n\t49: MoveLoc[20](loc17: &vector<u8>)\n\t50: Pop\n\t51: LdTrue\n\t52: StLoc[11](loc8: bool)\nB9:\n\t53: MoveLoc[11](loc8: bool)\n\t54: BrFalse(56)\nB10:\n\t55: Branch(62)\nB11:\n\t56: MoveLoc[0](Arg0: &mut CoinRegistry)\n\t57: Pop\n\t58: MoveLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t59: Pop\n\t60: LdU64(13836748739094249485)\n\t61: Abort\nB12:\n\t62: MoveLoc[0](Arg0: &mut CoinRegistry)\n\t63: MutBorrowField[0](CoinRegistry.id: UID)\n\t64: LdFalse\n\t65: PackGeneric[0](CurrencyKey<Ty0>)\n\t66: Call derived_object::claim<CurrencyKey<Ty0>>(&mut UID, CurrencyKey<Ty0>): UID\n\t67: StLoc[9](loc6: UID)\n\t68: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t69: Call coin::get_decimals<Ty0>(&CoinMetadata<Ty0>): u8\n\t70: StLoc[8](loc5: u8)\n\t71: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t72: Call coin::get_name<Ty0>(&CoinMetadata<Ty0>): String\n\t73: StLoc[7](loc4: String)\n\t74: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t75: Call coin::get_symbol<Ty0>(&CoinMetadata<Ty0>): String\n\t76: Call string::from_ascii(String): String\n\t77: StLoc[6](loc3: String)\n\t78: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t79: Call coin::get_description<Ty0>(&CoinMetadata<Ty0>): String\n\t80: StLoc[5](loc2: String)\n\t81: MoveLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t82: Call coin::get_icon_url<Ty0>(&CoinMetadata<Ty0>): Option<Url>\n\t83: StLoc[16](loc13: Option<Url>)\n\t84: ImmBorrowLoc[16](loc13: Option<Url>)\n\t85: Call option::is_some<Url>(&Option<Url>): bool\n\t86: BrFalse(96)\nB13:\n\t87: MoveLoc[16](loc13: Option<Url>)\n\t88: Call option::destroy_some<Url>(Option<Url>): Url\n\t89: StLoc[19](loc16: Url)\n\t90: ImmBorrowLoc[19](loc16: Url)\n\t91: Call url::inner_url(&Url): String\n\t92: Call string::from_ascii(String): String\n\t93: Call option::some<String>(String): Option<String>\n\t94: StLoc[12](loc9: Option<String>)\n\t95: Branch(100)\nB14:\n\t96: MoveLoc[16](loc13: Option<Url>)\n\t97: Call option::destroy_none<Url>(Option<Url>)\n\t98: Call option::none<String>(): Option<String>\n\t99: StLoc[12](loc9: Option<String>)\nB15:\n\t100: MoveLoc[12](loc9: Option<String>)\n\t101: StLoc[17](loc14: Option<String>)\n\t102: ImmBorrowLoc[17](loc14: Option<String>)\n\t103: Call option::is_some<String>(&Option<String>): bool\n\t104: BrFalse(109)\nB16:\n\t105: MoveLoc[17](loc14: Option<String>)\n\t106: Call option::destroy_some<String>(Option<String>): String\n\t107: StLoc[4](loc1: String)\n\t108: Branch(114)\nB17:\n\t109: MoveLoc[17](loc14: Option<String>)\n\t110: Call option::destroy_none<String>(Option<String>)\n\t111: LdConst[25](vector<u8>: \"\" /..)\n\t112: Call string::utf8(vector<u8>): String\n\t113: StLoc[4](loc1: String)\nB18:\n\t114: MoveLoc[4](loc1: String)\n\t115: StLoc[13](loc10: String)\n\t116: MoveLoc[9](loc6: UID)\n\t117: MoveLoc[8](loc5: u8)\n\t118: MoveLoc[7](loc4: String)\n\t119: MoveLoc[6](loc3: String)\n\t120: MoveLoc[5](loc2: String)\n\t121: MoveLoc[13](loc10: String)\n\t122: PackVariantGeneric(VariantInstantiationHandleIndex(0))\n\t123: Call option::some<SupplyState<Ty0>>(SupplyState<Ty0>): Option<SupplyState<Ty0>>\n\t124: PackVariant(VariantHandleIndex(5))\n\t125: Call option::none<ID>(): Option<ID>\n\t126: PackVariant(VariantHandleIndex(1))\n\t127: Call vec_map::empty<String, ExtraField>(): VecMap<String, ExtraField>\n\t128: PackGeneric[1](Currency<Ty0>)\n\t129: Call transfer::share_object<Currency<Ty0>>(Currency<Ty0>)\n\t130: Ret\n}\n\npublic update_from_legacy_metadata<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &CoinMetadata<Ty0>) {\nL2:\tloc0: Option<String>\nL3:\tloc1: String\nL4:\tloc2: Option<Url>\nL5:\tloc3: Option<String>\nL6:\tloc4: Url\nB0:\n\t0: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: FreezeRef\n\t2: Call is_metadata_cap_claimed<Ty0>(&Currency<Ty0>): bool\n\t3: Not\n\t4: BrFalse(6)\nB1:\n\t5: Branch(12)\nB2:\n\t6: MoveLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t7: Pop\n\t8: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t9: Pop\n\t10: LdU64(13836467362901655563)\n\t11: Abort\nB3:\n\t12: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t13: Call coin::get_name<Ty0>(&CoinMetadata<Ty0>): String\n\t14: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t15: MutBorrowFieldGeneric[4](Currency.name: String)\n\t16: WriteRef\n\t17: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t18: Call coin::get_symbol<Ty0>(&CoinMetadata<Ty0>): String\n\t19: Call string::from_ascii(String): String\n\t20: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t21: MutBorrowFieldGeneric[8](Currency.symbol: String)\n\t22: WriteRef\n\t23: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t24: Call coin::get_description<Ty0>(&CoinMetadata<Ty0>): String\n\t25: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t26: MutBorrowFieldGeneric[5](Currency.description: String)\n\t27: WriteRef\n\t28: CopyLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t29: Call coin::get_decimals<Ty0>(&CoinMetadata<Ty0>): u8\n\t30: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t31: MutBorrowFieldGeneric[9](Currency.decimals: u8)\n\t32: WriteRef\n\t33: MoveLoc[1](Arg1: &CoinMetadata<Ty0>)\n\t34: Call coin::get_icon_url<Ty0>(&CoinMetadata<Ty0>): Option<Url>\n\t35: StLoc[4](loc2: Option<Url>)\n\t36: ImmBorrowLoc[4](loc2: Option<Url>)\n\t37: Call option::is_some<Url>(&Option<Url>): bool\n\t38: BrFalse(48)\nB4:\n\t39: MoveLoc[4](loc2: Option<Url>)\n\t40: Call option::destroy_some<Url>(Option<Url>): Url\n\t41: StLoc[6](loc4: Url)\n\t42: ImmBorrowLoc[6](loc4: Url)\n\t43: Call url::inner_url(&Url): String\n\t44: Call string::from_ascii(String): String\n\t45: Call option::some<String>(String): Option<String>\n\t46: StLoc[2](loc0: Option<String>)\n\t47: Branch(52)\nB5:\n\t48: MoveLoc[4](loc2: Option<Url>)\n\t49: Call option::destroy_none<Url>(Option<Url>)\n\t50: Call option::none<String>(): Option<String>\n\t51: StLoc[2](loc0: Option<String>)\nB6:\n\t52: MoveLoc[2](loc0: Option<String>)\n\t53: StLoc[5](loc3: Option<String>)\n\t54: ImmBorrowLoc[5](loc3: Option<String>)\n\t55: Call option::is_some<String>(&Option<String>): bool\n\t56: BrFalse(61)\nB7:\n\t57: MoveLoc[5](loc3: Option<String>)\n\t58: Call option::destroy_some<String>(Option<String>): String\n\t59: StLoc[3](loc1: String)\n\t60: Branch(66)\nB8:\n\t61: MoveLoc[5](loc3: Option<String>)\n\t62: Call option::destroy_none<String>(Option<String>)\n\t63: LdConst[25](vector<u8>: \"\" /..)\n\t64: Call string::utf8(vector<u8>): String\n\t65: StLoc[3](loc1: String)\nB9:\n\t66: MoveLoc[3](loc1: String)\n\t67: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t68: MutBorrowFieldGeneric[6](Currency.icon_url: String)\n\t69: WriteRef\n\t70: Ret\n}\n\npublic delete_migrated_legacy_metadata<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: CoinMetadata<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: FreezeRef\n\t2: Call is_metadata_cap_claimed<Ty0>(&Currency<Ty0>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdU64(13836185956644290569)\n\t6: Abort\nB3:\n\t7: MoveLoc[1](Arg1: CoinMetadata<Ty0>)\n\t8: Call coin::destroy_metadata<Ty0>(CoinMetadata<Ty0>)\n\t9: Ret\n}\n\npublic migrate_regulated_state_by_metadata<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &RegulatedCoinMetadata<Ty0>) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](Currency.regulated: RegulatedState)\n\t2: ReadRef\n\t3: PackVariant(VariantHandleIndex(5))\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(13)\nB2:\n\t7: MoveLoc[1](Arg1: &RegulatedCoinMetadata<Ty0>)\n\t8: Pop\n\t9: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t10: Pop\n\t11: LdU64(13835904528912089095)\n\t12: Abort\nB3:\n\t13: MoveLoc[1](Arg1: &RegulatedCoinMetadata<Ty0>)\n\t14: Call coin::deny_cap_id<Ty0>(&RegulatedCoinMetadata<Ty0>): ID\n\t15: Call option::none<bool>(): Option<bool>\n\t16: LdConst[24](u8: 0)\n\t17: PackVariant(VariantHandleIndex(3))\n\t18: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t19: MutBorrowFieldGeneric[2](Currency.regulated: RegulatedState)\n\t20: WriteRef\n\t21: Ret\n}\n\npublic migrate_regulated_state_by_cap<Ty0>(Arg0: &mut Currency<Ty0>, Arg1: &DenyCapV2<Ty0>) {\nB0:\n\t0: CopyLoc[1](Arg1: &DenyCapV2<Ty0>)\n\t1: Call object::id<DenyCapV2<Ty0>>(&DenyCapV2<Ty0>): ID\n\t2: MoveLoc[1](Arg1: &DenyCapV2<Ty0>)\n\t3: Call coin::allow_global_pause<Ty0>(&DenyCapV2<Ty0>): bool\n\t4: Call option::some<bool>(bool): Option<bool>\n\t5: LdConst[24](u8: 0)\n\t6: PackVariant(VariantHandleIndex(3))\n\t7: MoveLoc[0](Arg0: &mut Currency<Ty0>)\n\t8: MutBorrowFieldGeneric[2](Currency.regulated: RegulatedState)\n\t9: WriteRef\n\t10: Ret\n}\n\npublic decimals<Ty0>(Arg0: &Currency<Ty0>): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[9](Currency.decimals: u8)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic name<Ty0>(Arg0: &Currency<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[4](Currency.name: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic symbol<Ty0>(Arg0: &Currency<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[8](Currency.symbol: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic description<Ty0>(Arg0: &Currency<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[5](Currency.description: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic icon_url<Ty0>(Arg0: &Currency<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[6](Currency.icon_url: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic is_metadata_cap_claimed<Ty0>(Arg0: &Currency<Ty0>): bool {\nL1:\tloc0: bool\nL2:\tloc1: &MetadataCapState\nL3:\tloc2: MetadataCapState\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Currency.metadata_cap_id: MetadataCapState)\n\t2: ReadRef\n\t3: StLoc[3](loc2: MetadataCapState)\n\t4: ImmBorrowLoc[3](loc2: MetadataCapState)\n\t5: StLoc[2](loc1: &MetadataCapState)\n\t6: CopyLoc[2](loc1: &MetadataCapState)\n\t7: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t8: MoveLoc[2](loc1: &MetadataCapState)\n\t9: UnpackVariantImmRef(VariantHandleIndex(2))\n\t10: Pop\n\t11: MoveLoc[3](loc2: MetadataCapState)\n\t12: UnpackVariant(VariantHandleIndex(2))\n\t13: Pop\n\t14: LdTrue\n\t15: StLoc[1](loc0: bool)\n\t16: Branch(28)\nB2:\n\t17: MoveLoc[2](loc1: &MetadataCapState)\n\t18: Pop\n\t19: LdFalse\n\t20: StLoc[1](loc0: bool)\n\t21: Branch(28)\nB3:\n\t22: MoveLoc[2](loc1: &MetadataCapState)\n\t23: UnpackVariantImmRef(VariantHandleIndex(4))\n\t24: MoveLoc[3](loc2: MetadataCapState)\n\t25: UnpackVariant(VariantHandleIndex(4))\n\t26: LdTrue\n\t27: StLoc[1](loc0: bool)\nB4:\n\t28: MoveLoc[1](loc0: bool)\n\t29: Ret\nJump tables:\n[0]:\tvariant_switch MetadataCapState {\n\t\tVariant0 => jump 8\n\t\tVariant1 => jump 17\n\t\tVariant2 => jump 22\n\t}\n}\n\npublic is_metadata_cap_deleted<Ty0>(Arg0: &Currency<Ty0>): bool {\nL1:\tloc0: bool\nL2:\tloc1: &MetadataCapState\nL3:\tloc2: MetadataCapState\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Currency.metadata_cap_id: MetadataCapState)\n\t2: ReadRef\n\t3: StLoc[3](loc2: MetadataCapState)\n\t4: ImmBorrowLoc[3](loc2: MetadataCapState)\n\t5: StLoc[2](loc1: &MetadataCapState)\n\t6: CopyLoc[2](loc1: &MetadataCapState)\n\t7: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t8: MoveLoc[2](loc1: &MetadataCapState)\n\t9: Pop\n\t10: LdFalse\n\t11: StLoc[1](loc0: bool)\n\t12: Branch(24)\nB2:\n\t13: MoveLoc[2](loc1: &MetadataCapState)\n\t14: Pop\n\t15: LdFalse\n\t16: StLoc[1](loc0: bool)\n\t17: Branch(24)\nB3:\n\t18: MoveLoc[2](loc1: &MetadataCapState)\n\t19: UnpackVariantImmRef(VariantHandleIndex(4))\n\t20: MoveLoc[3](loc2: MetadataCapState)\n\t21: UnpackVariant(VariantHandleIndex(4))\n\t22: LdTrue\n\t23: StLoc[1](loc0: bool)\nB4:\n\t24: MoveLoc[1](loc0: bool)\n\t25: Ret\nJump tables:\n[0]:\tvariant_switch MetadataCapState {\n\t\tVariant0 => jump 8\n\t\tVariant1 => jump 13\n\t\tVariant2 => jump 18\n\t}\n}\n\npublic metadata_cap_id<Ty0>(Arg0: &Currency<Ty0>): Option<ID> {\nL1:\tloc0: Option<ID>\nL2:\tloc1: &MetadataCapState\nL3:\tloc2: MetadataCapState\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Currency.metadata_cap_id: MetadataCapState)\n\t2: ReadRef\n\t3: StLoc[3](loc2: MetadataCapState)\n\t4: ImmBorrowLoc[3](loc2: MetadataCapState)\n\t5: StLoc[2](loc1: &MetadataCapState)\n\t6: CopyLoc[2](loc1: &MetadataCapState)\n\t7: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t8: MoveLoc[2](loc1: &MetadataCapState)\n\t9: UnpackVariantImmRef(VariantHandleIndex(2))\n\t10: Pop\n\t11: MoveLoc[3](loc2: MetadataCapState)\n\t12: UnpackVariant(VariantHandleIndex(2))\n\t13: Call option::some<ID>(ID): Option<ID>\n\t14: StLoc[1](loc0: Option<ID>)\n\t15: Branch(25)\nB2:\n\t16: MoveLoc[2](loc1: &MetadataCapState)\n\t17: Pop\n\t18: Call option::none<ID>(): Option<ID>\n\t19: StLoc[1](loc0: Option<ID>)\n\t20: Branch(25)\nB3:\n\t21: MoveLoc[2](loc1: &MetadataCapState)\n\t22: Pop\n\t23: Call option::none<ID>(): Option<ID>\n\t24: StLoc[1](loc0: Option<ID>)\nB4:\n\t25: MoveLoc[1](loc0: Option<ID>)\n\t26: Ret\nJump tables:\n[0]:\tvariant_switch MetadataCapState {\n\t\tVariant0 => jump 8\n\t\tVariant1 => jump 16\n\t\tVariant2 => jump 21\n\t}\n}\n\npublic treasury_cap_id<Ty0>(Arg0: &Currency<Ty0>): Option<ID> {\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[7](Currency.treasury_cap_id: Option<ID>)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic deny_cap_id<Ty0>(Arg0: &Currency<Ty0>): Option<ID> {\nL1:\tloc0: Option<ID>\nL2:\tloc1: &RegulatedState\nL3:\tloc2: RegulatedState\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](Currency.regulated: RegulatedState)\n\t2: ReadRef\n\t3: StLoc[3](loc2: RegulatedState)\n\t4: ImmBorrowLoc[3](loc2: RegulatedState)\n\t5: StLoc[2](loc1: &RegulatedState)\n\t6: CopyLoc[2](loc1: &RegulatedState)\n\t7: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t8: MoveLoc[2](loc1: &RegulatedState)\n\t9: UnpackVariantImmRef(VariantHandleIndex(3))\n\t10: Pop\n\t11: Pop\n\t12: Pop\n\t13: MoveLoc[3](loc2: RegulatedState)\n\t14: UnpackVariant(VariantHandleIndex(3))\n\t15: Pop\n\t16: Pop\n\t17: Call option::some<ID>(ID): Option<ID>\n\t18: StLoc[1](loc0: Option<ID>)\n\t19: Branch(33)\nB2:\n\t20: MoveLoc[2](loc1: &RegulatedState)\n\t21: UnpackVariantImmRef(VariantHandleIndex(0))\n\t22: MoveLoc[3](loc2: RegulatedState)\n\t23: UnpackVariant(VariantHandleIndex(0))\n\t24: Call option::none<ID>(): Option<ID>\n\t25: StLoc[1](loc0: Option<ID>)\n\t26: Branch(33)\nB3:\n\t27: MoveLoc[2](loc1: &RegulatedState)\n\t28: UnpackVariantImmRef(VariantHandleIndex(5))\n\t29: MoveLoc[3](loc2: RegulatedState)\n\t30: UnpackVariant(VariantHandleIndex(5))\n\t31: Call option::none<ID>(): Option<ID>\n\t32: StLoc[1](loc0: Option<ID>)\nB4:\n\t33: MoveLoc[1](loc0: Option<ID>)\n\t34: Ret\nJump tables:\n[0]:\tvariant_switch RegulatedState {\n\t\tVariant0 => jump 8\n\t\tVariant1 => jump 20\n\t\tVariant2 => jump 27\n\t}\n}\n\npublic is_supply_fixed<Ty0>(Arg0: &Currency<Ty0>): bool {\nL1:\tloc0: bool\nL2:\tloc1: &SupplyState<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](Currency.supply: Option<SupplyState<Ty0>>)\n\t2: Call option::borrow<SupplyState<Ty0>>(&Option<SupplyState<Ty0>>): &SupplyState<Ty0>\n\t3: StLoc[2](loc1: &SupplyState<Ty0>)\n\t4: CopyLoc[2](loc1: &SupplyState<Ty0>)\n\t5: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t6: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t7: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(1))\n\t8: Pop\n\t9: LdTrue\n\t10: StLoc[1](loc0: bool)\n\t11: Branch(21)\nB2:\n\t12: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t13: Pop\n\t14: LdFalse\n\t15: StLoc[1](loc0: bool)\n\t16: Branch(21)\nB3:\n\t17: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t18: Pop\n\t19: LdFalse\n\t20: StLoc[1](loc0: bool)\nB4:\n\t21: MoveLoc[1](loc0: bool)\n\t22: Ret\nJump tables:\n[0]:\tvariant_switch SupplyState {\n\t\tVariant0 => jump 6\n\t\tVariant1 => jump 12\n\t\tVariant2 => jump 17\n\t}\n}\n\npublic is_supply_burn_only<Ty0>(Arg0: &Currency<Ty0>): bool {\nL1:\tloc0: bool\nL2:\tloc1: &SupplyState<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](Currency.supply: Option<SupplyState<Ty0>>)\n\t2: Call option::borrow<SupplyState<Ty0>>(&Option<SupplyState<Ty0>>): &SupplyState<Ty0>\n\t3: StLoc[2](loc1: &SupplyState<Ty0>)\n\t4: CopyLoc[2](loc1: &SupplyState<Ty0>)\n\t5: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t6: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t7: Pop\n\t8: LdFalse\n\t9: StLoc[1](loc0: bool)\n\t10: Branch(21)\nB2:\n\t11: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t12: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(2))\n\t13: Pop\n\t14: LdTrue\n\t15: StLoc[1](loc0: bool)\n\t16: Branch(21)\nB3:\n\t17: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t18: Pop\n\t19: LdFalse\n\t20: StLoc[1](loc0: bool)\nB4:\n\t21: MoveLoc[1](loc0: bool)\n\t22: Ret\nJump tables:\n[0]:\tvariant_switch SupplyState {\n\t\tVariant0 => jump 6\n\t\tVariant1 => jump 11\n\t\tVariant2 => jump 17\n\t}\n}\n\npublic is_regulated<Ty0>(Arg0: &Currency<Ty0>): bool {\nL1:\tloc0: bool\nL2:\tloc1: &RegulatedState\nL3:\tloc2: RegulatedState\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](Currency.regulated: RegulatedState)\n\t2: ReadRef\n\t3: StLoc[3](loc2: RegulatedState)\n\t4: ImmBorrowLoc[3](loc2: RegulatedState)\n\t5: StLoc[2](loc1: &RegulatedState)\n\t6: CopyLoc[2](loc1: &RegulatedState)\n\t7: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t8: MoveLoc[2](loc1: &RegulatedState)\n\t9: UnpackVariantImmRef(VariantHandleIndex(3))\n\t10: Pop\n\t11: Pop\n\t12: Pop\n\t13: MoveLoc[3](loc2: RegulatedState)\n\t14: UnpackVariant(VariantHandleIndex(3))\n\t15: Pop\n\t16: Pop\n\t17: Pop\n\t18: LdTrue\n\t19: StLoc[1](loc0: bool)\n\t20: Branch(30)\nB2:\n\t21: MoveLoc[2](loc1: &RegulatedState)\n\t22: Pop\n\t23: LdFalse\n\t24: StLoc[1](loc0: bool)\n\t25: Branch(30)\nB3:\n\t26: MoveLoc[2](loc1: &RegulatedState)\n\t27: Pop\n\t28: LdFalse\n\t29: StLoc[1](loc0: bool)\nB4:\n\t30: MoveLoc[1](loc0: bool)\n\t31: Ret\nJump tables:\n[0]:\tvariant_switch RegulatedState {\n\t\tVariant0 => jump 8\n\t\tVariant1 => jump 21\n\t\tVariant2 => jump 26\n\t}\n}\n\npublic total_supply<Ty0>(Arg0: &Currency<Ty0>): Option<u64> {\nL1:\tloc0: Option<u64>\nL2:\tloc1: &SupplyState<Ty0>\nL3:\tloc2: &SupplyState<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &Currency<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](Currency.supply: Option<SupplyState<Ty0>>)\n\t2: Call option::borrow<SupplyState<Ty0>>(&Option<SupplyState<Ty0>>): &SupplyState<Ty0>\n\t3: StLoc[3](loc2: &SupplyState<Ty0>)\n\t4: CopyLoc[3](loc2: &SupplyState<Ty0>)\n\t5: StLoc[2](loc1: &SupplyState<Ty0>)\n\t6: CopyLoc[2](loc1: &SupplyState<Ty0>)\n\t7: VariantSwitch(VariantJumpTableIndex(0))\nB1:\n\t8: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t9: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(1))\n\t10: Pop\n\t11: MoveLoc[3](loc2: &SupplyState<Ty0>)\n\t12: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(1))\n\t13: Call balance::supply_value<Ty0>(&Supply<Ty0>): u64\n\t14: Call option::some<u64>(u64): Option<u64>\n\t15: StLoc[1](loc0: Option<u64>)\n\t16: Branch(32)\nB2:\n\t17: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t18: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(2))\n\t19: Pop\n\t20: MoveLoc[3](loc2: &SupplyState<Ty0>)\n\t21: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(2))\n\t22: Call balance::supply_value<Ty0>(&Supply<Ty0>): u64\n\t23: Call option::some<u64>(u64): Option<u64>\n\t24: StLoc[1](loc0: Option<u64>)\n\t25: Branch(32)\nB3:\n\t26: MoveLoc[3](loc2: &SupplyState<Ty0>)\n\t27: Pop\n\t28: MoveLoc[2](loc1: &SupplyState<Ty0>)\n\t29: UnpackVariantGenericImmRef(VariantInstantiationHandleIndex(0))\n\t30: Call option::none<u64>(): Option<u64>\n\t31: StLoc[1](loc0: Option<u64>)\nB4:\n\t32: MoveLoc[1](loc0: Option<u64>)\n\t33: Ret\nJump tables:\n[0]:\tvariant_switch SupplyState {\n\t\tVariant0 => jump 8\n\t\tVariant1 => jump 17\n\t\tVariant2 => jump 26\n\t}\n}\n\npublic exists<Ty0>(Arg0: &CoinRegistry): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &CoinRegistry)\n\t1: ImmBorrowField[0](CoinRegistry.id: UID)\n\t2: LdFalse\n\t3: PackGeneric[0](CurrencyKey<Ty0>)\n\t4: Call derived_object::exists<CurrencyKey<Ty0>>(&UID, CurrencyKey<Ty0>): bool\n\t5: Ret\n}\n\ncreate(Arg0: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[26](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdU64(13835342094354481155)\n\t7: Abort\nB3:\n\t8: Call object::sui_coin_registry_object_id(): UID\n\t9: Pack[0](CoinRegistry)\n\t10: Call transfer::share_object<CoinRegistry>(CoinRegistry)\n\t11: Ret\n}\n\nConstants [\n\t0 => vector<u8>: \"EMetadataCapAlreadyClaimed\" // interpreted as UTF8 string\n\t1 => vector<u8>: \"Metadata cap already claimed.\" // interpreted as UTF8 string\n\t2 => vector<u8>: \"ENotSystemAddress\" // interpreted as UTF8 string\n\t3 => vector<u8>: \"Only the system can create the registry.\" // interpreted as UTF8 string\n\t4 => vector<u8>: \"ECurrencyAlreadyExists\" // interpreted as UTF8 string\n\t5 => vector<u8>: \"Currency for this coin type already exists.\" // interpreted as UTF8 string\n\t6 => vector<u8>: \"EDenyListStateAlreadySet\" // interpreted as UTF8 string\n\t7 => vector<u8>: \"Cannot set the deny list state as it has already been set.\" // interpreted as UTF8 string\n\t8 => vector<u8>: \"EMetadataCapNotClaimed\" // interpreted as UTF8 string\n\t9 => vector<u8>: \"Cannot delete legacy metadata before claiming the `MetadataCap`.\" // interpreted as UTF8 string\n\t10 => vector<u8>: \"ECannotUpdateManagedMetadata\" // interpreted as UTF8 string\n\t11 => vector<u8>: \"Cannot update metadata whose `MetadataCap` has already been claimed.\" // interpreted as UTF8 string\n\t12 => vector<u8>: \"EInvalidSymbol\" // interpreted as UTF8 string\n\t13 => vector<u8>: \"Symbol has to be ASCII printable.\" // interpreted as UTF8 string\n\t14 => vector<u8>: \"EDenyCapAlreadyCreated\" // interpreted as UTF8 string\n\t15 => vector<u8>: \"Cannot claim the deny cap twice.\" // interpreted as UTF8 string\n\t16 => vector<u8>: \"ECurrencyAlreadyRegistered\" // interpreted as UTF8 string\n\t17 => vector<u8>: \"Currency already registered.\" // interpreted as UTF8 string\n\t18 => vector<u8>: \"EEmptySupply\" // interpreted as UTF8 string\n\t19 => vector<u8>: \"Supply cannot be empty.\" // interpreted as UTF8 string\n\t20 => vector<u8>: \"ESupplyNotBurnOnly\" // interpreted as UTF8 string\n\t21 => vector<u8>: \"Cannot burn on a non burn-only supply.\" // interpreted as UTF8 string\n\t22 => vector<u8>: \"EInvariantViolation\" // interpreted as UTF8 string\n\t23 => vector<u8>: \"Code invariant violation.\" // interpreted as UTF8 string\n\t24 => u8: 0\n\t25 => vector<u8>: \"\" // interpreted as UTF8 string\n\t26 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","config":"// Move bytecode v6\nmodule 2.config {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Config<phantom Ty0> has key {\n\tid: UID\n}\n\nstruct Setting<Ty0: copy + drop + store> has drop, store {\n\tdata: Option<SettingData<Ty0>>\n}\n\nstruct SettingData<Ty0: copy + drop + store> has drop, store {\n\tnewer_value_epoch: u64,\n\tnewer_value: Option<Ty0>,\n\tolder_value_opt: Option<Ty0>\n}\n\npublic(friend) new<Ty0>(Arg0: &mut Ty0, Arg1: &mut TxContext): Config<Ty0> {\nB0:\n\t0: MoveLoc[1](Arg1: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: PackGeneric[0](Config<Ty0>)\n\t3: Ret\n}\n\npublic(friend) share<Ty0>(Arg0: Config<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: Config<Ty0>)\n\t1: Call transfer::share_object<Config<Ty0>>(Config<Ty0>)\n\t2: Ret\n}\n\npublic(friend) transfer<Ty0>(Arg0: Config<Ty0>, Arg1: address) {\nB0:\n\t0: MoveLoc[0](Arg0: Config<Ty0>)\n\t1: MoveLoc[1](Arg1: address)\n\t2: Call transfer::transfer<Config<Ty0>>(Config<Ty0>, address)\n\t3: Ret\n}\n\npublic(friend) add_for_next_epoch<Ty0, Ty1: copy + drop + store, Ty2: copy + drop + store>(Arg0: &mut Config<Ty0>, Arg1: &mut Ty0, Arg2: Ty1, Arg3: Ty2, Arg4: &mut TxContext): Option<Ty2> {\nL5:\tloc0: Option<Ty2>\nL6:\tloc1: Option<Ty2>\nL7:\tloc2: Option<Ty2>\nL8:\tloc3: u64\nL9:\tloc4: Option<Ty2>\nL10:\tloc5: u64\nL11:\tloc6: Option<Ty2>\nL12:\tloc7: Option<Ty2>\nL13:\tloc8: Option<Ty2>\nL14:\tloc9: Setting<Ty2>\nL15:\tloc10: &mut Setting<Ty2>\nB0:\n\t0: MoveLoc[4](Arg4: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::epoch(&TxContext): u64\n\t3: StLoc[8](loc3: u64)\n\t4: CopyLoc[0](Arg0: &mut Config<Ty0>)\n\t5: ImmBorrowFieldGeneric[0](Config.id: UID)\n\t6: CopyLoc[2](Arg2: Ty1)\n\t7: Call dynamic_field::exists_<Ty1>(&UID, Ty1): bool\n\t8: Not\n\t9: BrFalse(26)\nB1:\n\t10: MoveLoc[8](loc3: u64)\n\t11: MoveLoc[3](Arg3: Ty2)\n\t12: Call option::some<Ty2>(Ty2): Option<Ty2>\n\t13: Call option::none<Ty2>(): Option<Ty2>\n\t14: PackGeneric[1](SettingData<Ty2>)\n\t15: Call option::some<SettingData<Ty2>>(SettingData<Ty2>): Option<SettingData<Ty2>>\n\t16: PackGeneric[2](Setting<Ty2>)\n\t17: StLoc[14](loc9: Setting<Ty2>)\n\t18: MoveLoc[0](Arg0: &mut Config<Ty0>)\n\t19: MutBorrowFieldGeneric[0](Config.id: UID)\n\t20: MoveLoc[2](Arg2: Ty1)\n\t21: MoveLoc[14](loc9: Setting<Ty2>)\n\t22: Call dynamic_field::add<Ty1, Setting<Ty2>>(&mut UID, Ty1, Setting<Ty2>)\n\t23: Call option::none<Ty2>(): Option<Ty2>\n\t24: StLoc[7](loc2: Option<Ty2>)\n\t25: Branch(82)\nB2:\n\t26: MoveLoc[0](Arg0: &mut Config<Ty0>)\n\t27: MutBorrowFieldGeneric[0](Config.id: UID)\n\t28: MoveLoc[2](Arg2: Ty1)\n\t29: Call dynamic_field::borrow_mut<Ty1, Setting<Ty2>>(&mut UID, Ty1): &mut Setting<Ty2>\n\t30: StLoc[15](loc10: &mut Setting<Ty2>)\n\t31: CopyLoc[15](loc10: &mut Setting<Ty2>)\n\t32: MutBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t33: Call option::extract<SettingData<Ty2>>(&mut Option<SettingData<Ty2>>): SettingData<Ty2>\n\t34: UnpackGeneric[1](SettingData<Ty2>)\n\t35: StLoc[11](loc6: Option<Ty2>)\n\t36: StLoc[9](loc4: Option<Ty2>)\n\t37: StLoc[10](loc5: u64)\n\t38: CopyLoc[8](loc3: u64)\n\t39: CopyLoc[10](loc5: u64)\n\t40: Gt\n\t41: BrFalse(47)\nB3:\n\t42: MoveLoc[9](loc4: Option<Ty2>)\n\t43: MoveLoc[11](loc6: Option<Ty2>)\n\t44: StLoc[6](loc1: Option<Ty2>)\n\t45: StLoc[5](loc0: Option<Ty2>)\n\t46: Branch(68)\nB4:\n\t47: CopyLoc[8](loc3: u64)\n\t48: MoveLoc[10](loc5: u64)\n\t49: Eq\n\t50: BrFalse(52)\nB5:\n\t51: Branch(56)\nB6:\n\t52: MoveLoc[15](loc10: &mut Setting<Ty2>)\n\t53: Pop\n\t54: LdU64(13906834543710568447)\n\t55: Abort\nB7:\n\t56: ImmBorrowLoc[9](loc4: Option<Ty2>)\n\t57: Call option::is_none<Ty2>(&Option<Ty2>): bool\n\t58: BrFalse(60)\nB8:\n\t59: Branch(64)\nB9:\n\t60: MoveLoc[15](loc10: &mut Setting<Ty2>)\n\t61: Pop\n\t62: LdConst[0](u64: 0)\n\t63: Abort\nB10:\n\t64: MoveLoc[11](loc6: Option<Ty2>)\n\t65: Call option::none<Ty2>(): Option<Ty2>\n\t66: StLoc[6](loc1: Option<Ty2>)\n\t67: StLoc[5](loc0: Option<Ty2>)\nB11:\n\t68: MoveLoc[5](loc0: Option<Ty2>)\n\t69: MoveLoc[6](loc1: Option<Ty2>)\n\t70: StLoc[13](loc8: Option<Ty2>)\n\t71: StLoc[12](loc7: Option<Ty2>)\n\t72: MoveLoc[15](loc10: &mut Setting<Ty2>)\n\t73: MutBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t74: MoveLoc[8](loc3: u64)\n\t75: MoveLoc[3](Arg3: Ty2)\n\t76: Call option::some<Ty2>(Ty2): Option<Ty2>\n\t77: MoveLoc[12](loc7: Option<Ty2>)\n\t78: PackGeneric[1](SettingData<Ty2>)\n\t79: Call option::fill<SettingData<Ty2>>(&mut Option<SettingData<Ty2>>, SettingData<Ty2>)\n\t80: MoveLoc[13](loc8: Option<Ty2>)\n\t81: StLoc[7](loc2: Option<Ty2>)\nB12:\n\t82: MoveLoc[7](loc2: Option<Ty2>)\n\t83: Ret\n}\n\npublic(friend) remove_for_next_epoch<Ty0, Ty1: copy + drop + store, Ty2: copy + drop + store>(Arg0: &mut Config<Ty0>, Arg1: &mut Ty0, Arg2: Ty1, Arg3: &mut TxContext): Option<Ty2> {\nL4:\tloc0: Option<Ty2>\nL5:\tloc1: Option<Ty2>\nL6:\tloc2: u64\nL7:\tloc3: Option<Ty2>\nL8:\tloc4: u64\nL9:\tloc5: Option<Ty2>\nL10:\tloc6: Option<Ty2>\nL11:\tloc7: bool\nL12:\tloc8: Option<Ty2>\nL13:\tloc9: &mut Setting<Ty2>\nB0:\n\t0: MoveLoc[3](Arg3: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::epoch(&TxContext): u64\n\t3: StLoc[6](loc2: u64)\n\t4: CopyLoc[0](Arg0: &mut Config<Ty0>)\n\t5: ImmBorrowFieldGeneric[0](Config.id: UID)\n\t6: CopyLoc[2](Arg2: Ty1)\n\t7: Call dynamic_field::exists_<Ty1>(&UID, Ty1): bool\n\t8: Not\n\t9: BrFalse(14)\nB1:\n\t10: MoveLoc[0](Arg0: &mut Config<Ty0>)\n\t11: Pop\n\t12: Call option::none<Ty2>(): Option<Ty2>\n\t13: Ret\nB2:\n\t14: CopyLoc[0](Arg0: &mut Config<Ty0>)\n\t15: MutBorrowFieldGeneric[0](Config.id: UID)\n\t16: CopyLoc[2](Arg2: Ty1)\n\t17: Call dynamic_field::borrow_mut<Ty1, Setting<Ty2>>(&mut UID, Ty1): &mut Setting<Ty2>\n\t18: StLoc[13](loc9: &mut Setting<Ty2>)\n\t19: CopyLoc[13](loc9: &mut Setting<Ty2>)\n\t20: MutBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t21: Call option::extract<SettingData<Ty2>>(&mut Option<SettingData<Ty2>>): SettingData<Ty2>\n\t22: UnpackGeneric[1](SettingData<Ty2>)\n\t23: StLoc[9](loc5: Option<Ty2>)\n\t24: StLoc[7](loc3: Option<Ty2>)\n\t25: StLoc[8](loc4: u64)\n\t26: CopyLoc[6](loc2: u64)\n\t27: CopyLoc[8](loc4: u64)\n\t28: Gt\n\t29: BrFalse(35)\nB3:\n\t30: MoveLoc[7](loc3: Option<Ty2>)\n\t31: Call option::none<Ty2>(): Option<Ty2>\n\t32: StLoc[5](loc1: Option<Ty2>)\n\t33: StLoc[4](loc0: Option<Ty2>)\n\t34: Branch(50)\nB4:\n\t35: CopyLoc[6](loc2: u64)\n\t36: MoveLoc[8](loc4: u64)\n\t37: Eq\n\t38: BrFalse(40)\nB5:\n\t39: Branch(46)\nB6:\n\t40: MoveLoc[13](loc9: &mut Setting<Ty2>)\n\t41: Pop\n\t42: MoveLoc[0](Arg0: &mut Config<Ty0>)\n\t43: Pop\n\t44: LdU64(13906834715509260287)\n\t45: Abort\nB7:\n\t46: MoveLoc[9](loc5: Option<Ty2>)\n\t47: MoveLoc[7](loc3: Option<Ty2>)\n\t48: StLoc[5](loc1: Option<Ty2>)\n\t49: StLoc[4](loc0: Option<Ty2>)\nB8:\n\t50: MoveLoc[4](loc0: Option<Ty2>)\n\t51: MoveLoc[5](loc1: Option<Ty2>)\n\t52: StLoc[12](loc8: Option<Ty2>)\n\t53: StLoc[10](loc6: Option<Ty2>)\n\t54: ImmBorrowLoc[10](loc6: Option<Ty2>)\n\t55: Call option::is_none<Ty2>(&Option<Ty2>): bool\n\t56: StLoc[11](loc7: bool)\n\t57: MoveLoc[13](loc9: &mut Setting<Ty2>)\n\t58: MutBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t59: MoveLoc[6](loc2: u64)\n\t60: Call option::none<Ty2>(): Option<Ty2>\n\t61: MoveLoc[10](loc6: Option<Ty2>)\n\t62: PackGeneric[1](SettingData<Ty2>)\n\t63: Call option::fill<SettingData<Ty2>>(&mut Option<SettingData<Ty2>>, SettingData<Ty2>)\n\t64: MoveLoc[11](loc7: bool)\n\t65: BrFalse(72)\nB9:\n\t66: MoveLoc[0](Arg0: &mut Config<Ty0>)\n\t67: MutBorrowFieldGeneric[0](Config.id: UID)\n\t68: MoveLoc[2](Arg2: Ty1)\n\t69: Call dynamic_field::remove<Ty1, Setting<Ty2>>(&mut UID, Ty1): Setting<Ty2>\n\t70: Pop\n\t71: Branch(74)\nB10:\n\t72: MoveLoc[0](Arg0: &mut Config<Ty0>)\n\t73: Pop\nB11:\n\t74: MoveLoc[12](loc8: Option<Ty2>)\n\t75: Ret\n}\n\npublic(friend) exists_with_type<Ty0, Ty1: copy + drop + store, Ty2: copy + drop + store>(Arg0: &Config<Ty0>, Arg1: Ty1): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Config<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Config.id: UID)\n\t2: MoveLoc[1](Arg1: Ty1)\n\t3: Call dynamic_field::exists_with_type<Ty1, Setting<Ty2>>(&UID, Ty1): bool\n\t4: Ret\n}\n\npublic(friend) exists_with_type_for_next_epoch<Ty0, Ty1: copy + drop + store, Ty2: copy + drop + store>(Arg0: &Config<Ty0>, Arg1: Ty1, Arg2: &TxContext): bool {\nL3:\tloc0: bool\nL4:\tloc1: bool\nL5:\tloc2: u64\nL6:\tloc3: &Setting<Ty2>\nB0:\n\t0: CopyLoc[0](Arg0: &Config<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Config.id: UID)\n\t2: CopyLoc[1](Arg1: Ty1)\n\t3: Call dynamic_field::exists_with_type<Ty1, Setting<Ty2>>(&UID, Ty1): bool\n\t4: BrFalse(35)\nB1:\n\t5: MoveLoc[2](Arg2: &TxContext)\n\t6: Call tx_context::epoch(&TxContext): u64\n\t7: StLoc[5](loc2: u64)\n\t8: MoveLoc[0](Arg0: &Config<Ty0>)\n\t9: ImmBorrowFieldGeneric[0](Config.id: UID)\n\t10: MoveLoc[1](Arg1: Ty1)\n\t11: Call dynamic_field::borrow<Ty1, Setting<Ty2>>(&UID, Ty1): &Setting<Ty2>\n\t12: StLoc[6](loc3: &Setting<Ty2>)\n\t13: MoveLoc[5](loc2: u64)\n\t14: CopyLoc[6](loc3: &Setting<Ty2>)\n\t15: ImmBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t16: Call option::borrow<SettingData<Ty2>>(&Option<SettingData<Ty2>>): &SettingData<Ty2>\n\t17: ImmBorrowFieldGeneric[2](SettingData.newer_value_epoch: u64)\n\t18: ReadRef\n\t19: Eq\n\t20: BrFalse(28)\nB2:\n\t21: MoveLoc[6](loc3: &Setting<Ty2>)\n\t22: ImmBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t23: Call option::borrow<SettingData<Ty2>>(&Option<SettingData<Ty2>>): &SettingData<Ty2>\n\t24: ImmBorrowFieldGeneric[3](SettingData.newer_value: Option<Ty2>)\n\t25: Call option::is_some<Ty2>(&Option<Ty2>): bool\n\t26: StLoc[4](loc1: bool)\n\t27: Branch(32)\nB3:\n\t28: MoveLoc[6](loc3: &Setting<Ty2>)\n\t29: Pop\n\t30: LdFalse\n\t31: StLoc[4](loc1: bool)\nB4:\n\t32: MoveLoc[4](loc1: bool)\n\t33: StLoc[3](loc0: bool)\n\t34: Branch(41)\nB5:\n\t35: MoveLoc[2](Arg2: &TxContext)\n\t36: Pop\n\t37: MoveLoc[0](Arg0: &Config<Ty0>)\n\t38: Pop\n\t39: LdFalse\n\t40: StLoc[3](loc0: bool)\nB6:\n\t41: MoveLoc[3](loc0: bool)\n\t42: Ret\n}\n\npublic(friend) borrow_for_next_epoch_mut<Ty0, Ty1: copy + drop + store, Ty2: copy + drop + store>(Arg0: &mut Config<Ty0>, Arg1: &mut Ty0, Arg2: Ty1, Arg3: &mut TxContext): &mut Ty2 {\nL4:\tloc0: &mut SettingData<Ty2>\nL5:\tloc1: u64\nB0:\n\t0: MoveLoc[3](Arg3: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::epoch(&TxContext): u64\n\t3: StLoc[5](loc1: u64)\n\t4: MoveLoc[0](Arg0: &mut Config<Ty0>)\n\t5: MutBorrowFieldGeneric[0](Config.id: UID)\n\t6: MoveLoc[2](Arg2: Ty1)\n\t7: Call dynamic_field::borrow_mut<Ty1, Setting<Ty2>>(&mut UID, Ty1): &mut Setting<Ty2>\n\t8: MutBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t9: Call option::borrow_mut<SettingData<Ty2>>(&mut Option<SettingData<Ty2>>): &mut SettingData<Ty2>\n\t10: StLoc[4](loc0: &mut SettingData<Ty2>)\n\t11: CopyLoc[4](loc0: &mut SettingData<Ty2>)\n\t12: ImmBorrowFieldGeneric[2](SettingData.newer_value_epoch: u64)\n\t13: ReadRef\n\t14: MoveLoc[5](loc1: u64)\n\t15: Eq\n\t16: BrFalse(18)\nB1:\n\t17: Branch(22)\nB2:\n\t18: MoveLoc[4](loc0: &mut SettingData<Ty2>)\n\t19: Pop\n\t20: LdConst[1](u64: 1)\n\t21: Abort\nB3:\n\t22: CopyLoc[4](loc0: &mut SettingData<Ty2>)\n\t23: ImmBorrowFieldGeneric[3](SettingData.newer_value: Option<Ty2>)\n\t24: Call option::is_some<Ty2>(&Option<Ty2>): bool\n\t25: BrFalse(27)\nB4:\n\t26: Branch(31)\nB5:\n\t27: MoveLoc[4](loc0: &mut SettingData<Ty2>)\n\t28: Pop\n\t29: LdConst[1](u64: 1)\n\t30: Abort\nB6:\n\t31: MoveLoc[4](loc0: &mut SettingData<Ty2>)\n\t32: MutBorrowFieldGeneric[3](SettingData.newer_value: Option<Ty2>)\n\t33: Call option::borrow_mut<Ty2>(&mut Option<Ty2>): &mut Ty2\n\t34: Ret\n}\n\npublic(friend) read_setting_for_next_epoch<Ty0, Ty1: copy + drop + store, Ty2: copy + drop + store>(Arg0: &Config<Ty0>, Arg1: Ty1): Option<Ty2> {\nB0:\n\t0: CopyLoc[0](Arg0: &Config<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Config.id: UID)\n\t2: CopyLoc[1](Arg1: Ty1)\n\t3: Call dynamic_field::exists_with_type<Ty1, Setting<Ty2>>(&UID, Ty1): bool\n\t4: Not\n\t5: BrFalse(10)\nB1:\n\t6: MoveLoc[0](Arg0: &Config<Ty0>)\n\t7: Pop\n\t8: Call option::none<Ty2>(): Option<Ty2>\n\t9: Ret\nB2:\n\t10: MoveLoc[0](Arg0: &Config<Ty0>)\n\t11: ImmBorrowFieldGeneric[0](Config.id: UID)\n\t12: MoveLoc[1](Arg1: Ty1)\n\t13: Call dynamic_field::borrow<Ty1, Setting<Ty2>>(&UID, Ty1): &Setting<Ty2>\n\t14: ImmBorrowFieldGeneric[1](Setting.data: Option<SettingData<Ty2>>)\n\t15: Call option::borrow<SettingData<Ty2>>(&Option<SettingData<Ty2>>): &SettingData<Ty2>\n\t16: ImmBorrowFieldGeneric[3](SettingData.newer_value: Option<Ty2>)\n\t17: ReadRef\n\t18: Ret\n}\n\npublic(friend) read_setting<Ty0: copy + drop + store, Ty1: copy + drop + store>(Arg0: ID, Arg1: Ty0, Arg2: &TxContext): Option<Ty1> {\nL3:\tloc0: address\nL4:\tloc1: address\nB0:\n\t0: ImmBorrowLoc[0](Arg0: ID)\n\t1: Call object::id_to_address(&ID): address\n\t2: StLoc[3](loc0: address)\n\t3: CopyLoc[3](loc0: address)\n\t4: MoveLoc[1](Arg1: Ty0)\n\t5: Call dynamic_field::hash_type_and_key<Ty0>(address, Ty0): address\n\t6: StLoc[4](loc1: address)\n\t7: MoveLoc[3](loc0: address)\n\t8: MoveLoc[4](loc1: address)\n\t9: MoveLoc[2](Arg2: &TxContext)\n\t10: Call tx_context::epoch(&TxContext): u64\n\t11: Call read_setting_impl<Field<Ty0, Setting<Ty1>>, Setting<Ty1>, SettingData<Ty1>, Ty1>(address, address, u64): Option<Ty1>\n\t12: Ret\n}\n\nnative read_setting_impl<Ty0: key, Ty1: store, Ty2: store, Ty3: copy + drop + store>(Arg0: address, Arg1: address, Arg2: u64): Option<Ty3>;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n]\n}\n","deny_list":"// Move bytecode v6\nmodule 2.deny_list {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::bag;\nuse 0000000000000000000000000000000000000000000000000000000000000002::config;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_object_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::table;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::vec_set;\n\nstruct DenyList has key {\n\tid: UID,\n\tlists: Bag\n}\n\nstruct ConfigWriteCap has drop {\n\tdummy_field: bool\n}\n\nstruct ConfigKey has copy, drop, store {\n\tper_type_index: u64,\n\tper_type_key: vector<u8>\n}\n\nstruct AddressKey has copy, drop, store {\n\tpos0: address\n}\n\nstruct GlobalPauseKey has copy, drop, store {\n\tdummy_field: bool\n}\n\nstruct PerTypeConfigCreated has copy, drop, store {\n\tkey: ConfigKey,\n\tconfig_id: ID\n}\n\nstruct PerTypeList has store, key {\n\tid: UID,\n\tdenied_count: Table<address, u64>,\n\tdenied_addresses: Table<vector<u8>, VecSet<address>>\n}\n\npublic(friend) v2_add(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: address, Arg4: &mut TxContext) {\nL5:\tloc0: ConfigWriteCap\nL6:\tloc1: &mut ConfigWriteCap\nL7:\tloc2: &mut Config<ConfigWriteCap>\nL8:\tloc3: &mut TxContext\nL9:\tloc4: &mut TxContext\nL10:\tloc5: &mut DenyList\nL11:\tloc6: AddressKey\nL12:\tloc7: &mut bool\nL13:\tloc8: &mut Config<ConfigWriteCap>\nL14:\tloc9: u64\nL15:\tloc10: vector<u8>\nL16:\tloc11: AddressKey\nB0:\n\t0: MoveLoc[0](Arg0: &mut DenyList)\n\t1: StLoc[10](loc5: &mut DenyList)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: StLoc[14](loc9: u64)\n\t4: MoveLoc[2](Arg2: vector<u8>)\n\t5: StLoc[15](loc10: vector<u8>)\n\t6: CopyLoc[4](Arg4: &mut TxContext)\n\t7: StLoc[8](loc3: &mut TxContext)\n\t8: CopyLoc[10](loc5: &mut DenyList)\n\t9: FreezeRef\n\t10: CopyLoc[14](loc9: u64)\n\t11: CopyLoc[15](loc10: vector<u8>)\n\t12: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t13: Not\n\t14: BrFalse(21)\nB1:\n\t15: CopyLoc[10](loc5: &mut DenyList)\n\t16: CopyLoc[14](loc9: u64)\n\t17: CopyLoc[15](loc10: vector<u8>)\n\t18: MoveLoc[8](loc3: &mut TxContext)\n\t19: Call add_per_type_config(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t20: Branch(23)\nB2:\n\t21: MoveLoc[8](loc3: &mut TxContext)\n\t22: Pop\nB3:\n\t23: MoveLoc[10](loc5: &mut DenyList)\n\t24: MoveLoc[14](loc9: u64)\n\t25: MoveLoc[15](loc10: vector<u8>)\n\t26: Call borrow_per_type_config_mut(&mut DenyList, u64, vector<u8>): &mut Config<ConfigWriteCap>\n\t27: StLoc[13](loc8: &mut Config<ConfigWriteCap>)\n\t28: MoveLoc[3](Arg3: address)\n\t29: Pack[3](AddressKey)\n\t30: StLoc[16](loc11: AddressKey)\n\t31: MoveLoc[13](loc8: &mut Config<ConfigWriteCap>)\n\t32: StLoc[7](loc2: &mut Config<ConfigWriteCap>)\n\t33: LdFalse\n\t34: Pack[1](ConfigWriteCap)\n\t35: StLoc[5](loc0: ConfigWriteCap)\n\t36: MutBorrowLoc[5](loc0: ConfigWriteCap)\n\t37: StLoc[6](loc1: &mut ConfigWriteCap)\n\t38: MoveLoc[16](loc11: AddressKey)\n\t39: StLoc[11](loc6: AddressKey)\n\t40: MoveLoc[4](Arg4: &mut TxContext)\n\t41: StLoc[9](loc4: &mut TxContext)\n\t42: CopyLoc[7](loc2: &mut Config<ConfigWriteCap>)\n\t43: FreezeRef\n\t44: CopyLoc[11](loc6: AddressKey)\n\t45: CopyLoc[9](loc4: &mut TxContext)\n\t46: FreezeRef\n\t47: Call config::exists_with_type_for_next_epoch<ConfigWriteCap, AddressKey, bool>(&Config<ConfigWriteCap>, AddressKey, &TxContext): bool\n\t48: Not\n\t49: BrFalse(63)\nB4:\n\t50: CopyLoc[7](loc2: &mut Config<ConfigWriteCap>)\n\t51: Pop\n\t52: CopyLoc[6](loc1: &mut ConfigWriteCap)\n\t53: Pop\n\t54: CopyLoc[9](loc4: &mut TxContext)\n\t55: Pop\n\t56: CopyLoc[7](loc2: &mut Config<ConfigWriteCap>)\n\t57: CopyLoc[6](loc1: &mut ConfigWriteCap)\n\t58: CopyLoc[11](loc6: AddressKey)\n\t59: LdTrue\n\t60: CopyLoc[9](loc4: &mut TxContext)\n\t61: Call config::add_for_next_epoch<ConfigWriteCap, AddressKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, AddressKey, bool, &mut TxContext): Option<bool>\n\t62: Pop\nB5:\n\t63: MoveLoc[7](loc2: &mut Config<ConfigWriteCap>)\n\t64: MoveLoc[6](loc1: &mut ConfigWriteCap)\n\t65: MoveLoc[11](loc6: AddressKey)\n\t66: MoveLoc[9](loc4: &mut TxContext)\n\t67: Call config::borrow_for_next_epoch_mut<ConfigWriteCap, AddressKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, AddressKey, &mut TxContext): &mut bool\n\t68: StLoc[12](loc7: &mut bool)\n\t69: LdTrue\n\t70: MoveLoc[12](loc7: &mut bool)\n\t71: WriteRef\n\t72: Ret\n}\n\npublic(friend) v2_remove(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: address, Arg4: &mut TxContext) {\nL5:\tloc0: ConfigWriteCap\nL6:\tloc1: &mut Config<ConfigWriteCap>\nL7:\tloc2: &mut TxContext\nL8:\tloc3: &mut DenyList\nL9:\tloc4: &mut Config<ConfigWriteCap>\nL10:\tloc5: u64\nL11:\tloc6: vector<u8>\nL12:\tloc7: AddressKey\nB0:\n\t0: MoveLoc[0](Arg0: &mut DenyList)\n\t1: StLoc[8](loc3: &mut DenyList)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: StLoc[10](loc5: u64)\n\t4: MoveLoc[2](Arg2: vector<u8>)\n\t5: StLoc[11](loc6: vector<u8>)\n\t6: CopyLoc[4](Arg4: &mut TxContext)\n\t7: StLoc[7](loc2: &mut TxContext)\n\t8: CopyLoc[8](loc3: &mut DenyList)\n\t9: FreezeRef\n\t10: CopyLoc[10](loc5: u64)\n\t11: CopyLoc[11](loc6: vector<u8>)\n\t12: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t13: Not\n\t14: BrFalse(21)\nB1:\n\t15: CopyLoc[8](loc3: &mut DenyList)\n\t16: CopyLoc[10](loc5: u64)\n\t17: CopyLoc[11](loc6: vector<u8>)\n\t18: MoveLoc[7](loc2: &mut TxContext)\n\t19: Call add_per_type_config(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t20: Branch(23)\nB2:\n\t21: MoveLoc[7](loc2: &mut TxContext)\n\t22: Pop\nB3:\n\t23: MoveLoc[8](loc3: &mut DenyList)\n\t24: MoveLoc[10](loc5: u64)\n\t25: MoveLoc[11](loc6: vector<u8>)\n\t26: Call borrow_per_type_config_mut(&mut DenyList, u64, vector<u8>): &mut Config<ConfigWriteCap>\n\t27: StLoc[9](loc4: &mut Config<ConfigWriteCap>)\n\t28: MoveLoc[3](Arg3: address)\n\t29: Pack[3](AddressKey)\n\t30: StLoc[12](loc7: AddressKey)\n\t31: MoveLoc[9](loc4: &mut Config<ConfigWriteCap>)\n\t32: StLoc[6](loc1: &mut Config<ConfigWriteCap>)\n\t33: LdFalse\n\t34: Pack[1](ConfigWriteCap)\n\t35: StLoc[5](loc0: ConfigWriteCap)\n\t36: MoveLoc[6](loc1: &mut Config<ConfigWriteCap>)\n\t37: MutBorrowLoc[5](loc0: ConfigWriteCap)\n\t38: MoveLoc[12](loc7: AddressKey)\n\t39: MoveLoc[4](Arg4: &mut TxContext)\n\t40: Call config::remove_for_next_epoch<ConfigWriteCap, AddressKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, AddressKey, &mut TxContext): Option<bool>\n\t41: Pop\n\t42: Ret\n}\n\npublic(friend) v2_contains_current_epoch(Arg0: &DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: address, Arg4: &TxContext): bool {\nL5:\tloc0: bool\nL6:\tloc1: Option<bool>\nL7:\tloc2: &Config<ConfigWriteCap>\nL8:\tloc3: AddressKey\nB0:\n\t0: CopyLoc[0](Arg0: &DenyList)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: CopyLoc[2](Arg2: vector<u8>)\n\t3: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t4: Not\n\t5: BrFalse(12)\nB1:\n\t6: MoveLoc[0](Arg0: &DenyList)\n\t7: Pop\n\t8: MoveLoc[4](Arg4: &TxContext)\n\t9: Pop\n\t10: LdFalse\n\t11: Ret\nB2:\n\t12: MoveLoc[0](Arg0: &DenyList)\n\t13: MoveLoc[1](Arg1: u64)\n\t14: MoveLoc[2](Arg2: vector<u8>)\n\t15: Call borrow_per_type_config(&DenyList, u64, vector<u8>): &Config<ConfigWriteCap>\n\t16: StLoc[7](loc2: &Config<ConfigWriteCap>)\n\t17: MoveLoc[3](Arg3: address)\n\t18: Pack[3](AddressKey)\n\t19: StLoc[8](loc3: AddressKey)\n\t20: MoveLoc[7](loc2: &Config<ConfigWriteCap>)\n\t21: Call object::id<Config<ConfigWriteCap>>(&Config<ConfigWriteCap>): ID\n\t22: MoveLoc[8](loc3: AddressKey)\n\t23: MoveLoc[4](Arg4: &TxContext)\n\t24: Call config::read_setting<AddressKey, bool>(ID, AddressKey, &TxContext): Option<bool>\n\t25: StLoc[6](loc1: Option<bool>)\n\t26: ImmBorrowLoc[6](loc1: Option<bool>)\n\t27: Call option::is_some<bool>(&Option<bool>): bool\n\t28: BrFalse(33)\nB3:\n\t29: MoveLoc[6](loc1: Option<bool>)\n\t30: Call option::destroy_some<bool>(Option<bool>): bool\n\t31: StLoc[5](loc0: bool)\n\t32: Branch(37)\nB4:\n\t33: MoveLoc[6](loc1: Option<bool>)\n\t34: Call option::destroy_none<bool>(Option<bool>)\n\t35: LdFalse\n\t36: StLoc[5](loc0: bool)\nB5:\n\t37: MoveLoc[5](loc0: bool)\n\t38: Ret\n}\n\npublic(friend) v2_contains_next_epoch(Arg0: &DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: address): bool {\nL4:\tloc0: bool\nL5:\tloc1: Option<bool>\nL6:\tloc2: &Config<ConfigWriteCap>\nL7:\tloc3: AddressKey\nB0:\n\t0: CopyLoc[0](Arg0: &DenyList)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: CopyLoc[2](Arg2: vector<u8>)\n\t3: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t4: Not\n\t5: BrFalse(10)\nB1:\n\t6: MoveLoc[0](Arg0: &DenyList)\n\t7: Pop\n\t8: LdFalse\n\t9: Ret\nB2:\n\t10: MoveLoc[0](Arg0: &DenyList)\n\t11: MoveLoc[1](Arg1: u64)\n\t12: MoveLoc[2](Arg2: vector<u8>)\n\t13: Call borrow_per_type_config(&DenyList, u64, vector<u8>): &Config<ConfigWriteCap>\n\t14: StLoc[6](loc2: &Config<ConfigWriteCap>)\n\t15: MoveLoc[3](Arg3: address)\n\t16: Pack[3](AddressKey)\n\t17: StLoc[7](loc3: AddressKey)\n\t18: MoveLoc[6](loc2: &Config<ConfigWriteCap>)\n\t19: MoveLoc[7](loc3: AddressKey)\n\t20: Call config::read_setting_for_next_epoch<ConfigWriteCap, AddressKey, bool>(&Config<ConfigWriteCap>, AddressKey): Option<bool>\n\t21: StLoc[5](loc1: Option<bool>)\n\t22: ImmBorrowLoc[5](loc1: Option<bool>)\n\t23: Call option::is_some<bool>(&Option<bool>): bool\n\t24: BrFalse(29)\nB3:\n\t25: MoveLoc[5](loc1: Option<bool>)\n\t26: Call option::destroy_some<bool>(Option<bool>): bool\n\t27: StLoc[4](loc0: bool)\n\t28: Branch(33)\nB4:\n\t29: MoveLoc[5](loc1: Option<bool>)\n\t30: Call option::destroy_none<bool>(Option<bool>)\n\t31: LdFalse\n\t32: StLoc[4](loc0: bool)\nB5:\n\t33: MoveLoc[4](loc0: bool)\n\t34: Ret\n}\n\npublic(friend) v2_enable_global_pause(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: &mut TxContext) {\nL4:\tloc0: ConfigWriteCap\nL5:\tloc1: &mut ConfigWriteCap\nL6:\tloc2: &mut Config<ConfigWriteCap>\nL7:\tloc3: &mut TxContext\nL8:\tloc4: &mut TxContext\nL9:\tloc5: &mut DenyList\nL10:\tloc6: GlobalPauseKey\nL11:\tloc7: &mut bool\nL12:\tloc8: u64\nL13:\tloc9: vector<u8>\nB0:\n\t0: MoveLoc[0](Arg0: &mut DenyList)\n\t1: StLoc[9](loc5: &mut DenyList)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: StLoc[12](loc8: u64)\n\t4: MoveLoc[2](Arg2: vector<u8>)\n\t5: StLoc[13](loc9: vector<u8>)\n\t6: CopyLoc[3](Arg3: &mut TxContext)\n\t7: StLoc[7](loc3: &mut TxContext)\n\t8: CopyLoc[9](loc5: &mut DenyList)\n\t9: FreezeRef\n\t10: CopyLoc[12](loc8: u64)\n\t11: CopyLoc[13](loc9: vector<u8>)\n\t12: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t13: Not\n\t14: BrFalse(21)\nB1:\n\t15: CopyLoc[9](loc5: &mut DenyList)\n\t16: CopyLoc[12](loc8: u64)\n\t17: CopyLoc[13](loc9: vector<u8>)\n\t18: MoveLoc[7](loc3: &mut TxContext)\n\t19: Call add_per_type_config(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t20: Branch(23)\nB2:\n\t21: MoveLoc[7](loc3: &mut TxContext)\n\t22: Pop\nB3:\n\t23: MoveLoc[9](loc5: &mut DenyList)\n\t24: MoveLoc[12](loc8: u64)\n\t25: MoveLoc[13](loc9: vector<u8>)\n\t26: Call borrow_per_type_config_mut(&mut DenyList, u64, vector<u8>): &mut Config<ConfigWriteCap>\n\t27: StLoc[6](loc2: &mut Config<ConfigWriteCap>)\n\t28: LdFalse\n\t29: Pack[1](ConfigWriteCap)\n\t30: StLoc[4](loc0: ConfigWriteCap)\n\t31: MutBorrowLoc[4](loc0: ConfigWriteCap)\n\t32: StLoc[5](loc1: &mut ConfigWriteCap)\n\t33: LdFalse\n\t34: Pack[4](GlobalPauseKey)\n\t35: StLoc[10](loc6: GlobalPauseKey)\n\t36: MoveLoc[3](Arg3: &mut TxContext)\n\t37: StLoc[8](loc4: &mut TxContext)\n\t38: CopyLoc[6](loc2: &mut Config<ConfigWriteCap>)\n\t39: FreezeRef\n\t40: CopyLoc[10](loc6: GlobalPauseKey)\n\t41: CopyLoc[8](loc4: &mut TxContext)\n\t42: FreezeRef\n\t43: Call config::exists_with_type_for_next_epoch<ConfigWriteCap, GlobalPauseKey, bool>(&Config<ConfigWriteCap>, GlobalPauseKey, &TxContext): bool\n\t44: Not\n\t45: BrFalse(59)\nB4:\n\t46: CopyLoc[6](loc2: &mut Config<ConfigWriteCap>)\n\t47: Pop\n\t48: CopyLoc[5](loc1: &mut ConfigWriteCap)\n\t49: Pop\n\t50: CopyLoc[8](loc4: &mut TxContext)\n\t51: Pop\n\t52: CopyLoc[6](loc2: &mut Config<ConfigWriteCap>)\n\t53: CopyLoc[5](loc1: &mut ConfigWriteCap)\n\t54: CopyLoc[10](loc6: GlobalPauseKey)\n\t55: LdTrue\n\t56: CopyLoc[8](loc4: &mut TxContext)\n\t57: Call config::add_for_next_epoch<ConfigWriteCap, GlobalPauseKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, GlobalPauseKey, bool, &mut TxContext): Option<bool>\n\t58: Pop\nB5:\n\t59: MoveLoc[6](loc2: &mut Config<ConfigWriteCap>)\n\t60: MoveLoc[5](loc1: &mut ConfigWriteCap)\n\t61: MoveLoc[10](loc6: GlobalPauseKey)\n\t62: MoveLoc[8](loc4: &mut TxContext)\n\t63: Call config::borrow_for_next_epoch_mut<ConfigWriteCap, GlobalPauseKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, GlobalPauseKey, &mut TxContext): &mut bool\n\t64: StLoc[11](loc7: &mut bool)\n\t65: LdTrue\n\t66: MoveLoc[11](loc7: &mut bool)\n\t67: WriteRef\n\t68: Ret\n}\n\npublic(friend) v2_disable_global_pause(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: &mut TxContext) {\nL4:\tloc0: ConfigWriteCap\nL5:\tloc1: &mut Config<ConfigWriteCap>\nL6:\tloc2: &mut TxContext\nL7:\tloc3: &mut DenyList\nL8:\tloc4: u64\nL9:\tloc5: vector<u8>\nB0:\n\t0: MoveLoc[0](Arg0: &mut DenyList)\n\t1: StLoc[7](loc3: &mut DenyList)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: StLoc[8](loc4: u64)\n\t4: MoveLoc[2](Arg2: vector<u8>)\n\t5: StLoc[9](loc5: vector<u8>)\n\t6: CopyLoc[3](Arg3: &mut TxContext)\n\t7: StLoc[6](loc2: &mut TxContext)\n\t8: CopyLoc[7](loc3: &mut DenyList)\n\t9: FreezeRef\n\t10: CopyLoc[8](loc4: u64)\n\t11: CopyLoc[9](loc5: vector<u8>)\n\t12: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t13: Not\n\t14: BrFalse(21)\nB1:\n\t15: CopyLoc[7](loc3: &mut DenyList)\n\t16: CopyLoc[8](loc4: u64)\n\t17: CopyLoc[9](loc5: vector<u8>)\n\t18: MoveLoc[6](loc2: &mut TxContext)\n\t19: Call add_per_type_config(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t20: Branch(23)\nB2:\n\t21: MoveLoc[6](loc2: &mut TxContext)\n\t22: Pop\nB3:\n\t23: MoveLoc[7](loc3: &mut DenyList)\n\t24: MoveLoc[8](loc4: u64)\n\t25: MoveLoc[9](loc5: vector<u8>)\n\t26: Call borrow_per_type_config_mut(&mut DenyList, u64, vector<u8>): &mut Config<ConfigWriteCap>\n\t27: StLoc[5](loc1: &mut Config<ConfigWriteCap>)\n\t28: LdFalse\n\t29: Pack[1](ConfigWriteCap)\n\t30: StLoc[4](loc0: ConfigWriteCap)\n\t31: MoveLoc[5](loc1: &mut Config<ConfigWriteCap>)\n\t32: MutBorrowLoc[4](loc0: ConfigWriteCap)\n\t33: LdFalse\n\t34: Pack[4](GlobalPauseKey)\n\t35: MoveLoc[3](Arg3: &mut TxContext)\n\t36: Call config::remove_for_next_epoch<ConfigWriteCap, GlobalPauseKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, GlobalPauseKey, &mut TxContext): Option<bool>\n\t37: Pop\n\t38: Ret\n}\n\npublic(friend) v2_is_global_pause_enabled_current_epoch(Arg0: &DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: &TxContext): bool {\nL4:\tloc0: bool\nL5:\tloc1: Option<bool>\nB0:\n\t0: CopyLoc[0](Arg0: &DenyList)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: CopyLoc[2](Arg2: vector<u8>)\n\t3: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t4: Not\n\t5: BrFalse(12)\nB1:\n\t6: MoveLoc[0](Arg0: &DenyList)\n\t7: Pop\n\t8: MoveLoc[3](Arg3: &TxContext)\n\t9: Pop\n\t10: LdFalse\n\t11: Ret\nB2:\n\t12: MoveLoc[0](Arg0: &DenyList)\n\t13: MoveLoc[1](Arg1: u64)\n\t14: MoveLoc[2](Arg2: vector<u8>)\n\t15: Call borrow_per_type_config(&DenyList, u64, vector<u8>): &Config<ConfigWriteCap>\n\t16: Call object::id<Config<ConfigWriteCap>>(&Config<ConfigWriteCap>): ID\n\t17: LdFalse\n\t18: Pack[4](GlobalPauseKey)\n\t19: MoveLoc[3](Arg3: &TxContext)\n\t20: Call config::read_setting<GlobalPauseKey, bool>(ID, GlobalPauseKey, &TxContext): Option<bool>\n\t21: StLoc[5](loc1: Option<bool>)\n\t22: ImmBorrowLoc[5](loc1: Option<bool>)\n\t23: Call option::is_some<bool>(&Option<bool>): bool\n\t24: BrFalse(29)\nB3:\n\t25: MoveLoc[5](loc1: Option<bool>)\n\t26: Call option::destroy_some<bool>(Option<bool>): bool\n\t27: StLoc[4](loc0: bool)\n\t28: Branch(33)\nB4:\n\t29: MoveLoc[5](loc1: Option<bool>)\n\t30: Call option::destroy_none<bool>(Option<bool>)\n\t31: LdFalse\n\t32: StLoc[4](loc0: bool)\nB5:\n\t33: MoveLoc[4](loc0: bool)\n\t34: Ret\n}\n\npublic(friend) v2_is_global_pause_enabled_next_epoch(Arg0: &DenyList, Arg1: u64, Arg2: vector<u8>): bool {\nL3:\tloc0: bool\nL4:\tloc1: Option<bool>\nB0:\n\t0: CopyLoc[0](Arg0: &DenyList)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: CopyLoc[2](Arg2: vector<u8>)\n\t3: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t4: Not\n\t5: BrFalse(10)\nB1:\n\t6: MoveLoc[0](Arg0: &DenyList)\n\t7: Pop\n\t8: LdFalse\n\t9: Ret\nB2:\n\t10: MoveLoc[0](Arg0: &DenyList)\n\t11: MoveLoc[1](Arg1: u64)\n\t12: MoveLoc[2](Arg2: vector<u8>)\n\t13: Call borrow_per_type_config(&DenyList, u64, vector<u8>): &Config<ConfigWriteCap>\n\t14: LdFalse\n\t15: Pack[4](GlobalPauseKey)\n\t16: Call config::read_setting_for_next_epoch<ConfigWriteCap, GlobalPauseKey, bool>(&Config<ConfigWriteCap>, GlobalPauseKey): Option<bool>\n\t17: StLoc[4](loc1: Option<bool>)\n\t18: ImmBorrowLoc[4](loc1: Option<bool>)\n\t19: Call option::is_some<bool>(&Option<bool>): bool\n\t20: BrFalse(25)\nB3:\n\t21: MoveLoc[4](loc1: Option<bool>)\n\t22: Call option::destroy_some<bool>(Option<bool>): bool\n\t23: StLoc[3](loc0: bool)\n\t24: Branch(29)\nB4:\n\t25: MoveLoc[4](loc1: Option<bool>)\n\t26: Call option::destroy_none<bool>(Option<bool>)\n\t27: LdFalse\n\t28: StLoc[3](loc0: bool)\nB5:\n\t29: MoveLoc[3](loc0: bool)\n\t30: Ret\n}\n\npublic(friend) migrate_v1_to_v2(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: &mut TxContext) {\nL4:\tloc0: u64\nL5:\tloc1: u64\nL6:\tloc2: vector<address>\nL7:\tloc3: ConfigWriteCap\nL8:\tloc4: address\nL9:\tloc5: &mut PerTypeList\nL10:\tloc6: &mut ConfigWriteCap\nL11:\tloc7: &mut Config<ConfigWriteCap>\nL12:\tloc8: &mut TxContext\nL13:\tloc9: &mut TxContext\nL14:\tloc10: &mut u64\nL15:\tloc11: &mut DenyList\nL16:\tloc12: vector<address>\nL17:\tloc13: u64\nL18:\tloc14: u64\nL19:\tloc15: u64\nL20:\tloc16: AddressKey\nL21:\tloc17: &mut bool\nL22:\tloc18: &mut Config<ConfigWriteCap>\nL23:\tloc19: u64\nL24:\tloc20: vector<u8>\nL25:\tloc21: AddressKey\nL26:\tloc22: u64\nL27:\tloc23: u64\nL28:\tloc24: &vector<address>\nL29:\tloc25: vector<address>\nB0:\n\t0: CopyLoc[0](Arg0: &mut DenyList)\n\t1: MutBorrowField[0](DenyList.lists: Bag)\n\t2: CopyLoc[1](Arg1: u64)\n\t3: Call bag::borrow_mut<u64, PerTypeList>(&mut Bag, u64): &mut PerTypeList\n\t4: StLoc[9](loc5: &mut PerTypeList)\n\t5: CopyLoc[9](loc5: &mut PerTypeList)\n\t6: ImmBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t7: CopyLoc[2](Arg2: vector<u8>)\n\t8: Call table::contains<vector<u8>, VecSet<address>>(&Table<vector<u8>, VecSet<address>>, vector<u8>): bool\n\t9: Not\n\t10: BrFalse(14)\nB1:\n\t11: LdConst[3](vector<address>: 00)\n\t12: StLoc[6](loc2: vector<address>)\n\t13: Branch(20)\nB2:\n\t14: CopyLoc[9](loc5: &mut PerTypeList)\n\t15: MutBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t16: CopyLoc[2](Arg2: vector<u8>)\n\t17: Call table::remove<vector<u8>, VecSet<address>>(&mut Table<vector<u8>, VecSet<address>>, vector<u8>): VecSet<address>\n\t18: Call vec_set::into_keys<address>(VecSet<address>): vector<address>\n\t19: StLoc[6](loc2: vector<address>)\nB3:\n\t20: MoveLoc[6](loc2: vector<address>)\n\t21: StLoc[16](loc12: vector<address>)\n\t22: ImmBorrowLoc[16](loc12: vector<address>)\n\t23: StLoc[28](loc24: &vector<address>)\n\t24: CopyLoc[28](loc24: &vector<address>)\n\t25: VecLen(48)\n\t26: StLoc[5](loc1: u64)\n\t27: LdU64(0)\n\t28: StLoc[18](loc14: u64)\n\t29: MoveLoc[5](loc1: u64)\n\t30: StLoc[27](loc23: u64)\nB4:\n\t31: CopyLoc[18](loc14: u64)\n\t32: CopyLoc[27](loc23: u64)\n\t33: Lt\n\t34: BrFalse(68)\nB5:\n\t35: CopyLoc[18](loc14: u64)\n\t36: StLoc[19](loc15: u64)\n\t37: CopyLoc[28](loc24: &vector<address>)\n\t38: MoveLoc[19](loc15: u64)\n\t39: VecImmBorrow(48)\n\t40: ReadRef\n\t41: StLoc[8](loc4: address)\n\t42: CopyLoc[9](loc5: &mut PerTypeList)\n\t43: MutBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t44: CopyLoc[8](loc4: address)\n\t45: Call table::borrow_mut<address, u64>(&mut Table<address, u64>, address): &mut u64\n\t46: StLoc[14](loc10: &mut u64)\n\t47: CopyLoc[14](loc10: &mut u64)\n\t48: ReadRef\n\t49: LdU64(1)\n\t50: Sub\n\t51: CopyLoc[14](loc10: &mut u64)\n\t52: WriteRef\n\t53: MoveLoc[14](loc10: &mut u64)\n\t54: ReadRef\n\t55: LdU64(0)\n\t56: Eq\n\t57: BrFalse(63)\nB6:\n\t58: CopyLoc[9](loc5: &mut PerTypeList)\n\t59: MutBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t60: MoveLoc[8](loc4: address)\n\t61: Call table::remove<address, u64>(&mut Table<address, u64>, address): u64\n\t62: Pop\nB7:\n\t63: MoveLoc[18](loc14: u64)\n\t64: LdU64(1)\n\t65: Add\n\t66: StLoc[18](loc14: u64)\n\t67: Branch(31)\nB8:\n\t68: MoveLoc[28](loc24: &vector<address>)\n\t69: Pop\n\t70: MoveLoc[9](loc5: &mut PerTypeList)\n\t71: Pop\n\t72: MoveLoc[0](Arg0: &mut DenyList)\n\t73: StLoc[15](loc11: &mut DenyList)\n\t74: MoveLoc[1](Arg1: u64)\n\t75: StLoc[23](loc19: u64)\n\t76: MoveLoc[2](Arg2: vector<u8>)\n\t77: StLoc[24](loc20: vector<u8>)\n\t78: CopyLoc[3](Arg3: &mut TxContext)\n\t79: StLoc[12](loc8: &mut TxContext)\n\t80: CopyLoc[15](loc11: &mut DenyList)\n\t81: FreezeRef\n\t82: CopyLoc[23](loc19: u64)\n\t83: CopyLoc[24](loc20: vector<u8>)\n\t84: Call per_type_exists(&DenyList, u64, vector<u8>): bool\n\t85: Not\n\t86: BrFalse(94)\nB9:\n\t87: Branch(88)\nB10:\n\t88: CopyLoc[15](loc11: &mut DenyList)\n\t89: CopyLoc[23](loc19: u64)\n\t90: CopyLoc[24](loc20: vector<u8>)\n\t91: MoveLoc[12](loc8: &mut TxContext)\n\t92: Call add_per_type_config(&mut DenyList, u64, vector<u8>, &mut TxContext)\n\t93: Branch(96)\nB11:\n\t94: MoveLoc[12](loc8: &mut TxContext)\n\t95: Pop\nB12:\n\t96: MoveLoc[15](loc11: &mut DenyList)\n\t97: MoveLoc[23](loc19: u64)\n\t98: MoveLoc[24](loc20: vector<u8>)\n\t99: Call borrow_per_type_config_mut(&mut DenyList, u64, vector<u8>): &mut Config<ConfigWriteCap>\n\t100: StLoc[22](loc18: &mut Config<ConfigWriteCap>)\n\t101: MoveLoc[16](loc12: vector<address>)\n\t102: StLoc[29](loc25: vector<address>)\n\t103: MutBorrowLoc[29](loc25: vector<address>)\n\t104: Call vector::reverse<address>(&mut vector<address>)\n\t105: ImmBorrowLoc[29](loc25: vector<address>)\n\t106: VecLen(48)\n\t107: StLoc[4](loc0: u64)\n\t108: LdU64(0)\n\t109: StLoc[17](loc13: u64)\n\t110: MoveLoc[4](loc0: u64)\n\t111: StLoc[26](loc22: u64)\nB13:\n\t112: CopyLoc[17](loc13: u64)\n\t113: CopyLoc[26](loc22: u64)\n\t114: Lt\n\t115: BrFalse(168)\nB14:\n\t116: CopyLoc[17](loc13: u64)\n\t117: Pop\n\t118: MutBorrowLoc[29](loc25: vector<address>)\n\t119: VecPopBack(48)\n\t120: Pack[3](AddressKey)\n\t121: StLoc[25](loc21: AddressKey)\n\t122: CopyLoc[22](loc18: &mut Config<ConfigWriteCap>)\n\t123: StLoc[11](loc7: &mut Config<ConfigWriteCap>)\n\t124: LdFalse\n\t125: Pack[1](ConfigWriteCap)\n\t126: StLoc[7](loc3: ConfigWriteCap)\n\t127: MutBorrowLoc[7](loc3: ConfigWriteCap)\n\t128: StLoc[10](loc6: &mut ConfigWriteCap)\n\t129: MoveLoc[25](loc21: AddressKey)\n\t130: StLoc[20](loc16: AddressKey)\n\t131: CopyLoc[3](Arg3: &mut TxContext)\n\t132: StLoc[13](loc9: &mut TxContext)\n\t133: CopyLoc[11](loc7: &mut Config<ConfigWriteCap>)\n\t134: FreezeRef\n\t135: CopyLoc[20](loc16: AddressKey)\n\t136: CopyLoc[13](loc9: &mut TxContext)\n\t137: FreezeRef\n\t138: Call config::exists_with_type_for_next_epoch<ConfigWriteCap, AddressKey, bool>(&Config<ConfigWriteCap>, AddressKey, &TxContext): bool\n\t139: Not\n\t140: BrFalse(154)\nB15:\n\t141: CopyLoc[11](loc7: &mut Config<ConfigWriteCap>)\n\t142: Pop\n\t143: CopyLoc[10](loc6: &mut ConfigWriteCap)\n\t144: Pop\n\t145: CopyLoc[13](loc9: &mut TxContext)\n\t146: Pop\n\t147: CopyLoc[11](loc7: &mut Config<ConfigWriteCap>)\n\t148: CopyLoc[10](loc6: &mut ConfigWriteCap)\n\t149: CopyLoc[20](loc16: AddressKey)\n\t150: LdTrue\n\t151: CopyLoc[13](loc9: &mut TxContext)\n\t152: Call config::add_for_next_epoch<ConfigWriteCap, AddressKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, AddressKey, bool, &mut TxContext): Option<bool>\n\t153: Pop\nB16:\n\t154: MoveLoc[11](loc7: &mut Config<ConfigWriteCap>)\n\t155: MoveLoc[10](loc6: &mut ConfigWriteCap)\n\t156: MoveLoc[20](loc16: AddressKey)\n\t157: MoveLoc[13](loc9: &mut TxContext)\n\t158: Call config::borrow_for_next_epoch_mut<ConfigWriteCap, AddressKey, bool>(&mut Config<ConfigWriteCap>, &mut ConfigWriteCap, AddressKey, &mut TxContext): &mut bool\n\t159: StLoc[21](loc17: &mut bool)\n\t160: LdTrue\n\t161: MoveLoc[21](loc17: &mut bool)\n\t162: WriteRef\n\t163: MoveLoc[17](loc13: u64)\n\t164: LdU64(1)\n\t165: Add\n\t166: StLoc[17](loc13: u64)\n\t167: Branch(112)\nB17:\n\t168: MoveLoc[22](loc18: &mut Config<ConfigWriteCap>)\n\t169: Pop\n\t170: MoveLoc[3](Arg3: &mut TxContext)\n\t171: Pop\n\t172: MoveLoc[29](loc25: vector<address>)\n\t173: VecUnpack(48, 0)\n\t174: Ret\n}\n\nadd_per_type_config(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: &mut TxContext) {\nL4:\tloc0: ConfigWriteCap\nL5:\tloc1: Config<ConfigWriteCap>\nL6:\tloc2: ID\nL7:\tloc3: ConfigKey\nB0:\n\t0: MoveLoc[1](Arg1: u64)\n\t1: MoveLoc[2](Arg2: vector<u8>)\n\t2: Pack[2](ConfigKey)\n\t3: StLoc[7](loc3: ConfigKey)\n\t4: LdFalse\n\t5: Pack[1](ConfigWriteCap)\n\t6: StLoc[4](loc0: ConfigWriteCap)\n\t7: MutBorrowLoc[4](loc0: ConfigWriteCap)\n\t8: MoveLoc[3](Arg3: &mut TxContext)\n\t9: Call config::new<ConfigWriteCap>(&mut ConfigWriteCap, &mut TxContext): Config<ConfigWriteCap>\n\t10: StLoc[5](loc1: Config<ConfigWriteCap>)\n\t11: ImmBorrowLoc[5](loc1: Config<ConfigWriteCap>)\n\t12: Call object::id<Config<ConfigWriteCap>>(&Config<ConfigWriteCap>): ID\n\t13: StLoc[6](loc2: ID)\n\t14: MoveLoc[0](Arg0: &mut DenyList)\n\t15: MutBorrowField[3](DenyList.id: UID)\n\t16: CopyLoc[7](loc3: ConfigKey)\n\t17: MoveLoc[5](loc1: Config<ConfigWriteCap>)\n\t18: Call dynamic_object_field::internal_add<ConfigKey, Config<ConfigWriteCap>>(&mut UID, ConfigKey, Config<ConfigWriteCap>)\n\t19: MoveLoc[7](loc3: ConfigKey)\n\t20: MoveLoc[6](loc2: ID)\n\t21: Pack[5](PerTypeConfigCreated)\n\t22: Call event::emit<PerTypeConfigCreated>(PerTypeConfigCreated)\n\t23: Ret\n}\n\nborrow_per_type_config_mut(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>): &mut Config<ConfigWriteCap> {\nL3:\tloc0: ConfigKey\nB0:\n\t0: MoveLoc[1](Arg1: u64)\n\t1: MoveLoc[2](Arg2: vector<u8>)\n\t2: Pack[2](ConfigKey)\n\t3: StLoc[3](loc0: ConfigKey)\n\t4: MoveLoc[0](Arg0: &mut DenyList)\n\t5: MutBorrowField[3](DenyList.id: UID)\n\t6: MoveLoc[3](loc0: ConfigKey)\n\t7: Call dynamic_object_field::internal_borrow_mut<ConfigKey, Config<ConfigWriteCap>>(&mut UID, ConfigKey): &mut Config<ConfigWriteCap>\n\t8: Ret\n}\n\nborrow_per_type_config(Arg0: &DenyList, Arg1: u64, Arg2: vector<u8>): &Config<ConfigWriteCap> {\nL3:\tloc0: ConfigKey\nB0:\n\t0: MoveLoc[1](Arg1: u64)\n\t1: MoveLoc[2](Arg2: vector<u8>)\n\t2: Pack[2](ConfigKey)\n\t3: StLoc[3](loc0: ConfigKey)\n\t4: MoveLoc[0](Arg0: &DenyList)\n\t5: ImmBorrowField[3](DenyList.id: UID)\n\t6: MoveLoc[3](loc0: ConfigKey)\n\t7: Call dynamic_object_field::internal_borrow<ConfigKey, Config<ConfigWriteCap>>(&UID, ConfigKey): &Config<ConfigWriteCap>\n\t8: Ret\n}\n\nper_type_exists(Arg0: &DenyList, Arg1: u64, Arg2: vector<u8>): bool {\nL3:\tloc0: ConfigKey\nB0:\n\t0: MoveLoc[1](Arg1: u64)\n\t1: MoveLoc[2](Arg2: vector<u8>)\n\t2: Pack[2](ConfigKey)\n\t3: StLoc[3](loc0: ConfigKey)\n\t4: MoveLoc[0](Arg0: &DenyList)\n\t5: ImmBorrowField[3](DenyList.id: UID)\n\t6: MoveLoc[3](loc0: ConfigKey)\n\t7: Call dynamic_object_field::exists_<ConfigKey>(&UID, ConfigKey): bool\n\t8: Ret\n}\n\npublic(friend) v1_add(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: address) {\nL4:\tloc0: vector<address>\nB0:\n\t0: LdConst[2](vector<address>: 1200..)\n\t1: StLoc[4](loc0: vector<address>)\n\t2: ImmBorrowLoc[4](loc0: vector<address>)\n\t3: ImmBorrowLoc[3](Arg3: address)\n\t4: Call vector::contains<address>(&vector<address>, &address): bool\n\t5: Not\n\t6: BrFalse(8)\nB1:\n\t7: Branch(12)\nB2:\n\t8: MoveLoc[0](Arg0: &mut DenyList)\n\t9: Pop\n\t10: LdConst[1](u64: 1)\n\t11: Abort\nB3:\n\t12: MoveLoc[0](Arg0: &mut DenyList)\n\t13: MutBorrowField[0](DenyList.lists: Bag)\n\t14: MoveLoc[1](Arg1: u64)\n\t15: Call bag::borrow_mut<u64, PerTypeList>(&mut Bag, u64): &mut PerTypeList\n\t16: MoveLoc[2](Arg2: vector<u8>)\n\t17: MoveLoc[3](Arg3: address)\n\t18: Call v1_per_type_list_add(&mut PerTypeList, vector<u8>, address)\n\t19: Ret\n}\n\nv1_per_type_list_add(Arg0: &mut PerTypeList, Arg1: vector<u8>, Arg2: address) {\nL3:\tloc0: &mut VecSet<address>\nL4:\tloc1: &mut u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut PerTypeList)\n\t1: ImmBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t2: CopyLoc[1](Arg1: vector<u8>)\n\t3: Call table::contains<vector<u8>, VecSet<address>>(&Table<vector<u8>, VecSet<address>>, vector<u8>): bool\n\t4: Not\n\t5: BrFalse(11)\nB1:\n\t6: CopyLoc[0](Arg0: &mut PerTypeList)\n\t7: MutBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t8: CopyLoc[1](Arg1: vector<u8>)\n\t9: Call vec_set::empty<address>(): VecSet<address>\n\t10: Call table::add<vector<u8>, VecSet<address>>(&mut Table<vector<u8>, VecSet<address>>, vector<u8>, VecSet<address>)\nB2:\n\t11: CopyLoc[0](Arg0: &mut PerTypeList)\n\t12: MutBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t13: MoveLoc[1](Arg1: vector<u8>)\n\t14: Call table::borrow_mut<vector<u8>, VecSet<address>>(&mut Table<vector<u8>, VecSet<address>>, vector<u8>): &mut VecSet<address>\n\t15: StLoc[3](loc0: &mut VecSet<address>)\n\t16: CopyLoc[3](loc0: &mut VecSet<address>)\n\t17: FreezeRef\n\t18: ImmBorrowLoc[2](Arg2: address)\n\t19: Call vec_set::contains<address>(&VecSet<address>, &address): bool\n\t20: BrFalse(26)\nB3:\n\t21: MoveLoc[0](Arg0: &mut PerTypeList)\n\t22: Pop\n\t23: MoveLoc[3](loc0: &mut VecSet<address>)\n\t24: Pop\n\t25: Ret\nB4:\n\t26: MoveLoc[3](loc0: &mut VecSet<address>)\n\t27: CopyLoc[2](Arg2: address)\n\t28: Call vec_set::insert<address>(&mut VecSet<address>, address)\n\t29: CopyLoc[0](Arg0: &mut PerTypeList)\n\t30: ImmBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t31: CopyLoc[2](Arg2: address)\n\t32: Call table::contains<address, u64>(&Table<address, u64>, address): bool\n\t33: Not\n\t34: BrFalse(40)\nB5:\n\t35: CopyLoc[0](Arg0: &mut PerTypeList)\n\t36: MutBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t37: CopyLoc[2](Arg2: address)\n\t38: LdU64(0)\n\t39: Call table::add<address, u64>(&mut Table<address, u64>, address, u64)\nB6:\n\t40: MoveLoc[0](Arg0: &mut PerTypeList)\n\t41: MutBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t42: MoveLoc[2](Arg2: address)\n\t43: Call table::borrow_mut<address, u64>(&mut Table<address, u64>, address): &mut u64\n\t44: StLoc[4](loc1: &mut u64)\n\t45: CopyLoc[4](loc1: &mut u64)\n\t46: ReadRef\n\t47: LdU64(1)\n\t48: Add\n\t49: MoveLoc[4](loc1: &mut u64)\n\t50: WriteRef\n\t51: Ret\n}\n\npublic(friend) v1_remove(Arg0: &mut DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: address) {\nL4:\tloc0: vector<address>\nB0:\n\t0: LdConst[2](vector<address>: 1200..)\n\t1: StLoc[4](loc0: vector<address>)\n\t2: ImmBorrowLoc[4](loc0: vector<address>)\n\t3: ImmBorrowLoc[3](Arg3: address)\n\t4: Call vector::contains<address>(&vector<address>, &address): bool\n\t5: Not\n\t6: BrFalse(8)\nB1:\n\t7: Branch(12)\nB2:\n\t8: MoveLoc[0](Arg0: &mut DenyList)\n\t9: Pop\n\t10: LdConst[1](u64: 1)\n\t11: Abort\nB3:\n\t12: MoveLoc[0](Arg0: &mut DenyList)\n\t13: MutBorrowField[0](DenyList.lists: Bag)\n\t14: MoveLoc[1](Arg1: u64)\n\t15: Call bag::borrow_mut<u64, PerTypeList>(&mut Bag, u64): &mut PerTypeList\n\t16: MoveLoc[2](Arg2: vector<u8>)\n\t17: MoveLoc[3](Arg3: address)\n\t18: Call v1_per_type_list_remove(&mut PerTypeList, vector<u8>, address)\n\t19: Ret\n}\n\nv1_per_type_list_remove(Arg0: &mut PerTypeList, Arg1: vector<u8>, Arg2: address) {\nL3:\tloc0: &mut VecSet<address>\nL4:\tloc1: &mut u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut PerTypeList)\n\t1: MutBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t2: MoveLoc[1](Arg1: vector<u8>)\n\t3: Call table::borrow_mut<vector<u8>, VecSet<address>>(&mut Table<vector<u8>, VecSet<address>>, vector<u8>): &mut VecSet<address>\n\t4: StLoc[3](loc0: &mut VecSet<address>)\n\t5: CopyLoc[3](loc0: &mut VecSet<address>)\n\t6: FreezeRef\n\t7: ImmBorrowLoc[2](Arg2: address)\n\t8: Call vec_set::contains<address>(&VecSet<address>, &address): bool\n\t9: BrFalse(11)\nB1:\n\t10: Branch(17)\nB2:\n\t11: MoveLoc[0](Arg0: &mut PerTypeList)\n\t12: Pop\n\t13: MoveLoc[3](loc0: &mut VecSet<address>)\n\t14: Pop\n\t15: LdConst[1](u64: 1)\n\t16: Abort\nB3:\n\t17: MoveLoc[3](loc0: &mut VecSet<address>)\n\t18: ImmBorrowLoc[2](Arg2: address)\n\t19: Call vec_set::remove<address>(&mut VecSet<address>, &address)\n\t20: CopyLoc[0](Arg0: &mut PerTypeList)\n\t21: MutBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t22: CopyLoc[2](Arg2: address)\n\t23: Call table::borrow_mut<address, u64>(&mut Table<address, u64>, address): &mut u64\n\t24: StLoc[4](loc1: &mut u64)\n\t25: CopyLoc[4](loc1: &mut u64)\n\t26: ReadRef\n\t27: LdU64(1)\n\t28: Sub\n\t29: CopyLoc[4](loc1: &mut u64)\n\t30: WriteRef\n\t31: MoveLoc[4](loc1: &mut u64)\n\t32: ReadRef\n\t33: LdU64(0)\n\t34: Eq\n\t35: BrFalse(42)\nB4:\n\t36: MoveLoc[0](Arg0: &mut PerTypeList)\n\t37: MutBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t38: MoveLoc[2](Arg2: address)\n\t39: Call table::remove<address, u64>(&mut Table<address, u64>, address): u64\n\t40: Pop\n\t41: Branch(44)\nB5:\n\t42: MoveLoc[0](Arg0: &mut PerTypeList)\n\t43: Pop\nB6:\n\t44: Ret\n}\n\npublic(friend) v1_contains(Arg0: &DenyList, Arg1: u64, Arg2: vector<u8>, Arg3: address): bool {\nL4:\tloc0: vector<address>\nB0:\n\t0: LdConst[2](vector<address>: 1200..)\n\t1: StLoc[4](loc0: vector<address>)\n\t2: ImmBorrowLoc[4](loc0: vector<address>)\n\t3: ImmBorrowLoc[3](Arg3: address)\n\t4: Call vector::contains<address>(&vector<address>, &address): bool\n\t5: BrFalse(10)\nB1:\n\t6: MoveLoc[0](Arg0: &DenyList)\n\t7: Pop\n\t8: LdFalse\n\t9: Ret\nB2:\n\t10: MoveLoc[0](Arg0: &DenyList)\n\t11: ImmBorrowField[0](DenyList.lists: Bag)\n\t12: MoveLoc[1](Arg1: u64)\n\t13: Call bag::borrow<u64, PerTypeList>(&Bag, u64): &PerTypeList\n\t14: MoveLoc[2](Arg2: vector<u8>)\n\t15: MoveLoc[3](Arg3: address)\n\t16: Call v1_per_type_list_contains(&PerTypeList, vector<u8>, address): bool\n\t17: Ret\n}\n\nv1_per_type_list_contains(Arg0: &PerTypeList, Arg1: vector<u8>, Arg2: address): bool {\nB0:\n\t0: CopyLoc[0](Arg0: &PerTypeList)\n\t1: ImmBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t2: CopyLoc[2](Arg2: address)\n\t3: Call table::contains<address, u64>(&Table<address, u64>, address): bool\n\t4: Not\n\t5: BrFalse(10)\nB1:\n\t6: MoveLoc[0](Arg0: &PerTypeList)\n\t7: Pop\n\t8: LdFalse\n\t9: Ret\nB2:\n\t10: CopyLoc[0](Arg0: &PerTypeList)\n\t11: ImmBorrowField[2](PerTypeList.denied_count: Table<address, u64>)\n\t12: CopyLoc[2](Arg2: address)\n\t13: Call table::borrow<address, u64>(&Table<address, u64>, address): &u64\n\t14: ReadRef\n\t15: LdU64(0)\n\t16: Eq\n\t17: BrFalse(22)\nB3:\n\t18: MoveLoc[0](Arg0: &PerTypeList)\n\t19: Pop\n\t20: LdFalse\n\t21: Ret\nB4:\n\t22: CopyLoc[0](Arg0: &PerTypeList)\n\t23: ImmBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t24: CopyLoc[1](Arg1: vector<u8>)\n\t25: Call table::contains<vector<u8>, VecSet<address>>(&Table<vector<u8>, VecSet<address>>, vector<u8>): bool\n\t26: Not\n\t27: BrFalse(32)\nB5:\n\t28: MoveLoc[0](Arg0: &PerTypeList)\n\t29: Pop\n\t30: LdFalse\n\t31: Ret\nB6:\n\t32: MoveLoc[0](Arg0: &PerTypeList)\n\t33: ImmBorrowField[1](PerTypeList.denied_addresses: Table<vector<u8>, VecSet<address>>)\n\t34: MoveLoc[1](Arg1: vector<u8>)\n\t35: Call table::borrow<vector<u8>, VecSet<address>>(&Table<vector<u8>, VecSet<address>>, vector<u8>): &VecSet<address>\n\t36: ImmBorrowLoc[2](Arg2: address)\n\t37: Call vec_set::contains<address>(&VecSet<address>, &address): bool\n\t38: Ret\n}\n\ncreate(Arg0: &mut TxContext) {\nL1:\tloc0: Bag\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::sender(&TxContext): address\n\t3: LdConst[4](address: 0x00..)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut TxContext)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut TxContext)\n\t12: Call bag::new(&mut TxContext): Bag\n\t13: StLoc[1](loc0: Bag)\n\t14: MutBorrowLoc[1](loc0: Bag)\n\t15: LdConst[0](u64: 0)\n\t16: MoveLoc[0](Arg0: &mut TxContext)\n\t17: Call per_type_list(&mut TxContext): PerTypeList\n\t18: Call bag::add<u64, PerTypeList>(&mut Bag, u64, PerTypeList)\n\t19: Call object::sui_deny_list_object_id(): UID\n\t20: MoveLoc[1](loc0: Bag)\n\t21: Pack[0](DenyList)\n\t22: Call transfer::share_object<DenyList>(DenyList)\n\t23: Ret\n}\n\nper_type_list(Arg0: &mut TxContext): PerTypeList {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: CopyLoc[0](Arg0: &mut TxContext)\n\t3: Call table::new<address, u64>(&mut TxContext): Table<address, u64>\n\t4: MoveLoc[0](Arg0: &mut TxContext)\n\t5: Call table::new<vector<u8>, VecSet<address>>(&mut TxContext): Table<vector<u8>, VecSet<address>>\n\t6: Pack[6](PerTypeList)\n\t7: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => vector<address>: 120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000403000000000000000000000000000000000000000000000000000000000000dee9\n\t3 => vector<address>: 00\n\t4 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","derived_object":"// Move bytecode v7\nmodule 2.derived_object {\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\n\nstruct Claimed has copy, drop, store {\n\tpos0: ID\n}\n\nstruct DerivedObjectKey<Ty0: copy + drop + store> has copy, drop, store {\n\tpos0: Ty0\n}\n\nenum ClaimedStatus has store {\n\tReserved {  }\n}\n\npublic claim<Ty0: copy + drop + store>(Arg0: &mut UID, Arg1: Ty0): UID {\nL2:\tloc0: address\nL3:\tloc1: ID\nB0:\n\t0: CopyLoc[0](Arg0: &mut UID)\n\t1: FreezeRef\n\t2: Call object::uid_to_inner(&UID): ID\n\t3: MoveLoc[1](Arg1: Ty0)\n\t4: Call derive_address<Ty0>(ID, Ty0): address\n\t5: StLoc[2](loc0: address)\n\t6: CopyLoc[2](loc0: address)\n\t7: Call object::id_from_address(address): ID\n\t8: StLoc[3](loc1: ID)\n\t9: CopyLoc[0](Arg0: &mut UID)\n\t10: FreezeRef\n\t11: CopyLoc[3](loc1: ID)\n\t12: Pack[0](Claimed)\n\t13: Call dynamic_field::exists_<Claimed>(&UID, Claimed): bool\n\t14: Not\n\t15: BrFalse(17)\nB1:\n\t16: Branch(21)\nB2:\n\t17: MoveLoc[0](Arg0: &mut UID)\n\t18: Pop\n\t19: LdU64(13835058231375822849)\n\t20: Abort\nB3:\n\t21: MoveLoc[0](Arg0: &mut UID)\n\t22: MoveLoc[3](loc1: ID)\n\t23: Pack[0](Claimed)\n\t24: PackVariant(VariantHandleIndex(0))\n\t25: Call dynamic_field::add<Claimed, ClaimedStatus>(&mut UID, Claimed, ClaimedStatus)\n\t26: MoveLoc[2](loc0: address)\n\t27: Call object::new_uid_from_hash(address): UID\n\t28: Ret\n}\n\npublic exists<Ty0: copy + drop + store>(Arg0: &UID, Arg1: Ty0): bool {\nL2:\tloc0: address\nB0:\n\t0: CopyLoc[0](Arg0: &UID)\n\t1: Call object::uid_to_inner(&UID): ID\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call derive_address<Ty0>(ID, Ty0): address\n\t4: StLoc[2](loc0: address)\n\t5: MoveLoc[0](Arg0: &UID)\n\t6: MoveLoc[2](loc0: address)\n\t7: Call object::id_from_address(address): ID\n\t8: Pack[0](Claimed)\n\t9: Call dynamic_field::exists_<Claimed>(&UID, Claimed): bool\n\t10: Ret\n}\n\npublic derive_address<Ty0: copy + drop + store>(Arg0: ID, Arg1: Ty0): address {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: ID)\n\t1: Call object::id_to_address(&ID): address\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](DerivedObjectKey<Ty0>)\n\t4: Call dynamic_field::hash_type_and_key<DerivedObjectKey<Ty0>>(address, DerivedObjectKey<Ty0>): address\n\t5: Ret\n}\n\nConstants [\n\t0 => vector<u8>: \"EObjectAlreadyExists\" // interpreted as UTF8 string\n\t1 => vector<u8>: \"Derived object is already claimed.\" // interpreted as UTF8 string\n]\n}\n","display":"// Move bytecode v6\nmodule 2.display {\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::package;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::vec_map;\n\nstruct Display<phantom Ty0: key> has store, key {\n\tid: UID,\n\tfields: VecMap<String, String>,\n\tversion: u16\n}\n\nstruct DisplayCreated<phantom Ty0: key> has copy, drop {\n\tid: ID\n}\n\nstruct VersionUpdated<phantom Ty0: key> has copy, drop {\n\tid: ID,\n\tversion: u16,\n\tfields: VecMap<String, String>\n}\n\npublic new<Ty0: key>(Arg0: &Publisher, Arg1: &mut TxContext): Display<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &Publisher)\n\t1: Call is_authorized<Ty0>(&Publisher): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(8)\nB2:\n\t4: MoveLoc[1](Arg1: &mut TxContext)\n\t5: Pop\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: MoveLoc[1](Arg1: &mut TxContext)\n\t9: Call create_internal<Ty0>(&mut TxContext): Display<Ty0>\n\t10: Ret\n}\n\npublic new_with_fields<Ty0: key>(Arg0: &Publisher, Arg1: vector<String>, Arg2: vector<String>, Arg3: &mut TxContext): Display<Ty0> {\nL4:\tloc0: u64\nL5:\tloc1: Display<Ty0>\nL6:\tloc2: String\nL7:\tloc3: u64\nL8:\tloc4: u64\nL9:\tloc5: vector<String>\nL10:\tloc6: vector<String>\nL11:\tloc7: vector<String>\nL12:\tloc8: String\nB0:\n\t0: ImmBorrowLoc[1](Arg1: vector<String>)\n\t1: VecLen(16)\n\t2: ImmBorrowLoc[2](Arg2: vector<String>)\n\t3: VecLen(16)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(13)\nB2:\n\t7: MoveLoc[0](Arg0: &Publisher)\n\t8: Pop\n\t9: MoveLoc[3](Arg3: &mut TxContext)\n\t10: Pop\n\t11: LdConst[1](u64: 1)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &Publisher)\n\t14: MoveLoc[3](Arg3: &mut TxContext)\n\t15: Call new<Ty0>(&Publisher, &mut TxContext): Display<Ty0>\n\t16: StLoc[5](loc1: Display<Ty0>)\n\t17: MoveLoc[1](Arg1: vector<String>)\n\t18: StLoc[10](loc6: vector<String>)\n\t19: MoveLoc[2](Arg2: vector<String>)\n\t20: StLoc[11](loc7: vector<String>)\n\t21: MutBorrowLoc[11](loc7: vector<String>)\n\t22: Call vector::reverse<String>(&mut vector<String>)\n\t23: ImmBorrowLoc[10](loc6: vector<String>)\n\t24: VecLen(16)\n\t25: ImmBorrowLoc[11](loc7: vector<String>)\n\t26: VecLen(16)\n\t27: Eq\n\t28: BrFalse(30)\nB4:\n\t29: Branch(32)\nB5:\n\t30: LdU64(13906834582365274111)\n\t31: Abort\nB6:\n\t32: MoveLoc[10](loc6: vector<String>)\n\t33: StLoc[9](loc5: vector<String>)\n\t34: MutBorrowLoc[9](loc5: vector<String>)\n\t35: Call vector::reverse<String>(&mut vector<String>)\n\t36: ImmBorrowLoc[9](loc5: vector<String>)\n\t37: VecLen(16)\n\t38: StLoc[4](loc0: u64)\n\t39: LdU64(0)\n\t40: StLoc[7](loc3: u64)\n\t41: MoveLoc[4](loc0: u64)\n\t42: StLoc[8](loc4: u64)\nB7:\n\t43: CopyLoc[7](loc3: u64)\n\t44: CopyLoc[8](loc4: u64)\n\t45: Lt\n\t46: BrFalse(64)\nB8:\n\t47: CopyLoc[7](loc3: u64)\n\t48: Pop\n\t49: MutBorrowLoc[9](loc5: vector<String>)\n\t50: VecPopBack(16)\n\t51: StLoc[6](loc2: String)\n\t52: MutBorrowLoc[11](loc7: vector<String>)\n\t53: VecPopBack(16)\n\t54: StLoc[12](loc8: String)\n\t55: MutBorrowLoc[5](loc1: Display<Ty0>)\n\t56: MoveLoc[6](loc2: String)\n\t57: MoveLoc[12](loc8: String)\n\t58: Call add_internal<Ty0>(&mut Display<Ty0>, String, String)\n\t59: MoveLoc[7](loc3: u64)\n\t60: LdU64(1)\n\t61: Add\n\t62: StLoc[7](loc3: u64)\n\t63: Branch(43)\nB9:\n\t64: MoveLoc[9](loc5: vector<String>)\n\t65: VecUnpack(16, 0)\n\t66: MoveLoc[11](loc7: vector<String>)\n\t67: VecUnpack(16, 0)\n\t68: MoveLoc[5](loc1: Display<Ty0>)\n\t69: Ret\n}\n\nentry public create_and_keep<Ty0: key>(Arg0: &Publisher, Arg1: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &Publisher)\n\t1: CopyLoc[1](Arg1: &mut TxContext)\n\t2: Call new<Ty0>(&Publisher, &mut TxContext): Display<Ty0>\n\t3: MoveLoc[1](Arg1: &mut TxContext)\n\t4: FreezeRef\n\t5: Call tx_context::sender(&TxContext): address\n\t6: Call transfer::public_transfer<Display<Ty0>>(Display<Ty0>, address)\n\t7: Ret\n}\n\nentry public update_version<Ty0: key>(Arg0: &mut Display<Ty0>) {\nL1:\tloc0: u16\nL2:\tloc1: VecMap<String, String>\nB0:\n\t0: CopyLoc[0](Arg0: &mut Display<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Display.version: u16)\n\t2: ReadRef\n\t3: LdU16(1)\n\t4: Add\n\t5: CopyLoc[0](Arg0: &mut Display<Ty0>)\n\t6: MutBorrowFieldGeneric[0](Display.version: u16)\n\t7: WriteRef\n\t8: CopyLoc[0](Arg0: &mut Display<Ty0>)\n\t9: ImmBorrowFieldGeneric[0](Display.version: u16)\n\t10: ReadRef\n\t11: StLoc[1](loc0: u16)\n\t12: CopyLoc[0](Arg0: &mut Display<Ty0>)\n\t13: ImmBorrowFieldGeneric[1](Display.fields: VecMap<String, String>)\n\t14: ReadRef\n\t15: StLoc[2](loc1: VecMap<String, String>)\n\t16: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t17: ImmBorrowFieldGeneric[2](Display.id: UID)\n\t18: Call object::uid_to_inner(&UID): ID\n\t19: MoveLoc[1](loc0: u16)\n\t20: MoveLoc[2](loc1: VecMap<String, String>)\n\t21: PackGeneric[0](VersionUpdated<Ty0>)\n\t22: Call event::emit<VersionUpdated<Ty0>>(VersionUpdated<Ty0>)\n\t23: Ret\n}\n\nentry public add<Ty0: key>(Arg0: &mut Display<Ty0>, Arg1: String, Arg2: String) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t1: MoveLoc[1](Arg1: String)\n\t2: MoveLoc[2](Arg2: String)\n\t3: Call add_internal<Ty0>(&mut Display<Ty0>, String, String)\n\t4: Ret\n}\n\nentry public add_multiple<Ty0: key>(Arg0: &mut Display<Ty0>, Arg1: vector<String>, Arg2: vector<String>) {\nL3:\tloc0: u64\nL4:\tloc1: String\nL5:\tloc2: u64\nL6:\tloc3: u64\nL7:\tloc4: vector<String>\nL8:\tloc5: vector<String>\nL9:\tloc6: vector<String>\nL10:\tloc7: String\nB0:\n\t0: ImmBorrowLoc[1](Arg1: vector<String>)\n\t1: VecLen(16)\n\t2: ImmBorrowLoc[2](Arg2: vector<String>)\n\t3: VecLen(16)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t8: Pop\n\t9: LdConst[1](u64: 1)\n\t10: Abort\nB3:\n\t11: MoveLoc[1](Arg1: vector<String>)\n\t12: StLoc[8](loc5: vector<String>)\n\t13: MoveLoc[2](Arg2: vector<String>)\n\t14: StLoc[9](loc6: vector<String>)\n\t15: MutBorrowLoc[9](loc6: vector<String>)\n\t16: Call vector::reverse<String>(&mut vector<String>)\n\t17: ImmBorrowLoc[8](loc5: vector<String>)\n\t18: VecLen(16)\n\t19: ImmBorrowLoc[9](loc6: vector<String>)\n\t20: VecLen(16)\n\t21: Eq\n\t22: BrFalse(24)\nB4:\n\t23: Branch(28)\nB5:\n\t24: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t25: Pop\n\t26: LdU64(13906834754163965951)\n\t27: Abort\nB6:\n\t28: MoveLoc[8](loc5: vector<String>)\n\t29: StLoc[7](loc4: vector<String>)\n\t30: MutBorrowLoc[7](loc4: vector<String>)\n\t31: Call vector::reverse<String>(&mut vector<String>)\n\t32: ImmBorrowLoc[7](loc4: vector<String>)\n\t33: VecLen(16)\n\t34: StLoc[3](loc0: u64)\n\t35: LdU64(0)\n\t36: StLoc[5](loc2: u64)\n\t37: MoveLoc[3](loc0: u64)\n\t38: StLoc[6](loc3: u64)\nB7:\n\t39: CopyLoc[5](loc2: u64)\n\t40: CopyLoc[6](loc3: u64)\n\t41: Lt\n\t42: BrFalse(60)\nB8:\n\t43: CopyLoc[5](loc2: u64)\n\t44: Pop\n\t45: MutBorrowLoc[7](loc4: vector<String>)\n\t46: VecPopBack(16)\n\t47: StLoc[4](loc1: String)\n\t48: MutBorrowLoc[9](loc6: vector<String>)\n\t49: VecPopBack(16)\n\t50: StLoc[10](loc7: String)\n\t51: CopyLoc[0](Arg0: &mut Display<Ty0>)\n\t52: MoveLoc[4](loc1: String)\n\t53: MoveLoc[10](loc7: String)\n\t54: Call add_internal<Ty0>(&mut Display<Ty0>, String, String)\n\t55: MoveLoc[5](loc2: u64)\n\t56: LdU64(1)\n\t57: Add\n\t58: StLoc[5](loc2: u64)\n\t59: Branch(39)\nB9:\n\t60: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t61: Pop\n\t62: MoveLoc[7](loc4: vector<String>)\n\t63: VecUnpack(16, 0)\n\t64: MoveLoc[9](loc6: vector<String>)\n\t65: VecUnpack(16, 0)\n\t66: Ret\n}\n\nentry public edit<Ty0: key>(Arg0: &mut Display<Ty0>, Arg1: String, Arg2: String) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Display<Ty0>)\n\t1: MutBorrowFieldGeneric[1](Display.fields: VecMap<String, String>)\n\t2: ImmBorrowLoc[1](Arg1: String)\n\t3: Call vec_map::remove<String, String>(&mut VecMap<String, String>, &String): String * String\n\t4: Pop\n\t5: Pop\n\t6: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t7: MoveLoc[1](Arg1: String)\n\t8: MoveLoc[2](Arg2: String)\n\t9: Call add_internal<Ty0>(&mut Display<Ty0>, String, String)\n\t10: Ret\n}\n\nentry public remove<Ty0: key>(Arg0: &mut Display<Ty0>, Arg1: String) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t1: MutBorrowFieldGeneric[1](Display.fields: VecMap<String, String>)\n\t2: ImmBorrowLoc[1](Arg1: String)\n\t3: Call vec_map::remove<String, String>(&mut VecMap<String, String>, &String): String * String\n\t4: Pop\n\t5: Pop\n\t6: Ret\n}\n\npublic is_authorized<Ty0: key>(Arg0: &Publisher): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Publisher)\n\t1: Call package::from_package<Ty0>(&Publisher): bool\n\t2: Ret\n}\n\npublic version<Ty0: key>(Arg0: &Display<Ty0>): u16 {\nB0:\n\t0: MoveLoc[0](Arg0: &Display<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Display.version: u16)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic fields<Ty0: key>(Arg0: &Display<Ty0>): &VecMap<String, String> {\nB0:\n\t0: MoveLoc[0](Arg0: &Display<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](Display.fields: VecMap<String, String>)\n\t2: Ret\n}\n\ncreate_internal<Ty0: key>(Arg0: &mut TxContext): Display<Ty0> {\nL1:\tloc0: UID\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: StLoc[1](loc0: UID)\n\t3: ImmBorrowLoc[1](loc0: UID)\n\t4: Call object::uid_to_inner(&UID): ID\n\t5: PackGeneric[1](DisplayCreated<Ty0>)\n\t6: Call event::emit<DisplayCreated<Ty0>>(DisplayCreated<Ty0>)\n\t7: MoveLoc[1](loc0: UID)\n\t8: Call vec_map::empty<String, String>(): VecMap<String, String>\n\t9: LdU16(0)\n\t10: PackGeneric[2](Display<Ty0>)\n\t11: Ret\n}\n\nadd_internal<Ty0: key>(Arg0: &mut Display<Ty0>, Arg1: String, Arg2: String) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Display<Ty0>)\n\t1: MutBorrowFieldGeneric[1](Display.fields: VecMap<String, String>)\n\t2: MoveLoc[1](Arg1: String)\n\t3: MoveLoc[2](Arg2: String)\n\t4: Call vec_map::insert<String, String>(&mut VecMap<String, String>, String, String)\n\t5: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n]\n}\n","dynamic_field":"// Move bytecode v6\nmodule 2.dynamic_field {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\n\nstruct Field<Ty0: copy + drop + store, Ty1: store> has key {\n\tid: UID,\n\tname: Ty0,\n\tvalue: Ty1\n}\n\npublic add<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut UID, Arg1: Ty0, Arg2: Ty1) {\nL3:\tloc0: Field<Ty0, Ty1>\nL4:\tloc1: address\nL5:\tloc2: address\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: FreezeRef\n\t2: Call object::uid_to_address(&UID): address\n\t3: StLoc[5](loc2: address)\n\t4: CopyLoc[5](loc2: address)\n\t5: CopyLoc[1](Arg1: Ty0)\n\t6: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t7: StLoc[4](loc1: address)\n\t8: CopyLoc[5](loc2: address)\n\t9: CopyLoc[4](loc1: address)\n\t10: Call has_child_object(address, address): bool\n\t11: Not\n\t12: BrFalse(14)\nB1:\n\t13: Branch(16)\nB2:\n\t14: LdConst[0](u64: 0)\n\t15: Abort\nB3:\n\t16: MoveLoc[4](loc1: address)\n\t17: Call object::new_uid_from_hash(address): UID\n\t18: MoveLoc[1](Arg1: Ty0)\n\t19: MoveLoc[2](Arg2: Ty1)\n\t20: PackGeneric[0](Field<Ty0, Ty1>)\n\t21: StLoc[3](loc0: Field<Ty0, Ty1>)\n\t22: MoveLoc[5](loc2: address)\n\t23: MoveLoc[3](loc0: Field<Ty0, Ty1>)\n\t24: Call add_child_object<Field<Ty0, Ty1>>(address, Field<Ty0, Ty1>)\n\t25: Ret\n}\n\npublic borrow<Ty0: copy + drop + store, Ty1: store>(Arg0: &UID, Arg1: Ty0): &Ty1 {\nL2:\tloc0: address\nB0:\n\t0: CopyLoc[0](Arg0: &UID)\n\t1: Call object::uid_to_address(&UID): address\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t4: StLoc[2](loc0: address)\n\t5: MoveLoc[0](Arg0: &UID)\n\t6: MoveLoc[2](loc0: address)\n\t7: Call borrow_child_object<Field<Ty0, Ty1>>(&UID, address): &Field<Ty0, Ty1>\n\t8: ImmBorrowFieldGeneric[0](Field.value: Ty1)\n\t9: Ret\n}\n\npublic borrow_mut<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut UID, Arg1: Ty0): &mut Ty1 {\nL2:\tloc0: address\nB0:\n\t0: CopyLoc[0](Arg0: &mut UID)\n\t1: FreezeRef\n\t2: Call object::uid_to_address(&UID): address\n\t3: MoveLoc[1](Arg1: Ty0)\n\t4: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t5: StLoc[2](loc0: address)\n\t6: MoveLoc[0](Arg0: &mut UID)\n\t7: MoveLoc[2](loc0: address)\n\t8: Call borrow_child_object_mut<Field<Ty0, Ty1>>(&mut UID, address): &mut Field<Ty0, Ty1>\n\t9: MutBorrowFieldGeneric[0](Field.value: Ty1)\n\t10: Ret\n}\n\npublic remove<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut UID, Arg1: Ty0): Ty1 {\nL2:\tloc0: address\nL3:\tloc1: address\nL4:\tloc2: Ty1\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: FreezeRef\n\t2: Call object::uid_to_address(&UID): address\n\t3: StLoc[3](loc1: address)\n\t4: CopyLoc[3](loc1: address)\n\t5: MoveLoc[1](Arg1: Ty0)\n\t6: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t7: StLoc[2](loc0: address)\n\t8: MoveLoc[3](loc1: address)\n\t9: MoveLoc[2](loc0: address)\n\t10: Call remove_child_object<Field<Ty0, Ty1>>(address, address): Field<Ty0, Ty1>\n\t11: UnpackGeneric[0](Field<Ty0, Ty1>)\n\t12: StLoc[4](loc2: Ty1)\n\t13: Pop\n\t14: Call object::delete(UID)\n\t15: MoveLoc[4](loc2: Ty1)\n\t16: Ret\n}\n\npublic exists_<Ty0: copy + drop + store>(Arg0: &UID, Arg1: Ty0): bool {\nL2:\tloc0: address\nL3:\tloc1: address\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: Call object::uid_to_address(&UID): address\n\t2: StLoc[3](loc1: address)\n\t3: CopyLoc[3](loc1: address)\n\t4: MoveLoc[1](Arg1: Ty0)\n\t5: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t6: StLoc[2](loc0: address)\n\t7: MoveLoc[3](loc1: address)\n\t8: MoveLoc[2](loc0: address)\n\t9: Call has_child_object(address, address): bool\n\t10: Ret\n}\n\npublic remove_if_exists<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut UID, Arg1: Ty0): Option<Ty1> {\nL2:\tloc0: Option<Ty1>\nB0:\n\t0: CopyLoc[0](Arg0: &mut UID)\n\t1: FreezeRef\n\t2: CopyLoc[1](Arg1: Ty0)\n\t3: Call exists_<Ty0>(&UID, Ty0): bool\n\t4: BrFalse(11)\nB1:\n\t5: MoveLoc[0](Arg0: &mut UID)\n\t6: MoveLoc[1](Arg1: Ty0)\n\t7: Call remove<Ty0, Ty1>(&mut UID, Ty0): Ty1\n\t8: Call option::some<Ty1>(Ty1): Option<Ty1>\n\t9: StLoc[2](loc0: Option<Ty1>)\n\t10: Branch(15)\nB2:\n\t11: MoveLoc[0](Arg0: &mut UID)\n\t12: Pop\n\t13: Call option::none<Ty1>(): Option<Ty1>\n\t14: StLoc[2](loc0: Option<Ty1>)\nB3:\n\t15: MoveLoc[2](loc0: Option<Ty1>)\n\t16: Ret\n}\n\npublic exists_with_type<Ty0: copy + drop + store, Ty1: store>(Arg0: &UID, Arg1: Ty0): bool {\nL2:\tloc0: address\nL3:\tloc1: address\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: Call object::uid_to_address(&UID): address\n\t2: StLoc[3](loc1: address)\n\t3: CopyLoc[3](loc1: address)\n\t4: MoveLoc[1](Arg1: Ty0)\n\t5: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t6: StLoc[2](loc0: address)\n\t7: MoveLoc[3](loc1: address)\n\t8: MoveLoc[2](loc0: address)\n\t9: Call has_child_object_with_ty<Field<Ty0, Ty1>>(address, address): bool\n\t10: Ret\n}\n\npublic(friend) field_info<Ty0: copy + drop + store>(Arg0: &UID, Arg1: Ty0): &UID * address {\nL2:\tloc0: &Field<Ty0, ID>\nL3:\tloc1: address\nL4:\tloc2: &UID\nL5:\tloc3: &ID\nB0:\n\t0: CopyLoc[0](Arg0: &UID)\n\t1: Call object::uid_to_address(&UID): address\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t4: StLoc[3](loc1: address)\n\t5: MoveLoc[0](Arg0: &UID)\n\t6: MoveLoc[3](loc1: address)\n\t7: Call borrow_child_object<Field<Ty0, ID>>(&UID, address): &Field<Ty0, ID>\n\t8: StLoc[2](loc0: &Field<Ty0, ID>)\n\t9: CopyLoc[2](loc0: &Field<Ty0, ID>)\n\t10: ImmBorrowFieldGeneric[1](Field.id: UID)\n\t11: StLoc[4](loc2: &UID)\n\t12: CopyLoc[2](loc0: &Field<Ty0, ID>)\n\t13: ImmBorrowFieldGeneric[2](Field.name: Ty0)\n\t14: Pop\n\t15: MoveLoc[2](loc0: &Field<Ty0, ID>)\n\t16: ImmBorrowFieldGeneric[3](Field.value: ID)\n\t17: StLoc[5](loc3: &ID)\n\t18: MoveLoc[4](loc2: &UID)\n\t19: MoveLoc[5](loc3: &ID)\n\t20: Call object::id_to_address(&ID): address\n\t21: Ret\n}\n\npublic(friend) field_info_mut<Ty0: copy + drop + store>(Arg0: &mut UID, Arg1: Ty0): &mut UID * address {\nL2:\tloc0: &mut Field<Ty0, ID>\nL3:\tloc1: address\nL4:\tloc2: &mut UID\nL5:\tloc3: &mut ID\nB0:\n\t0: CopyLoc[0](Arg0: &mut UID)\n\t1: FreezeRef\n\t2: Call object::uid_to_address(&UID): address\n\t3: MoveLoc[1](Arg1: Ty0)\n\t4: Call hash_type_and_key<Ty0>(address, Ty0): address\n\t5: StLoc[3](loc1: address)\n\t6: MoveLoc[0](Arg0: &mut UID)\n\t7: MoveLoc[3](loc1: address)\n\t8: Call borrow_child_object_mut<Field<Ty0, ID>>(&mut UID, address): &mut Field<Ty0, ID>\n\t9: StLoc[2](loc0: &mut Field<Ty0, ID>)\n\t10: CopyLoc[2](loc0: &mut Field<Ty0, ID>)\n\t11: MutBorrowFieldGeneric[1](Field.id: UID)\n\t12: StLoc[4](loc2: &mut UID)\n\t13: CopyLoc[2](loc0: &mut Field<Ty0, ID>)\n\t14: MutBorrowFieldGeneric[2](Field.name: Ty0)\n\t15: Pop\n\t16: MoveLoc[2](loc0: &mut Field<Ty0, ID>)\n\t17: MutBorrowFieldGeneric[3](Field.value: ID)\n\t18: StLoc[5](loc3: &mut ID)\n\t19: MoveLoc[4](loc2: &mut UID)\n\t20: MoveLoc[5](loc3: &mut ID)\n\t21: FreezeRef\n\t22: Call object::id_to_address(&ID): address\n\t23: Ret\n}\n\nnative public(friend) hash_type_and_key<Ty0: copy + drop + store>(Arg0: address, Arg1: Ty0): address;\n\nnative public(friend) add_child_object<Ty0: key>(Arg0: address, Arg1: Ty0);\n\nnative public(friend) borrow_child_object<Ty0: key>(Arg0: &UID, Arg1: address): &Ty0;\n\nnative public(friend) borrow_child_object_mut<Ty0: key>(Arg0: &mut UID, Arg1: address): &mut Ty0;\n\nnative public(friend) remove_child_object<Ty0: key>(Arg0: address, Arg1: address): Ty0;\n\nnative public(friend) has_child_object(Arg0: address, Arg1: address): bool;\n\nnative public(friend) has_child_object_with_ty<Ty0: key>(Arg0: address, Arg1: address): bool;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n]\n}\n","dynamic_object_field":"// Move bytecode v6\nmodule 2.dynamic_object_field {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\n\nstruct Wrapper<Ty0> has copy, drop, store {\n\tname: Ty0\n}\n\npublic add<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut UID, Arg1: Ty0, Arg2: Ty1) {\nL3:\tloc0: ID\nL4:\tloc1: Wrapper<Ty0>\nL5:\tloc2: Ty0\nL6:\tloc3: &mut UID\nL7:\tloc4: Ty1\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: StLoc[6](loc3: &mut UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: StLoc[5](loc2: Ty0)\n\t4: MoveLoc[2](Arg2: Ty1)\n\t5: StLoc[7](loc4: Ty1)\n\t6: MoveLoc[5](loc2: Ty0)\n\t7: PackGeneric[0](Wrapper<Ty0>)\n\t8: StLoc[4](loc1: Wrapper<Ty0>)\n\t9: ImmBorrowLoc[7](loc4: Ty1)\n\t10: Call object::id<Ty1>(&Ty1): ID\n\t11: StLoc[3](loc0: ID)\n\t12: CopyLoc[6](loc3: &mut UID)\n\t13: CopyLoc[4](loc1: Wrapper<Ty0>)\n\t14: MoveLoc[3](loc0: ID)\n\t15: Call dynamic_field::add<Wrapper<Ty0>, ID>(&mut UID, Wrapper<Ty0>, ID)\n\t16: MoveLoc[6](loc3: &mut UID)\n\t17: FreezeRef\n\t18: MoveLoc[4](loc1: Wrapper<Ty0>)\n\t19: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t20: Pop\n\t21: Call object::uid_to_address(&UID): address\n\t22: MoveLoc[7](loc4: Ty1)\n\t23: Call dynamic_field::add_child_object<Ty1>(address, Ty1)\n\t24: Ret\n}\n\npublic borrow<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &UID, Arg1: Ty0): &Ty1 {\nL2:\tloc0: Wrapper<Ty0>\nL3:\tloc1: &UID\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: StLoc[3](loc1: &UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[2](loc0: Wrapper<Ty0>)\n\t5: MoveLoc[3](loc1: &UID)\n\t6: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t7: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t8: Call dynamic_field::borrow_child_object<Ty1>(&UID, address): &Ty1\n\t9: Ret\n}\n\npublic borrow_mut<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut UID, Arg1: Ty0): &mut Ty1 {\nL2:\tloc0: Wrapper<Ty0>\nL3:\tloc1: &mut UID\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: StLoc[3](loc1: &mut UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[2](loc0: Wrapper<Ty0>)\n\t5: MoveLoc[3](loc1: &mut UID)\n\t6: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t7: Call dynamic_field::field_info_mut<Wrapper<Ty0>>(&mut UID, Wrapper<Ty0>): &mut UID * address\n\t8: Call dynamic_field::borrow_child_object_mut<Ty1>(&mut UID, address): &mut Ty1\n\t9: Ret\n}\n\npublic remove<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut UID, Arg1: Ty0): Ty1 {\nL2:\tloc0: Wrapper<Ty0>\nL3:\tloc1: &mut UID\nL4:\tloc2: Ty1\nL5:\tloc3: address\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: StLoc[3](loc1: &mut UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[2](loc0: Wrapper<Ty0>)\n\t5: CopyLoc[3](loc1: &mut UID)\n\t6: FreezeRef\n\t7: CopyLoc[2](loc0: Wrapper<Ty0>)\n\t8: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t9: StLoc[5](loc3: address)\n\t10: Call object::uid_to_address(&UID): address\n\t11: MoveLoc[5](loc3: address)\n\t12: Call dynamic_field::remove_child_object<Ty1>(address, address): Ty1\n\t13: StLoc[4](loc2: Ty1)\n\t14: MoveLoc[3](loc1: &mut UID)\n\t15: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t16: Call dynamic_field::remove<Wrapper<Ty0>, ID>(&mut UID, Wrapper<Ty0>): ID\n\t17: Pop\n\t18: MoveLoc[4](loc2: Ty1)\n\t19: Ret\n}\n\npublic exists_<Ty0: copy + drop + store>(Arg0: &UID, Arg1: Ty0): bool {\nL2:\tloc0: Wrapper<Ty0>\nB0:\n\t0: MoveLoc[1](Arg1: Ty0)\n\t1: PackGeneric[0](Wrapper<Ty0>)\n\t2: StLoc[2](loc0: Wrapper<Ty0>)\n\t3: MoveLoc[0](Arg0: &UID)\n\t4: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t5: Call dynamic_field::exists_with_type<Wrapper<Ty0>, ID>(&UID, Wrapper<Ty0>): bool\n\t6: Ret\n}\n\npublic exists_with_type<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &UID, Arg1: Ty0): bool {\nL2:\tloc0: bool\nL3:\tloc1: Wrapper<Ty0>\nL4:\tloc2: &UID\nL5:\tloc3: address\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: StLoc[4](loc2: &UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[3](loc1: Wrapper<Ty0>)\n\t5: CopyLoc[4](loc2: &UID)\n\t6: CopyLoc[3](loc1: Wrapper<Ty0>)\n\t7: Call dynamic_field::exists_with_type<Wrapper<Ty0>, ID>(&UID, Wrapper<Ty0>): bool\n\t8: Not\n\t9: BrFalse(15)\nB1:\n\t10: MoveLoc[4](loc2: &UID)\n\t11: Pop\n\t12: LdFalse\n\t13: StLoc[2](loc0: bool)\n\t14: Branch(23)\nB2:\n\t15: MoveLoc[4](loc2: &UID)\n\t16: MoveLoc[3](loc1: Wrapper<Ty0>)\n\t17: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t18: StLoc[5](loc3: address)\n\t19: Call object::uid_to_address(&UID): address\n\t20: MoveLoc[5](loc3: address)\n\t21: Call dynamic_field::has_child_object_with_ty<Ty1>(address, address): bool\n\t22: StLoc[2](loc0: bool)\nB3:\n\t23: MoveLoc[2](loc0: bool)\n\t24: Ret\n}\n\npublic id<Ty0: copy + drop + store>(Arg0: &UID, Arg1: Ty0): Option<ID> {\nL2:\tloc0: Wrapper<Ty0>\nL3:\tloc1: address\nB0:\n\t0: MoveLoc[1](Arg1: Ty0)\n\t1: PackGeneric[0](Wrapper<Ty0>)\n\t2: StLoc[2](loc0: Wrapper<Ty0>)\n\t3: CopyLoc[0](Arg0: &UID)\n\t4: CopyLoc[2](loc0: Wrapper<Ty0>)\n\t5: Call dynamic_field::exists_with_type<Wrapper<Ty0>, ID>(&UID, Wrapper<Ty0>): bool\n\t6: Not\n\t7: BrFalse(12)\nB1:\n\t8: MoveLoc[0](Arg0: &UID)\n\t9: Pop\n\t10: Call option::none<ID>(): Option<ID>\n\t11: Ret\nB2:\n\t12: MoveLoc[0](Arg0: &UID)\n\t13: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t14: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t15: StLoc[3](loc1: address)\n\t16: Pop\n\t17: MoveLoc[3](loc1: address)\n\t18: Call object::id_from_address(address): ID\n\t19: Call option::some<ID>(ID): Option<ID>\n\t20: Ret\n}\n\npublic(friend) internal_add<Ty0: copy + drop + store, Ty1: key>(Arg0: &mut UID, Arg1: Ty0, Arg2: Ty1) {\nL3:\tloc0: ID\nL4:\tloc1: Wrapper<Ty0>\nL5:\tloc2: Ty0\nL6:\tloc3: &mut UID\nL7:\tloc4: Ty1\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: StLoc[6](loc3: &mut UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: StLoc[5](loc2: Ty0)\n\t4: MoveLoc[2](Arg2: Ty1)\n\t5: StLoc[7](loc4: Ty1)\n\t6: MoveLoc[5](loc2: Ty0)\n\t7: PackGeneric[0](Wrapper<Ty0>)\n\t8: StLoc[4](loc1: Wrapper<Ty0>)\n\t9: ImmBorrowLoc[7](loc4: Ty1)\n\t10: Call object::id<Ty1>(&Ty1): ID\n\t11: StLoc[3](loc0: ID)\n\t12: CopyLoc[6](loc3: &mut UID)\n\t13: CopyLoc[4](loc1: Wrapper<Ty0>)\n\t14: MoveLoc[3](loc0: ID)\n\t15: Call dynamic_field::add<Wrapper<Ty0>, ID>(&mut UID, Wrapper<Ty0>, ID)\n\t16: MoveLoc[6](loc3: &mut UID)\n\t17: FreezeRef\n\t18: MoveLoc[4](loc1: Wrapper<Ty0>)\n\t19: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t20: Pop\n\t21: Call object::uid_to_address(&UID): address\n\t22: MoveLoc[7](loc4: Ty1)\n\t23: Call dynamic_field::add_child_object<Ty1>(address, Ty1)\n\t24: Ret\n}\n\npublic(friend) internal_borrow<Ty0: copy + drop + store, Ty1: key>(Arg0: &UID, Arg1: Ty0): &Ty1 {\nL2:\tloc0: Wrapper<Ty0>\nL3:\tloc1: &UID\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: StLoc[3](loc1: &UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[2](loc0: Wrapper<Ty0>)\n\t5: MoveLoc[3](loc1: &UID)\n\t6: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t7: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t8: Call dynamic_field::borrow_child_object<Ty1>(&UID, address): &Ty1\n\t9: Ret\n}\n\npublic(friend) internal_borrow_mut<Ty0: copy + drop + store, Ty1: key>(Arg0: &mut UID, Arg1: Ty0): &mut Ty1 {\nL2:\tloc0: Wrapper<Ty0>\nL3:\tloc1: &mut UID\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: StLoc[3](loc1: &mut UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[2](loc0: Wrapper<Ty0>)\n\t5: MoveLoc[3](loc1: &mut UID)\n\t6: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t7: Call dynamic_field::field_info_mut<Wrapper<Ty0>>(&mut UID, Wrapper<Ty0>): &mut UID * address\n\t8: Call dynamic_field::borrow_child_object_mut<Ty1>(&mut UID, address): &mut Ty1\n\t9: Ret\n}\n\npublic(friend) internal_remove<Ty0: copy + drop + store, Ty1: key>(Arg0: &mut UID, Arg1: Ty0): Ty1 {\nL2:\tloc0: Wrapper<Ty0>\nL3:\tloc1: &mut UID\nL4:\tloc2: Ty1\nL5:\tloc3: address\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: StLoc[3](loc1: &mut UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[2](loc0: Wrapper<Ty0>)\n\t5: CopyLoc[3](loc1: &mut UID)\n\t6: FreezeRef\n\t7: CopyLoc[2](loc0: Wrapper<Ty0>)\n\t8: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t9: StLoc[5](loc3: address)\n\t10: Call object::uid_to_address(&UID): address\n\t11: MoveLoc[5](loc3: address)\n\t12: Call dynamic_field::remove_child_object<Ty1>(address, address): Ty1\n\t13: StLoc[4](loc2: Ty1)\n\t14: MoveLoc[3](loc1: &mut UID)\n\t15: MoveLoc[2](loc0: Wrapper<Ty0>)\n\t16: Call dynamic_field::remove<Wrapper<Ty0>, ID>(&mut UID, Wrapper<Ty0>): ID\n\t17: Pop\n\t18: MoveLoc[4](loc2: Ty1)\n\t19: Ret\n}\n\npublic(friend) internal_exists_with_type<Ty0: copy + drop + store, Ty1: key>(Arg0: &UID, Arg1: Ty0): bool {\nL2:\tloc0: bool\nL3:\tloc1: Wrapper<Ty0>\nL4:\tloc2: &UID\nL5:\tloc3: address\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: StLoc[4](loc2: &UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: PackGeneric[0](Wrapper<Ty0>)\n\t4: StLoc[3](loc1: Wrapper<Ty0>)\n\t5: CopyLoc[4](loc2: &UID)\n\t6: CopyLoc[3](loc1: Wrapper<Ty0>)\n\t7: Call dynamic_field::exists_with_type<Wrapper<Ty0>, ID>(&UID, Wrapper<Ty0>): bool\n\t8: Not\n\t9: BrFalse(15)\nB1:\n\t10: MoveLoc[4](loc2: &UID)\n\t11: Pop\n\t12: LdFalse\n\t13: StLoc[2](loc0: bool)\n\t14: Branch(23)\nB2:\n\t15: MoveLoc[4](loc2: &UID)\n\t16: MoveLoc[3](loc1: Wrapper<Ty0>)\n\t17: Call dynamic_field::field_info<Wrapper<Ty0>>(&UID, Wrapper<Ty0>): &UID * address\n\t18: StLoc[5](loc3: address)\n\t19: Call object::uid_to_address(&UID): address\n\t20: MoveLoc[5](loc3: address)\n\t21: Call dynamic_field::has_child_object_with_ty<Ty1>(address, address): bool\n\t22: StLoc[2](loc0: bool)\nB3:\n\t23: MoveLoc[2](loc0: bool)\n\t24: Ret\n}\n\n}\n","ecdsa_k1":"// Move bytecode v6\nmodule 2.ecdsa_k1 {\n\nnative public secp256k1_ecrecover(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: u8): vector<u8>;\n\nnative public decompress_pubkey(Arg0: &vector<u8>): vector<u8>;\n\nnative public secp256k1_verify(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>, Arg3: u8): bool;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u8: 0\n\t4 => u8: 1\n]\n}\n","ecdsa_r1":"// Move bytecode v6\nmodule 2.ecdsa_r1 {\n\nnative public secp256r1_ecrecover(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: u8): vector<u8>;\n\nnative public secp256r1_verify(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>, Arg3: u8): bool;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u8: 0\n\t3 => u8: 1\n]\n}\n","ecvrf":"// Move bytecode v6\nmodule 2.ecvrf {\n\nnative public ecvrf_verify(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>, Arg3: &vector<u8>): bool;\n\nConstants [\n\t0 => u64: 1\n\t1 => u64: 2\n\t2 => u64: 3\n]\n}\n","ed25519":"// Move bytecode v6\nmodule 2.ed25519 {\n\nnative public ed25519_verify(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>): bool;\n\n}\n","event":"// Move bytecode v6\nmodule 2.event {\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::accumulator;\nuse 0000000000000000000000000000000000000000000000000000000000000002::accumulator_settlement;\n\nnative public emit<Ty0: copy + drop>(Arg0: Ty0);\n\npublic emit_authenticated<Ty0: copy + drop>(Arg0: Ty0) {\nL1:\tloc0: address\nB0:\n\t0: Call type_name::original_id<Ty0>(): address\n\t1: StLoc[1](loc0: address)\n\t2: CopyLoc[1](loc0: address)\n\t3: Call accumulator::accumulator_address<EventStreamHead>(address): address\n\t4: MoveLoc[1](loc0: address)\n\t5: MoveLoc[0](Arg0: Ty0)\n\t6: Call emit_authenticated_impl<EventStreamHead, Ty0>(address, address, Ty0)\n\t7: Ret\n}\n\nnative emit_authenticated_impl<Ty0, Ty1: copy + drop>(Arg0: address, Arg1: address, Arg2: Ty1);\n\n}\n","funds_accumulator":"// Move bytecode v6\nmodule 2.funds_accumulator {\nuse 0000000000000000000000000000000000000000000000000000000000000002::accumulator;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\n\nstruct Withdrawal<phantom Ty0: store> has drop {\n\towner: address,\n\tlimit: u256\n}\n\npublic withdrawal_owner<Ty0: store>(Arg0: &Withdrawal<Ty0>): address {\nB0:\n\t0: MoveLoc[0](Arg0: &Withdrawal<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Withdrawal.owner: address)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic withdrawal_limit<Ty0: store>(Arg0: &Withdrawal<Ty0>): u256 {\nB0:\n\t0: MoveLoc[0](Arg0: &Withdrawal<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic withdrawal_split<Ty0: store>(Arg0: &mut Withdrawal<Ty0>, Arg1: u256): Withdrawal<Ty0> {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t2: ReadRef\n\t3: CopyLoc[1](Arg1: u256)\n\t4: Ge\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t8: Pop\n\t9: LdU64(13835339775072075778)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t12: ImmBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t13: ReadRef\n\t14: CopyLoc[1](Arg1: u256)\n\t15: Sub\n\t16: CopyLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t17: MutBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t18: WriteRef\n\t19: MoveLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t20: ImmBorrowFieldGeneric[0](Withdrawal.owner: address)\n\t21: ReadRef\n\t22: MoveLoc[1](Arg1: u256)\n\t23: PackGeneric[0](Withdrawal<Ty0>)\n\t24: Ret\n}\n\npublic withdrawal_join<Ty0: store>(Arg0: &mut Withdrawal<Ty0>, Arg1: Withdrawal<Ty0>) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Withdrawal.owner: address)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: Withdrawal<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](Withdrawal.owner: address)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t10: Pop\n\t11: LdU64(13835621288703623172)\n\t12: Abort\nB3:\n\t13: LdU256(115792089237316195423570985008687907853269984665640564039457584007913129639935)\n\t14: CopyLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t15: ImmBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t16: ReadRef\n\t17: Sub\n\t18: ImmBorrowLoc[1](Arg1: Withdrawal<Ty0>)\n\t19: ImmBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t20: ReadRef\n\t21: Ge\n\t22: BrFalse(24)\nB4:\n\t23: Branch(28)\nB5:\n\t24: MoveLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t25: Pop\n\t26: LdConst[0](u64: 0)\n\t27: Abort\nB6:\n\t28: CopyLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t29: ImmBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t30: ReadRef\n\t31: ImmBorrowLoc[1](Arg1: Withdrawal<Ty0>)\n\t32: ImmBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t33: ReadRef\n\t34: Add\n\t35: MoveLoc[0](Arg0: &mut Withdrawal<Ty0>)\n\t36: MutBorrowFieldGeneric[1](Withdrawal.limit: u256)\n\t37: WriteRef\n\t38: Ret\n}\n\npublic(friend) redeem<Ty0: store>(Arg0: Withdrawal<Ty0>): Ty0 {\nB0:\n\t0: MoveLoc[0](Arg0: Withdrawal<Ty0>)\n\t1: UnpackGeneric[0](Withdrawal<Ty0>)\n\t2: Call withdraw_impl<Ty0>(address, u256): Ty0\n\t3: Ret\n}\n\npublic(friend) withdraw_from_object<Ty0: store>(Arg0: &mut UID, Arg1: u256): Withdrawal<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut UID)\n\t1: FreezeRef\n\t2: Call object::uid_to_address(&UID): address\n\t3: MoveLoc[1](Arg1: u256)\n\t4: PackGeneric[0](Withdrawal<Ty0>)\n\t5: Ret\n}\n\npublic(friend) add_impl<Ty0: store>(Arg0: Ty0, Arg1: address) {\nB0:\n\t0: CopyLoc[1](Arg1: address)\n\t1: Call accumulator::accumulator_address<Ty0>(address): address\n\t2: MoveLoc[1](Arg1: address)\n\t3: MoveLoc[0](Arg0: Ty0)\n\t4: Call add_to_accumulator_address<Ty0>(address, address, Ty0)\n\t5: Ret\n}\n\nwithdraw_impl<Ty0: store>(Arg0: address, Arg1: u256): Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: address)\n\t1: Call accumulator::accumulator_address<Ty0>(address): address\n\t2: MoveLoc[0](Arg0: address)\n\t3: MoveLoc[1](Arg1: u256)\n\t4: Call withdraw_from_accumulator_address<Ty0>(address, address, u256): Ty0\n\t5: Ret\n}\n\nnative add_to_accumulator_address<Ty0: store>(Arg0: address, Arg1: address, Arg2: Ty0);\n\nnative withdraw_from_accumulator_address<Ty0: store>(Arg0: address, Arg1: address, Arg2: u256): Ty0;\n\npublic(friend) create_withdrawal<Ty0: store>(Arg0: address, Arg1: u256): Withdrawal<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: address)\n\t1: MoveLoc[1](Arg1: u256)\n\t2: PackGeneric[0](Withdrawal<Ty0>)\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => vector<u8>: \"EInvalidSubLimit\" // interpreted as UTF8 string\n\t2 => vector<u8>: \"Sub-limit exceeds current withdrawal limit\" // interpreted as UTF8 string\n\t3 => vector<u8>: \"EOwnerMismatch\" // interpreted as UTF8 string\n\t4 => vector<u8>: \"Withdrawal owners do not match\" // interpreted as UTF8 string\n]\n}\n","groth16":"// Move bytecode v6\nmodule 2.groth16 {\n\nstruct Curve has copy, drop, store {\n\tid: u8\n}\n\nstruct PreparedVerifyingKey has copy, drop, store {\n\tvk_gamma_abc_g1_bytes: vector<u8>,\n\talpha_g1_beta_g2_bytes: vector<u8>,\n\tgamma_g2_neg_pc_bytes: vector<u8>,\n\tdelta_g2_neg_pc_bytes: vector<u8>\n}\n\nstruct PublicProofInputs has copy, drop, store {\n\tbytes: vector<u8>\n}\n\nstruct ProofPoints has copy, drop, store {\n\tbytes: vector<u8>\n}\n\npublic bls12381(): Curve {\nB0:\n\t0: LdU8(0)\n\t1: Pack[0](Curve)\n\t2: Ret\n}\n\npublic bn254(): Curve {\nB0:\n\t0: LdU8(1)\n\t1: Pack[0](Curve)\n\t2: Ret\n}\n\npublic pvk_from_bytes(Arg0: vector<u8>, Arg1: vector<u8>, Arg2: vector<u8>, Arg3: vector<u8>): PreparedVerifyingKey {\nB0:\n\t0: MoveLoc[0](Arg0: vector<u8>)\n\t1: MoveLoc[1](Arg1: vector<u8>)\n\t2: MoveLoc[2](Arg2: vector<u8>)\n\t3: MoveLoc[3](Arg3: vector<u8>)\n\t4: Pack[1](PreparedVerifyingKey)\n\t5: Ret\n}\n\npublic pvk_to_bytes(Arg0: PreparedVerifyingKey): vector<vector<u8>> {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: PreparedVerifyingKey)\n\t1: ImmBorrowField[0](PreparedVerifyingKey.vk_gamma_abc_g1_bytes: vector<u8>)\n\t2: ReadRef\n\t3: ImmBorrowLoc[0](Arg0: PreparedVerifyingKey)\n\t4: ImmBorrowField[1](PreparedVerifyingKey.alpha_g1_beta_g2_bytes: vector<u8>)\n\t5: ReadRef\n\t6: ImmBorrowLoc[0](Arg0: PreparedVerifyingKey)\n\t7: ImmBorrowField[2](PreparedVerifyingKey.gamma_g2_neg_pc_bytes: vector<u8>)\n\t8: ReadRef\n\t9: ImmBorrowLoc[0](Arg0: PreparedVerifyingKey)\n\t10: ImmBorrowField[3](PreparedVerifyingKey.delta_g2_neg_pc_bytes: vector<u8>)\n\t11: ReadRef\n\t12: VecPack(5, 4)\n\t13: Ret\n}\n\npublic public_proof_inputs_from_bytes(Arg0: vector<u8>): PublicProofInputs {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t1: VecLen(13)\n\t2: LdU64(32)\n\t3: Mod\n\t4: LdU64(0)\n\t5: Eq\n\t6: BrFalse(8)\nB1:\n\t7: Branch(10)\nB2:\n\t8: LdConst[3](u64: 3)\n\t9: Abort\nB3:\n\t10: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t11: VecLen(13)\n\t12: LdU64(32)\n\t13: Div\n\t14: LdConst[4](u64: 8)\n\t15: Le\n\t16: BrFalse(18)\nB4:\n\t17: Branch(20)\nB5:\n\t18: LdConst[2](u64: 2)\n\t19: Abort\nB6:\n\t20: MoveLoc[0](Arg0: vector<u8>)\n\t21: Pack[2](PublicProofInputs)\n\t22: Ret\n}\n\npublic proof_points_from_bytes(Arg0: vector<u8>): ProofPoints {\nB0:\n\t0: MoveLoc[0](Arg0: vector<u8>)\n\t1: Pack[3](ProofPoints)\n\t2: Ret\n}\n\npublic prepare_verifying_key(Arg0: &Curve, Arg1: &vector<u8>): PreparedVerifyingKey {\nB0:\n\t0: MoveLoc[0](Arg0: &Curve)\n\t1: ImmBorrowField[4](Curve.id: u8)\n\t2: ReadRef\n\t3: MoveLoc[1](Arg1: &vector<u8>)\n\t4: Call prepare_verifying_key_internal(u8, &vector<u8>): PreparedVerifyingKey\n\t5: Ret\n}\n\nnative prepare_verifying_key_internal(Arg0: u8, Arg1: &vector<u8>): PreparedVerifyingKey;\n\npublic verify_groth16_proof(Arg0: &Curve, Arg1: &PreparedVerifyingKey, Arg2: &PublicProofInputs, Arg3: &ProofPoints): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Curve)\n\t1: ImmBorrowField[4](Curve.id: u8)\n\t2: ReadRef\n\t3: CopyLoc[1](Arg1: &PreparedVerifyingKey)\n\t4: ImmBorrowField[0](PreparedVerifyingKey.vk_gamma_abc_g1_bytes: vector<u8>)\n\t5: CopyLoc[1](Arg1: &PreparedVerifyingKey)\n\t6: ImmBorrowField[1](PreparedVerifyingKey.alpha_g1_beta_g2_bytes: vector<u8>)\n\t7: CopyLoc[1](Arg1: &PreparedVerifyingKey)\n\t8: ImmBorrowField[2](PreparedVerifyingKey.gamma_g2_neg_pc_bytes: vector<u8>)\n\t9: MoveLoc[1](Arg1: &PreparedVerifyingKey)\n\t10: ImmBorrowField[3](PreparedVerifyingKey.delta_g2_neg_pc_bytes: vector<u8>)\n\t11: MoveLoc[2](Arg2: &PublicProofInputs)\n\t12: ImmBorrowField[5](PublicProofInputs.bytes: vector<u8>)\n\t13: MoveLoc[3](Arg3: &ProofPoints)\n\t14: ImmBorrowField[6](ProofPoints.bytes: vector<u8>)\n\t15: Call verify_groth16_proof_internal(u8, &vector<u8>, &vector<u8>, &vector<u8>, &vector<u8>, &vector<u8>, &vector<u8>): bool\n\t16: Ret\n}\n\nnative verify_groth16_proof_internal(Arg0: u8, Arg1: &vector<u8>, Arg2: &vector<u8>, Arg3: &vector<u8>, Arg4: &vector<u8>, Arg5: &vector<u8>, Arg6: &vector<u8>): bool;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 8\n]\n}\n","group_ops":"// Move bytecode v6\nmodule 2.group_ops {\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::bcs;\n\nstruct Element<phantom Ty0> has copy, drop, store {\n\tbytes: vector<u8>\n}\n\npublic bytes<Ty0>(Arg0: &Element<Ty0>): &vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &Element<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t2: Ret\n}\n\npublic equal<Ty0>(Arg0: &Element<Ty0>, Arg1: &Element<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Element<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t2: MoveLoc[1](Arg1: &Element<Ty0>)\n\t3: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t4: Eq\n\t5: Ret\n}\n\npublic(friend) from_bytes<Ty0>(Arg0: u8, Arg1: &vector<u8>, Arg2: bool): Element<Ty0> {\nL3:\tloc0: bool\nB0:\n\t0: MoveLoc[2](Arg2: bool)\n\t1: BrFalse(5)\nB1:\n\t2: LdTrue\n\t3: StLoc[3](loc0: bool)\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: u8)\n\t6: CopyLoc[1](Arg1: &vector<u8>)\n\t7: Call internal_validate(u8, &vector<u8>): bool\n\t8: StLoc[3](loc0: bool)\nB3:\n\t9: MoveLoc[3](loc0: bool)\n\t10: BrFalse(12)\nB4:\n\t11: Branch(16)\nB5:\n\t12: MoveLoc[1](Arg1: &vector<u8>)\n\t13: Pop\n\t14: LdConst[1](u64: 1)\n\t15: Abort\nB6:\n\t16: MoveLoc[1](Arg1: &vector<u8>)\n\t17: ReadRef\n\t18: PackGeneric[0](Element<Ty0>)\n\t19: Ret\n}\n\npublic(friend) add<Ty0>(Arg0: u8, Arg1: &Element<Ty0>, Arg2: &Element<Ty0>): Element<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: MoveLoc[1](Arg1: &Element<Ty0>)\n\t2: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t3: MoveLoc[2](Arg2: &Element<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t5: Call internal_add(u8, &vector<u8>, &vector<u8>): vector<u8>\n\t6: PackGeneric[0](Element<Ty0>)\n\t7: Ret\n}\n\npublic(friend) sub<Ty0>(Arg0: u8, Arg1: &Element<Ty0>, Arg2: &Element<Ty0>): Element<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: MoveLoc[1](Arg1: &Element<Ty0>)\n\t2: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t3: MoveLoc[2](Arg2: &Element<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t5: Call internal_sub(u8, &vector<u8>, &vector<u8>): vector<u8>\n\t6: PackGeneric[0](Element<Ty0>)\n\t7: Ret\n}\n\npublic(friend) mul<Ty0, Ty1>(Arg0: u8, Arg1: &Element<Ty0>, Arg2: &Element<Ty1>): Element<Ty1> {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: MoveLoc[1](Arg1: &Element<Ty0>)\n\t2: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t3: MoveLoc[2](Arg2: &Element<Ty1>)\n\t4: ImmBorrowFieldGeneric[1](Element.bytes: vector<u8>)\n\t5: Call internal_mul(u8, &vector<u8>, &vector<u8>): vector<u8>\n\t6: PackGeneric[1](Element<Ty1>)\n\t7: Ret\n}\n\npublic(friend) div<Ty0, Ty1>(Arg0: u8, Arg1: &Element<Ty0>, Arg2: &Element<Ty1>): Element<Ty1> {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: MoveLoc[1](Arg1: &Element<Ty0>)\n\t2: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t3: MoveLoc[2](Arg2: &Element<Ty1>)\n\t4: ImmBorrowFieldGeneric[1](Element.bytes: vector<u8>)\n\t5: Call internal_div(u8, &vector<u8>, &vector<u8>): vector<u8>\n\t6: PackGeneric[1](Element<Ty1>)\n\t7: Ret\n}\n\npublic(friend) hash_to<Ty0>(Arg0: u8, Arg1: &vector<u8>): Element<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: MoveLoc[1](Arg1: &vector<u8>)\n\t2: Call internal_hash_to(u8, &vector<u8>): vector<u8>\n\t3: PackGeneric[0](Element<Ty0>)\n\t4: Ret\n}\n\npublic(friend) multi_scalar_multiplication<Ty0, Ty1>(Arg0: u8, Arg1: &vector<Element<Ty0>>, Arg2: &vector<Element<Ty1>>): Element<Ty1> {\nL3:\tloc0: Element<Ty1>\nL4:\tloc1: vector<u8>\nL5:\tloc2: u64\nL6:\tloc3: Element<Ty0>\nL7:\tloc4: vector<u8>\nB0:\n\t0: CopyLoc[1](Arg1: &vector<Element<Ty0>>)\n\t1: VecLen(5)\n\t2: LdU64(0)\n\t3: Gt\n\t4: BrFalse(6)\nB1:\n\t5: Branch(12)\nB2:\n\t6: MoveLoc[1](Arg1: &vector<Element<Ty0>>)\n\t7: Pop\n\t8: MoveLoc[2](Arg2: &vector<Element<Ty1>>)\n\t9: Pop\n\t10: LdConst[1](u64: 1)\n\t11: Abort\nB3:\n\t12: CopyLoc[1](Arg1: &vector<Element<Ty0>>)\n\t13: VecLen(5)\n\t14: CopyLoc[2](Arg2: &vector<Element<Ty1>>)\n\t15: VecLen(8)\n\t16: Eq\n\t17: BrFalse(19)\nB4:\n\t18: Branch(25)\nB5:\n\t19: MoveLoc[1](Arg1: &vector<Element<Ty0>>)\n\t20: Pop\n\t21: MoveLoc[2](Arg2: &vector<Element<Ty1>>)\n\t22: Pop\n\t23: LdConst[1](u64: 1)\n\t24: Abort\nB6:\n\t25: LdConst[4](vector<u8>: \"\" /..)\n\t26: StLoc[7](loc4: vector<u8>)\n\t27: LdConst[4](vector<u8>: \"\" /..)\n\t28: StLoc[4](loc1: vector<u8>)\n\t29: LdU64(0)\n\t30: StLoc[5](loc2: u64)\nB7:\n\t31: CopyLoc[5](loc2: u64)\n\t32: CopyLoc[1](Arg1: &vector<Element<Ty0>>)\n\t33: VecLen(5)\n\t34: Lt\n\t35: BrFalse(61)\nB8:\n\t36: CopyLoc[1](Arg1: &vector<Element<Ty0>>)\n\t37: CopyLoc[5](loc2: u64)\n\t38: VecImmBorrow(5)\n\t39: ReadRef\n\t40: StLoc[6](loc3: Element<Ty0>)\n\t41: MutBorrowLoc[7](loc4: vector<u8>)\n\t42: ImmBorrowLoc[6](loc3: Element<Ty0>)\n\t43: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t44: ReadRef\n\t45: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\n\t46: CopyLoc[2](Arg2: &vector<Element<Ty1>>)\n\t47: CopyLoc[5](loc2: u64)\n\t48: VecImmBorrow(8)\n\t49: ReadRef\n\t50: StLoc[3](loc0: Element<Ty1>)\n\t51: MutBorrowLoc[4](loc1: vector<u8>)\n\t52: ImmBorrowLoc[3](loc0: Element<Ty1>)\n\t53: ImmBorrowFieldGeneric[1](Element.bytes: vector<u8>)\n\t54: ReadRef\n\t55: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\n\t56: MoveLoc[5](loc2: u64)\n\t57: LdU64(1)\n\t58: Add\n\t59: StLoc[5](loc2: u64)\n\t60: Branch(31)\nB9:\n\t61: MoveLoc[1](Arg1: &vector<Element<Ty0>>)\n\t62: Pop\n\t63: MoveLoc[2](Arg2: &vector<Element<Ty1>>)\n\t64: Pop\n\t65: MoveLoc[0](Arg0: u8)\n\t66: ImmBorrowLoc[7](loc4: vector<u8>)\n\t67: ImmBorrowLoc[4](loc1: vector<u8>)\n\t68: Call internal_multi_scalar_mul(u8, &vector<u8>, &vector<u8>): vector<u8>\n\t69: PackGeneric[1](Element<Ty1>)\n\t70: Ret\n}\n\npublic(friend) pairing<Ty0, Ty1, Ty2>(Arg0: u8, Arg1: &Element<Ty0>, Arg2: &Element<Ty1>): Element<Ty2> {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: MoveLoc[1](Arg1: &Element<Ty0>)\n\t2: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t3: MoveLoc[2](Arg2: &Element<Ty1>)\n\t4: ImmBorrowFieldGeneric[1](Element.bytes: vector<u8>)\n\t5: Call internal_pairing(u8, &vector<u8>, &vector<u8>): vector<u8>\n\t6: PackGeneric[2](Element<Ty2>)\n\t7: Ret\n}\n\npublic(friend) convert<Ty0, Ty1>(Arg0: u8, Arg1: u8, Arg2: &Element<Ty0>): Element<Ty1> {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: MoveLoc[1](Arg1: u8)\n\t2: MoveLoc[2](Arg2: &Element<Ty0>)\n\t3: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t4: Call internal_convert(u8, u8, &vector<u8>): vector<u8>\n\t5: PackGeneric[1](Element<Ty1>)\n\t6: Ret\n}\n\npublic(friend) sum<Ty0>(Arg0: u8, Arg1: &vector<Element<Ty0>>): Element<Ty0> {\nL2:\tloc0: u64\nL3:\tloc1: vector<u8>\nL4:\tloc2: &mut vector<vector<u8>>\nL5:\tloc3: vector<vector<u8>>\nL6:\tloc4: u8\nL7:\tloc5: Element<Ty0>\nL8:\tloc6: u64\nL9:\tloc7: vector<vector<u8>>\nL10:\tloc8: u64\nL11:\tloc9: vector<Element<Ty0>>\nL12:\tloc10: vector<Element<Ty0>>\nL13:\tloc11: Element<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: StLoc[6](loc4: u8)\n\t2: MoveLoc[1](Arg1: &vector<Element<Ty0>>)\n\t3: ReadRef\n\t4: StLoc[11](loc9: vector<Element<Ty0>>)\n\t5: LdConst[5](vector<vector<u8>>: 00)\n\t6: StLoc[9](loc7: vector<vector<u8>>)\n\t7: MoveLoc[11](loc9: vector<Element<Ty0>>)\n\t8: StLoc[12](loc10: vector<Element<Ty0>>)\n\t9: MutBorrowLoc[12](loc10: vector<Element<Ty0>>)\n\t10: Call vector::reverse<Element<Ty0>>(&mut vector<Element<Ty0>>)\n\t11: ImmBorrowLoc[12](loc10: vector<Element<Ty0>>)\n\t12: VecLen(5)\n\t13: StLoc[2](loc0: u64)\n\t14: LdU64(0)\n\t15: StLoc[8](loc6: u64)\n\t16: MoveLoc[2](loc0: u64)\n\t17: StLoc[10](loc8: u64)\nB1:\n\t18: CopyLoc[8](loc6: u64)\n\t19: CopyLoc[10](loc8: u64)\n\t20: Lt\n\t21: BrFalse(43)\nB2:\n\t22: CopyLoc[8](loc6: u64)\n\t23: Pop\n\t24: MutBorrowLoc[12](loc10: vector<Element<Ty0>>)\n\t25: VecPopBack(5)\n\t26: StLoc[7](loc5: Element<Ty0>)\n\t27: MutBorrowLoc[9](loc7: vector<vector<u8>>)\n\t28: StLoc[4](loc2: &mut vector<vector<u8>>)\n\t29: MoveLoc[7](loc5: Element<Ty0>)\n\t30: StLoc[13](loc11: Element<Ty0>)\n\t31: ImmBorrowLoc[13](loc11: Element<Ty0>)\n\t32: ImmBorrowFieldGeneric[0](Element.bytes: vector<u8>)\n\t33: ReadRef\n\t34: StLoc[3](loc1: vector<u8>)\n\t35: MoveLoc[4](loc2: &mut vector<vector<u8>>)\n\t36: MoveLoc[3](loc1: vector<u8>)\n\t37: VecPushBack(15)\n\t38: MoveLoc[8](loc6: u64)\n\t39: LdU64(1)\n\t40: Add\n\t41: StLoc[8](loc6: u64)\n\t42: Branch(18)\nB3:\n\t43: MoveLoc[12](loc10: vector<Element<Ty0>>)\n\t44: VecUnpack(5, 0)\n\t45: MoveLoc[9](loc7: vector<vector<u8>>)\n\t46: StLoc[5](loc3: vector<vector<u8>>)\n\t47: MoveLoc[6](loc4: u8)\n\t48: ImmBorrowLoc[5](loc3: vector<vector<u8>>)\n\t49: Call internal_sum(u8, &vector<vector<u8>>): vector<u8>\n\t50: PackGeneric[0](Element<Ty0>)\n\t51: Ret\n}\n\nnative internal_validate(Arg0: u8, Arg1: &vector<u8>): bool;\n\nnative internal_add(Arg0: u8, Arg1: &vector<u8>, Arg2: &vector<u8>): vector<u8>;\n\nnative internal_sub(Arg0: u8, Arg1: &vector<u8>, Arg2: &vector<u8>): vector<u8>;\n\nnative internal_mul(Arg0: u8, Arg1: &vector<u8>, Arg2: &vector<u8>): vector<u8>;\n\nnative internal_div(Arg0: u8, Arg1: &vector<u8>, Arg2: &vector<u8>): vector<u8>;\n\nnative internal_hash_to(Arg0: u8, Arg1: &vector<u8>): vector<u8>;\n\nnative internal_multi_scalar_mul(Arg0: u8, Arg1: &vector<u8>, Arg2: &vector<u8>): vector<u8>;\n\nnative internal_pairing(Arg0: u8, Arg1: &vector<u8>, Arg2: &vector<u8>): vector<u8>;\n\nnative internal_convert(Arg0: u8, Arg1: u8, Arg2: &vector<u8>): vector<u8>;\n\nnative internal_sum(Arg0: u8, Arg1: &vector<vector<u8>>): vector<u8>;\n\npublic(friend) set_as_prefix(Arg0: u64, Arg1: bool, Arg2: &mut vector<u8>) {\nL3:\tloc0: u64\nL4:\tloc1: u64\nL5:\tloc2: u64\nL6:\tloc3: u64\nL7:\tloc4: vector<u8>\nB0:\n\t0: CopyLoc[2](Arg2: &mut vector<u8>)\n\t1: FreezeRef\n\t2: VecLen(23)\n\t3: StLoc[4](loc1: u64)\n\t4: CopyLoc[4](loc1: u64)\n\t5: LdU64(7)\n\t6: Gt\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[2](Arg2: &mut vector<u8>)\n\t10: Pop\n\t11: LdConst[3](u64: 3)\n\t12: Abort\nB3:\n\t13: ImmBorrowLoc[0](Arg0: u64)\n\t14: Call bcs::to_bytes<u64>(&u64): vector<u8>\n\t15: StLoc[7](loc4: vector<u8>)\n\t16: LdU64(0)\n\t17: StLoc[5](loc2: u64)\nB4:\n\t18: CopyLoc[5](loc2: u64)\n\t19: LdU64(8)\n\t20: Lt\n\t21: BrFalse(49)\nB5:\n\t22: CopyLoc[1](Arg1: bool)\n\t23: BrFalse(32)\nB6:\n\t24: Branch(25)\nB7:\n\t25: CopyLoc[4](loc1: u64)\n\t26: CopyLoc[5](loc2: u64)\n\t27: Sub\n\t28: LdU64(1)\n\t29: Sub\n\t30: StLoc[3](loc0: u64)\n\t31: Branch(34)\nB8:\n\t32: CopyLoc[5](loc2: u64)\n\t33: StLoc[3](loc0: u64)\nB9:\n\t34: MoveLoc[3](loc0: u64)\n\t35: StLoc[6](loc3: u64)\n\t36: ImmBorrowLoc[7](loc4: vector<u8>)\n\t37: CopyLoc[5](loc2: u64)\n\t38: VecImmBorrow(23)\n\t39: ReadRef\n\t40: CopyLoc[2](Arg2: &mut vector<u8>)\n\t41: MoveLoc[6](loc3: u64)\n\t42: VecMutBorrow(23)\n\t43: WriteRef\n\t44: MoveLoc[5](loc2: u64)\n\t45: LdU64(1)\n\t46: Add\n\t47: StLoc[5](loc2: u64)\n\t48: Branch(18)\nB10:\n\t49: MoveLoc[2](Arg2: &mut vector<u8>)\n\t50: Pop\n\t51: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => vector<u8>: \"\" // interpreted as UTF8 string\n\t5 => vector<vector<u8>>: 00\n]\n}\n","hash":"// Move bytecode v6\nmodule 2.hash {\n\nnative public blake2b256(Arg0: &vector<u8>): vector<u8>;\n\nnative public keccak256(Arg0: &vector<u8>): vector<u8>;\n\n}\n","hex":"// Move bytecode v6\nmodule 2.hex {\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\n\npublic encode(Arg0: vector<u8>): vector<u8> {\nL1:\tloc0: vector<vector<u8>>\nL2:\tloc1: u64\nL3:\tloc2: u64\nL4:\tloc3: vector<u8>\nB0:\n\t0: LdU64(0)\n\t1: LdConst[3](vector<u8>: \"\" /..)\n\t2: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t3: VecLen(1)\n\t4: StLoc[3](loc2: u64)\n\t5: StLoc[4](loc3: vector<u8>)\n\t6: StLoc[2](loc1: u64)\n\t7: LdConst[2](vector<vector<u8>>: 8002..)\n\t8: StLoc[1](loc0: vector<vector<u8>>)\nB1:\n\t9: CopyLoc[2](loc1: u64)\n\t10: CopyLoc[3](loc2: u64)\n\t11: Lt\n\t12: BrFalse(29)\nB2:\n\t13: Branch(14)\nB3:\n\t14: MutBorrowLoc[4](loc3: vector<u8>)\n\t15: ImmBorrowLoc[1](loc0: vector<vector<u8>>)\n\t16: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t17: CopyLoc[2](loc1: u64)\n\t18: VecImmBorrow(1)\n\t19: ReadRef\n\t20: CastU64\n\t21: VecImmBorrow(0)\n\t22: ReadRef\n\t23: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\n\t24: MoveLoc[2](loc1: u64)\n\t25: LdU64(1)\n\t26: Add\n\t27: StLoc[2](loc1: u64)\n\t28: Branch(9)\nB4:\n\t29: MoveLoc[4](loc3: vector<u8>)\n\t30: Ret\n}\n\npublic decode(Arg0: vector<u8>): vector<u8> {\nL1:\tloc0: u8\nL2:\tloc1: u64\nL3:\tloc2: u64\nL4:\tloc3: vector<u8>\nB0:\n\t0: LdU64(0)\n\t1: LdConst[3](vector<u8>: \"\" /..)\n\t2: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t3: VecLen(1)\n\t4: StLoc[3](loc2: u64)\n\t5: StLoc[4](loc3: vector<u8>)\n\t6: StLoc[2](loc1: u64)\n\t7: CopyLoc[3](loc2: u64)\n\t8: LdU64(2)\n\t9: Mod\n\t10: LdU64(0)\n\t11: Eq\n\t12: BrFalse(14)\nB1:\n\t13: Branch(16)\nB2:\n\t14: LdConst[0](u64: 0)\n\t15: Abort\nB3:\n\t16: CopyLoc[2](loc1: u64)\n\t17: CopyLoc[3](loc2: u64)\n\t18: Lt\n\t19: BrFalse(44)\nB4:\n\t20: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t21: CopyLoc[2](loc1: u64)\n\t22: VecImmBorrow(1)\n\t23: ReadRef\n\t24: Call decode_byte(u8): u8\n\t25: LdU8(16)\n\t26: Mul\n\t27: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t28: CopyLoc[2](loc1: u64)\n\t29: LdU64(1)\n\t30: Add\n\t31: VecImmBorrow(1)\n\t32: ReadRef\n\t33: Call decode_byte(u8): u8\n\t34: Add\n\t35: StLoc[1](loc0: u8)\n\t36: MutBorrowLoc[4](loc3: vector<u8>)\n\t37: MoveLoc[1](loc0: u8)\n\t38: VecPushBack(1)\n\t39: MoveLoc[2](loc1: u64)\n\t40: LdU64(2)\n\t41: Add\n\t42: StLoc[2](loc1: u64)\n\t43: Branch(16)\nB5:\n\t44: MoveLoc[4](loc3: vector<u8>)\n\t45: Ret\n}\n\ndecode_byte(Arg0: u8): u8 {\nL1:\tloc0: bool\nL2:\tloc1: bool\nL3:\tloc2: bool\nL4:\tloc3: u8\nL5:\tloc4: u8\nB0:\n\t0: LdU8(48)\n\t1: CopyLoc[0](Arg0: u8)\n\t2: Le\n\t3: BrFalse(9)\nB1:\n\t4: CopyLoc[0](Arg0: u8)\n\t5: LdU8(58)\n\t6: Lt\n\t7: StLoc[1](loc0: bool)\n\t8: Branch(11)\nB2:\n\t9: LdFalse\n\t10: StLoc[1](loc0: bool)\nB3:\n\t11: MoveLoc[1](loc0: bool)\n\t12: BrFalse(18)\nB4:\n\t13: MoveLoc[0](Arg0: u8)\n\t14: LdU8(48)\n\t15: Sub\n\t16: StLoc[5](loc4: u8)\n\t17: Branch(62)\nB5:\n\t18: LdU8(65)\n\t19: CopyLoc[0](Arg0: u8)\n\t20: Le\n\t21: BrFalse(27)\nB6:\n\t22: CopyLoc[0](Arg0: u8)\n\t23: LdU8(71)\n\t24: Lt\n\t25: StLoc[2](loc1: bool)\n\t26: Branch(29)\nB7:\n\t27: LdFalse\n\t28: StLoc[2](loc1: bool)\nB8:\n\t29: MoveLoc[2](loc1: bool)\n\t30: BrFalse(38)\nB9:\n\t31: LdU8(10)\n\t32: MoveLoc[0](Arg0: u8)\n\t33: Add\n\t34: LdU8(65)\n\t35: Sub\n\t36: StLoc[4](loc3: u8)\n\t37: Branch(60)\nB10:\n\t38: LdU8(97)\n\t39: CopyLoc[0](Arg0: u8)\n\t40: Le\n\t41: BrFalse(47)\nB11:\n\t42: CopyLoc[0](Arg0: u8)\n\t43: LdU8(103)\n\t44: Lt\n\t45: StLoc[3](loc2: bool)\n\t46: Branch(49)\nB12:\n\t47: LdFalse\n\t48: StLoc[3](loc2: bool)\nB13:\n\t49: MoveLoc[3](loc2: bool)\n\t50: BrFalse(52)\nB14:\n\t51: Branch(54)\nB15:\n\t52: LdConst[1](u64: 1)\n\t53: Abort\nB16:\n\t54: LdU8(10)\n\t55: MoveLoc[0](Arg0: u8)\n\t56: Add\n\t57: LdU8(97)\n\t58: Sub\n\t59: StLoc[4](loc3: u8)\nB17:\n\t60: MoveLoc[4](loc3: u8)\n\t61: StLoc[5](loc4: u8)\nB18:\n\t62: MoveLoc[5](loc4: u8)\n\t63: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => vector<vector<u8>>: 8002023030023031023032023033023034023035023036023037023038023039023061023062023063023064023065023066023130023131023132023133023134023135023136023137023138023139023161023162023163023164023165023166023230023231023232023233023234023235023236023237023238023239023261023262023263023264023265023266023330023331023332023333023334023335023336023337023338023339023361023362023363023364023365023366023430023431023432023433023434023435023436023437023438023439023461023462023463023464023465023466023530023531023532023533023534023535023536023537023538023539023561023562023563023564023565023566023630023631023632023633023634023635023636023637023638023639023661023662023663023664023665023666023730023731023732023733023734023735023736023737023738023739023761023762023763023764023765023766023830023831023832023833023834023835023836023837023838023839023861023862023863023864023865023866023930023931023932023933023934023935023936023937023938023939023961023962023963023964023965023966026130026131026132026133026134026135026136026137026138026139026161026162026163026164026165026166026230026231026232026233026234026235026236026237026238026239026261026262026263026264026265026266026330026331026332026333026334026335026336026337026338026339026361026362026363026364026365026366026430026431026432026433026434026435026436026437026438026439026461026462026463026464026465026466026530026531026532026533026534026535026536026537026538026539026561026562026563026564026565026566026630026631026632026633026634026635026636026637026638026639026661026662026663026664026665026666\n\t3 => vector<u8>: \"\" // interpreted as UTF8 string\n]\n}\n","hmac":"// Move bytecode v6\nmodule 2.hmac {\n\nnative public hmac_sha3_256(Arg0: &vector<u8>, Arg1: &vector<u8>): vector<u8>;\n\n}\n","kiosk":"// Move bytecode v6\nmodule 2.kiosk {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_object_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::sui;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer_policy;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Kiosk has store, key {\n\tid: UID,\n\tprofits: Balance<SUI>,\n\towner: address,\n\titem_count: u32,\n\tallow_extensions: bool\n}\n\nstruct KioskOwnerCap has store, key {\n\tid: UID,\n\tfor: ID\n}\n\nstruct PurchaseCap<phantom Ty0: store + key> has store, key {\n\tid: UID,\n\tkiosk_id: ID,\n\titem_id: ID,\n\tmin_price: u64\n}\n\nstruct Borrow {\n\tkiosk_id: ID,\n\titem_id: ID\n}\n\nstruct Item has copy, drop, store {\n\tid: ID\n}\n\nstruct Listing has copy, drop, store {\n\tid: ID,\n\tis_exclusive: bool\n}\n\nstruct Lock has copy, drop, store {\n\tid: ID\n}\n\nstruct ItemListed<phantom Ty0: store + key> has copy, drop {\n\tkiosk: ID,\n\tid: ID,\n\tprice: u64\n}\n\nstruct ItemPurchased<phantom Ty0: store + key> has copy, drop {\n\tkiosk: ID,\n\tid: ID,\n\tprice: u64\n}\n\nstruct ItemDelisted<phantom Ty0: store + key> has copy, drop {\n\tkiosk: ID,\n\tid: ID\n}\n\nentry default(Arg0: &mut TxContext) {\nL1:\tloc0: KioskOwnerCap\nL2:\tloc1: Kiosk\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: Call new(&mut TxContext): Kiosk * KioskOwnerCap\n\t2: StLoc[1](loc0: KioskOwnerCap)\n\t3: StLoc[2](loc1: Kiosk)\n\t4: MoveLoc[1](loc0: KioskOwnerCap)\n\t5: MoveLoc[0](Arg0: &mut TxContext)\n\t6: FreezeRef\n\t7: Call tx_context::sender(&TxContext): address\n\t8: Call transfer::transfer<KioskOwnerCap>(KioskOwnerCap, address)\n\t9: MoveLoc[2](loc1: Kiosk)\n\t10: Call transfer::share_object<Kiosk>(Kiosk)\n\t11: Ret\n}\n\npublic new(Arg0: &mut TxContext): Kiosk * KioskOwnerCap {\nL1:\tloc0: KioskOwnerCap\nL2:\tloc1: Kiosk\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: Call balance::zero<SUI>(): Balance<SUI>\n\t3: CopyLoc[0](Arg0: &mut TxContext)\n\t4: FreezeRef\n\t5: Call tx_context::sender(&TxContext): address\n\t6: LdU32(0)\n\t7: LdFalse\n\t8: Pack[0](Kiosk)\n\t9: StLoc[2](loc1: Kiosk)\n\t10: MoveLoc[0](Arg0: &mut TxContext)\n\t11: Call object::new(&mut TxContext): UID\n\t12: ImmBorrowLoc[2](loc1: Kiosk)\n\t13: Call object::id<Kiosk>(&Kiosk): ID\n\t14: Pack[1](KioskOwnerCap)\n\t15: StLoc[1](loc0: KioskOwnerCap)\n\t16: MoveLoc[2](loc1: Kiosk)\n\t17: MoveLoc[1](loc0: KioskOwnerCap)\n\t18: Ret\n}\n\npublic close_and_withdraw(Arg0: Kiosk, Arg1: KioskOwnerCap, Arg2: &mut TxContext): Coin<SUI> {\nL3:\tloc0: UID\nL4:\tloc1: ID\nL5:\tloc2: UID\nL6:\tloc3: u32\nL7:\tloc4: Balance<SUI>\nB0:\n\t0: MoveLoc[0](Arg0: Kiosk)\n\t1: Unpack[0](Kiosk)\n\t2: Pop\n\t3: StLoc[6](loc3: u32)\n\t4: Pop\n\t5: StLoc[7](loc4: Balance<SUI>)\n\t6: StLoc[5](loc2: UID)\n\t7: MoveLoc[1](Arg1: KioskOwnerCap)\n\t8: Unpack[1](KioskOwnerCap)\n\t9: StLoc[4](loc1: ID)\n\t10: StLoc[3](loc0: UID)\n\t11: ImmBorrowLoc[5](loc2: UID)\n\t12: Call object::uid_to_inner(&UID): ID\n\t13: MoveLoc[4](loc1: ID)\n\t14: Eq\n\t15: BrFalse(17)\nB1:\n\t16: Branch(21)\nB2:\n\t17: MoveLoc[2](Arg2: &mut TxContext)\n\t18: Pop\n\t19: LdConst[0](u64: 0)\n\t20: Abort\nB3:\n\t21: MoveLoc[6](loc3: u32)\n\t22: LdU32(0)\n\t23: Eq\n\t24: BrFalse(26)\nB4:\n\t25: Branch(30)\nB5:\n\t26: MoveLoc[2](Arg2: &mut TxContext)\n\t27: Pop\n\t28: LdConst[3](u64: 3)\n\t29: Abort\nB6:\n\t30: MoveLoc[3](loc0: UID)\n\t31: Call object::delete(UID)\n\t32: MoveLoc[5](loc2: UID)\n\t33: Call object::delete(UID)\n\t34: MoveLoc[7](loc4: Balance<SUI>)\n\t35: MoveLoc[2](Arg2: &mut TxContext)\n\t36: Call coin::from_balance<SUI>(Balance<SUI>, &mut TxContext): Coin<SUI>\n\t37: Ret\n}\n\npublic set_owner(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: &TxContext) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: MoveLoc[2](Arg2: &TxContext)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[2](Arg2: &TxContext)\n\t12: Call tx_context::sender(&TxContext): address\n\t13: MoveLoc[0](Arg0: &mut Kiosk)\n\t14: MutBorrowField[0](Kiosk.owner: address)\n\t15: WriteRef\n\t16: Ret\n}\n\npublic set_owner_custom(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: address) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: MoveLoc[2](Arg2: address)\n\t10: MoveLoc[0](Arg0: &mut Kiosk)\n\t11: MutBorrowField[0](Kiosk.owner: address)\n\t12: WriteRef\n\t13: Ret\n}\n\npublic place<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: Ty0) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: MoveLoc[0](Arg0: &mut Kiosk)\n\t10: MoveLoc[2](Arg2: Ty0)\n\t11: Call place_internal<Ty0>(&mut Kiosk, Ty0)\n\t12: Ret\n}\n\npublic lock<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: &TransferPolicy<Ty0>, Arg3: Ty0) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: MoveLoc[0](Arg0: &mut Kiosk)\n\t10: MoveLoc[3](Arg3: Ty0)\n\t11: Call lock_internal<Ty0>(&mut Kiosk, Ty0)\n\t12: Ret\n}\n\npublic take<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: ID): Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut Kiosk)\n\t10: FreezeRef\n\t11: CopyLoc[2](Arg2: ID)\n\t12: Call is_locked(&Kiosk, ID): bool\n\t13: Not\n\t14: BrFalse(16)\nB4:\n\t15: Branch(20)\nB5:\n\t16: MoveLoc[0](Arg0: &mut Kiosk)\n\t17: Pop\n\t18: LdConst[8](u64: 8)\n\t19: Abort\nB6:\n\t20: CopyLoc[0](Arg0: &mut Kiosk)\n\t21: FreezeRef\n\t22: CopyLoc[2](Arg2: ID)\n\t23: Call is_listed_exclusively(&Kiosk, ID): bool\n\t24: Not\n\t25: BrFalse(27)\nB7:\n\t26: Branch(31)\nB8:\n\t27: MoveLoc[0](Arg0: &mut Kiosk)\n\t28: Pop\n\t29: LdConst[4](u64: 4)\n\t30: Abort\nB9:\n\t31: CopyLoc[0](Arg0: &mut Kiosk)\n\t32: FreezeRef\n\t33: CopyLoc[2](Arg2: ID)\n\t34: Call has_item(&Kiosk, ID): bool\n\t35: BrFalse(37)\nB10:\n\t36: Branch(41)\nB11:\n\t37: MoveLoc[0](Arg0: &mut Kiosk)\n\t38: Pop\n\t39: LdConst[11](u64: 11)\n\t40: Abort\nB12:\n\t41: CopyLoc[0](Arg0: &mut Kiosk)\n\t42: ImmBorrowField[1](Kiosk.item_count: u32)\n\t43: ReadRef\n\t44: LdU32(1)\n\t45: Sub\n\t46: CopyLoc[0](Arg0: &mut Kiosk)\n\t47: MutBorrowField[1](Kiosk.item_count: u32)\n\t48: WriteRef\n\t49: CopyLoc[0](Arg0: &mut Kiosk)\n\t50: MutBorrowField[2](Kiosk.id: UID)\n\t51: CopyLoc[2](Arg2: ID)\n\t52: LdFalse\n\t53: Pack[5](Listing)\n\t54: Call dynamic_field::remove_if_exists<Listing, u64>(&mut UID, Listing): Option<u64>\n\t55: Pop\n\t56: MoveLoc[0](Arg0: &mut Kiosk)\n\t57: MutBorrowField[2](Kiosk.id: UID)\n\t58: MoveLoc[2](Arg2: ID)\n\t59: Pack[4](Item)\n\t60: Call dynamic_object_field::remove<Item, Ty0>(&mut UID, Item): Ty0\n\t61: Ret\n}\n\npublic list<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: ID, Arg3: u64) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut Kiosk)\n\t10: FreezeRef\n\t11: CopyLoc[2](Arg2: ID)\n\t12: Call has_item_with_type<Ty0>(&Kiosk, ID): bool\n\t13: BrFalse(15)\nB4:\n\t14: Branch(19)\nB5:\n\t15: MoveLoc[0](Arg0: &mut Kiosk)\n\t16: Pop\n\t17: LdConst[11](u64: 11)\n\t18: Abort\nB6:\n\t19: CopyLoc[0](Arg0: &mut Kiosk)\n\t20: FreezeRef\n\t21: CopyLoc[2](Arg2: ID)\n\t22: Call is_listed_exclusively(&Kiosk, ID): bool\n\t23: Not\n\t24: BrFalse(26)\nB7:\n\t25: Branch(30)\nB8:\n\t26: MoveLoc[0](Arg0: &mut Kiosk)\n\t27: Pop\n\t28: LdConst[4](u64: 4)\n\t29: Abort\nB9:\n\t30: CopyLoc[0](Arg0: &mut Kiosk)\n\t31: MutBorrowField[2](Kiosk.id: UID)\n\t32: CopyLoc[2](Arg2: ID)\n\t33: LdFalse\n\t34: Pack[5](Listing)\n\t35: CopyLoc[3](Arg3: u64)\n\t36: Call dynamic_field::add<Listing, u64>(&mut UID, Listing, u64)\n\t37: MoveLoc[0](Arg0: &mut Kiosk)\n\t38: FreezeRef\n\t39: Call object::id<Kiosk>(&Kiosk): ID\n\t40: MoveLoc[2](Arg2: ID)\n\t41: MoveLoc[3](Arg3: u64)\n\t42: PackGeneric[0](ItemListed<Ty0>)\n\t43: Call event::emit<ItemListed<Ty0>>(ItemListed<Ty0>)\n\t44: Ret\n}\n\npublic place_and_list<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: Ty0, Arg3: u64) {\nL4:\tloc0: ID\nB0:\n\t0: ImmBorrowLoc[2](Arg2: Ty0)\n\t1: Call object::id<Ty0>(&Ty0): ID\n\t2: StLoc[4](loc0: ID)\n\t3: CopyLoc[0](Arg0: &mut Kiosk)\n\t4: CopyLoc[1](Arg1: &KioskOwnerCap)\n\t5: MoveLoc[2](Arg2: Ty0)\n\t6: Call place<Ty0>(&mut Kiosk, &KioskOwnerCap, Ty0)\n\t7: MoveLoc[0](Arg0: &mut Kiosk)\n\t8: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t9: MoveLoc[4](loc0: ID)\n\t10: MoveLoc[3](Arg3: u64)\n\t11: Call list<Ty0>(&mut Kiosk, &KioskOwnerCap, ID, u64)\n\t12: Ret\n}\n\npublic delist<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: ID) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut Kiosk)\n\t10: FreezeRef\n\t11: CopyLoc[2](Arg2: ID)\n\t12: Call has_item_with_type<Ty0>(&Kiosk, ID): bool\n\t13: BrFalse(15)\nB4:\n\t14: Branch(19)\nB5:\n\t15: MoveLoc[0](Arg0: &mut Kiosk)\n\t16: Pop\n\t17: LdConst[11](u64: 11)\n\t18: Abort\nB6:\n\t19: CopyLoc[0](Arg0: &mut Kiosk)\n\t20: FreezeRef\n\t21: CopyLoc[2](Arg2: ID)\n\t22: Call is_listed_exclusively(&Kiosk, ID): bool\n\t23: Not\n\t24: BrFalse(26)\nB7:\n\t25: Branch(30)\nB8:\n\t26: MoveLoc[0](Arg0: &mut Kiosk)\n\t27: Pop\n\t28: LdConst[4](u64: 4)\n\t29: Abort\nB9:\n\t30: CopyLoc[0](Arg0: &mut Kiosk)\n\t31: FreezeRef\n\t32: CopyLoc[2](Arg2: ID)\n\t33: Call is_listed(&Kiosk, ID): bool\n\t34: BrFalse(36)\nB10:\n\t35: Branch(40)\nB11:\n\t36: MoveLoc[0](Arg0: &mut Kiosk)\n\t37: Pop\n\t38: LdConst[12](u64: 12)\n\t39: Abort\nB12:\n\t40: CopyLoc[0](Arg0: &mut Kiosk)\n\t41: MutBorrowField[2](Kiosk.id: UID)\n\t42: CopyLoc[2](Arg2: ID)\n\t43: LdFalse\n\t44: Pack[5](Listing)\n\t45: Call dynamic_field::remove<Listing, u64>(&mut UID, Listing): u64\n\t46: Pop\n\t47: MoveLoc[0](Arg0: &mut Kiosk)\n\t48: FreezeRef\n\t49: Call object::id<Kiosk>(&Kiosk): ID\n\t50: MoveLoc[2](Arg2: ID)\n\t51: PackGeneric[1](ItemDelisted<Ty0>)\n\t52: Call event::emit<ItemDelisted<Ty0>>(ItemDelisted<Ty0>)\n\t53: Ret\n}\n\npublic purchase<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: ID, Arg2: Coin<SUI>): Ty0 * TransferRequest<Ty0> {\nL3:\tloc0: Ty0\nL4:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MutBorrowField[2](Kiosk.id: UID)\n\t2: CopyLoc[1](Arg1: ID)\n\t3: LdFalse\n\t4: Pack[5](Listing)\n\t5: Call dynamic_field::remove<Listing, u64>(&mut UID, Listing): u64\n\t6: StLoc[4](loc1: u64)\n\t7: CopyLoc[0](Arg0: &mut Kiosk)\n\t8: MutBorrowField[2](Kiosk.id: UID)\n\t9: CopyLoc[1](Arg1: ID)\n\t10: Pack[4](Item)\n\t11: Call dynamic_object_field::remove<Item, Ty0>(&mut UID, Item): Ty0\n\t12: StLoc[3](loc0: Ty0)\n\t13: CopyLoc[0](Arg0: &mut Kiosk)\n\t14: ImmBorrowField[1](Kiosk.item_count: u32)\n\t15: ReadRef\n\t16: LdU32(1)\n\t17: Sub\n\t18: CopyLoc[0](Arg0: &mut Kiosk)\n\t19: MutBorrowField[1](Kiosk.item_count: u32)\n\t20: WriteRef\n\t21: CopyLoc[4](loc1: u64)\n\t22: ImmBorrowLoc[2](Arg2: Coin<SUI>)\n\t23: Call coin::value<SUI>(&Coin<SUI>): u64\n\t24: Eq\n\t25: BrFalse(27)\nB1:\n\t26: Branch(31)\nB2:\n\t27: MoveLoc[0](Arg0: &mut Kiosk)\n\t28: Pop\n\t29: LdConst[1](u64: 1)\n\t30: Abort\nB3:\n\t31: CopyLoc[0](Arg0: &mut Kiosk)\n\t32: MutBorrowField[2](Kiosk.id: UID)\n\t33: CopyLoc[1](Arg1: ID)\n\t34: Pack[6](Lock)\n\t35: Call dynamic_field::remove_if_exists<Lock, bool>(&mut UID, Lock): Option<bool>\n\t36: Pop\n\t37: CopyLoc[0](Arg0: &mut Kiosk)\n\t38: MutBorrowField[3](Kiosk.profits: Balance<SUI>)\n\t39: MoveLoc[2](Arg2: Coin<SUI>)\n\t40: Call coin::put<SUI>(&mut Balance<SUI>, Coin<SUI>)\n\t41: CopyLoc[0](Arg0: &mut Kiosk)\n\t42: FreezeRef\n\t43: Call object::id<Kiosk>(&Kiosk): ID\n\t44: CopyLoc[1](Arg1: ID)\n\t45: CopyLoc[4](loc1: u64)\n\t46: PackGeneric[2](ItemPurchased<Ty0>)\n\t47: Call event::emit<ItemPurchased<Ty0>>(ItemPurchased<Ty0>)\n\t48: MoveLoc[3](loc0: Ty0)\n\t49: MoveLoc[1](Arg1: ID)\n\t50: MoveLoc[4](loc1: u64)\n\t51: MoveLoc[0](Arg0: &mut Kiosk)\n\t52: FreezeRef\n\t53: Call object::id<Kiosk>(&Kiosk): ID\n\t54: Call transfer_policy::new_request<Ty0>(ID, u64, ID): TransferRequest<Ty0>\n\t55: Ret\n}\n\npublic list_with_purchase_cap<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: ID, Arg3: u64, Arg4: &mut TxContext): PurchaseCap<Ty0> {\nL5:\tloc0: u64\nL6:\tloc1: ID\nL7:\tloc2: UID\nL8:\tloc3: ID\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: MoveLoc[4](Arg4: &mut TxContext)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut Kiosk)\n\t12: FreezeRef\n\t13: CopyLoc[2](Arg2: ID)\n\t14: Call has_item_with_type<Ty0>(&Kiosk, ID): bool\n\t15: BrFalse(17)\nB4:\n\t16: Branch(23)\nB5:\n\t17: MoveLoc[0](Arg0: &mut Kiosk)\n\t18: Pop\n\t19: MoveLoc[4](Arg4: &mut TxContext)\n\t20: Pop\n\t21: LdConst[11](u64: 11)\n\t22: Abort\nB6:\n\t23: CopyLoc[0](Arg0: &mut Kiosk)\n\t24: FreezeRef\n\t25: CopyLoc[2](Arg2: ID)\n\t26: Call is_listed(&Kiosk, ID): bool\n\t27: Not\n\t28: BrFalse(30)\nB7:\n\t29: Branch(36)\nB8:\n\t30: MoveLoc[0](Arg0: &mut Kiosk)\n\t31: Pop\n\t32: MoveLoc[4](Arg4: &mut TxContext)\n\t33: Pop\n\t34: LdConst[6](u64: 6)\n\t35: Abort\nB9:\n\t36: CopyLoc[0](Arg0: &mut Kiosk)\n\t37: MutBorrowField[2](Kiosk.id: UID)\n\t38: CopyLoc[2](Arg2: ID)\n\t39: LdTrue\n\t40: Pack[5](Listing)\n\t41: CopyLoc[3](Arg3: u64)\n\t42: Call dynamic_field::add<Listing, u64>(&mut UID, Listing, u64)\n\t43: MoveLoc[3](Arg3: u64)\n\t44: StLoc[5](loc0: u64)\n\t45: MoveLoc[2](Arg2: ID)\n\t46: StLoc[6](loc1: ID)\n\t47: MoveLoc[4](Arg4: &mut TxContext)\n\t48: Call object::new(&mut TxContext): UID\n\t49: StLoc[7](loc2: UID)\n\t50: MoveLoc[0](Arg0: &mut Kiosk)\n\t51: FreezeRef\n\t52: Call object::id<Kiosk>(&Kiosk): ID\n\t53: StLoc[8](loc3: ID)\n\t54: MoveLoc[7](loc2: UID)\n\t55: MoveLoc[8](loc3: ID)\n\t56: MoveLoc[6](loc1: ID)\n\t57: MoveLoc[5](loc0: u64)\n\t58: PackGeneric[3](PurchaseCap<Ty0>)\n\t59: Ret\n}\n\npublic purchase_with_cap<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: PurchaseCap<Ty0>, Arg2: Coin<SUI>): Ty0 * TransferRequest<Ty0> {\nL3:\tloc0: ID\nL4:\tloc1: ID\nL5:\tloc2: ID\nL6:\tloc3: u64\nL7:\tloc4: u64\nB0:\n\t0: MoveLoc[1](Arg1: PurchaseCap<Ty0>)\n\t1: UnpackGeneric[3](PurchaseCap<Ty0>)\n\t2: StLoc[6](loc3: u64)\n\t3: StLoc[4](loc1: ID)\n\t4: StLoc[5](loc2: ID)\n\t5: Call object::delete(UID)\n\t6: MoveLoc[4](loc1: ID)\n\t7: StLoc[3](loc0: ID)\n\t8: ImmBorrowLoc[2](Arg2: Coin<SUI>)\n\t9: Call coin::value<SUI>(&Coin<SUI>): u64\n\t10: StLoc[7](loc4: u64)\n\t11: CopyLoc[7](loc4: u64)\n\t12: MoveLoc[6](loc3: u64)\n\t13: Ge\n\t14: BrFalse(16)\nB1:\n\t15: Branch(20)\nB2:\n\t16: MoveLoc[0](Arg0: &mut Kiosk)\n\t17: Pop\n\t18: LdConst[1](u64: 1)\n\t19: Abort\nB3:\n\t20: CopyLoc[0](Arg0: &mut Kiosk)\n\t21: FreezeRef\n\t22: Call object::id<Kiosk>(&Kiosk): ID\n\t23: MoveLoc[5](loc2: ID)\n\t24: Eq\n\t25: BrFalse(27)\nB4:\n\t26: Branch(31)\nB5:\n\t27: MoveLoc[0](Arg0: &mut Kiosk)\n\t28: Pop\n\t29: LdConst[5](u64: 5)\n\t30: Abort\nB6:\n\t31: CopyLoc[0](Arg0: &mut Kiosk)\n\t32: MutBorrowField[2](Kiosk.id: UID)\n\t33: CopyLoc[3](loc0: ID)\n\t34: LdTrue\n\t35: Pack[5](Listing)\n\t36: Call dynamic_field::remove<Listing, u64>(&mut UID, Listing): u64\n\t37: Pop\n\t38: CopyLoc[0](Arg0: &mut Kiosk)\n\t39: MutBorrowField[3](Kiosk.profits: Balance<SUI>)\n\t40: MoveLoc[2](Arg2: Coin<SUI>)\n\t41: Call coin::put<SUI>(&mut Balance<SUI>, Coin<SUI>)\n\t42: CopyLoc[0](Arg0: &mut Kiosk)\n\t43: ImmBorrowField[1](Kiosk.item_count: u32)\n\t44: ReadRef\n\t45: LdU32(1)\n\t46: Sub\n\t47: CopyLoc[0](Arg0: &mut Kiosk)\n\t48: MutBorrowField[1](Kiosk.item_count: u32)\n\t49: WriteRef\n\t50: CopyLoc[0](Arg0: &mut Kiosk)\n\t51: MutBorrowField[2](Kiosk.id: UID)\n\t52: CopyLoc[3](loc0: ID)\n\t53: Pack[6](Lock)\n\t54: Call dynamic_field::remove_if_exists<Lock, bool>(&mut UID, Lock): Option<bool>\n\t55: Pop\n\t56: CopyLoc[0](Arg0: &mut Kiosk)\n\t57: MutBorrowField[2](Kiosk.id: UID)\n\t58: CopyLoc[3](loc0: ID)\n\t59: Pack[4](Item)\n\t60: Call dynamic_object_field::remove<Item, Ty0>(&mut UID, Item): Ty0\n\t61: MoveLoc[3](loc0: ID)\n\t62: MoveLoc[7](loc4: u64)\n\t63: MoveLoc[0](Arg0: &mut Kiosk)\n\t64: FreezeRef\n\t65: Call object::id<Kiosk>(&Kiosk): ID\n\t66: Call transfer_policy::new_request<Ty0>(ID, u64, ID): TransferRequest<Ty0>\n\t67: Ret\n}\n\npublic return_purchase_cap<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: PurchaseCap<Ty0>) {\nL2:\tloc0: UID\nL3:\tloc1: ID\nL4:\tloc2: ID\nB0:\n\t0: MoveLoc[1](Arg1: PurchaseCap<Ty0>)\n\t1: UnpackGeneric[3](PurchaseCap<Ty0>)\n\t2: Pop\n\t3: StLoc[3](loc1: ID)\n\t4: StLoc[4](loc2: ID)\n\t5: StLoc[2](loc0: UID)\n\t6: CopyLoc[0](Arg0: &mut Kiosk)\n\t7: FreezeRef\n\t8: Call object::id<Kiosk>(&Kiosk): ID\n\t9: MoveLoc[4](loc2: ID)\n\t10: Eq\n\t11: BrFalse(13)\nB1:\n\t12: Branch(17)\nB2:\n\t13: MoveLoc[0](Arg0: &mut Kiosk)\n\t14: Pop\n\t15: LdConst[5](u64: 5)\n\t16: Abort\nB3:\n\t17: MoveLoc[0](Arg0: &mut Kiosk)\n\t18: MutBorrowField[2](Kiosk.id: UID)\n\t19: MoveLoc[3](loc1: ID)\n\t20: LdTrue\n\t21: Pack[5](Listing)\n\t22: Call dynamic_field::remove<Listing, u64>(&mut UID, Listing): u64\n\t23: Pop\n\t24: MoveLoc[2](loc0: UID)\n\t25: Call object::delete(UID)\n\t26: Ret\n}\n\npublic withdraw(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: Option<u64>, Arg3: &mut TxContext): Coin<SUI> {\nL4:\tloc0: u64\nL5:\tloc1: u64\nL6:\tloc2: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: MoveLoc[3](Arg3: &mut TxContext)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: ImmBorrowLoc[2](Arg2: Option<u64>)\n\t12: Call option::is_some<u64>(&Option<u64>): bool\n\t13: BrFalse(33)\nB4:\n\t14: MoveLoc[2](Arg2: Option<u64>)\n\t15: Call option::destroy_some<u64>(Option<u64>): u64\n\t16: StLoc[6](loc2: u64)\n\t17: CopyLoc[6](loc2: u64)\n\t18: CopyLoc[0](Arg0: &mut Kiosk)\n\t19: ImmBorrowField[3](Kiosk.profits: Balance<SUI>)\n\t20: Call balance::value<SUI>(&Balance<SUI>): u64\n\t21: Le\n\t22: BrFalse(24)\nB5:\n\t23: Branch(30)\nB6:\n\t24: MoveLoc[0](Arg0: &mut Kiosk)\n\t25: Pop\n\t26: MoveLoc[3](Arg3: &mut TxContext)\n\t27: Pop\n\t28: LdConst[2](u64: 2)\n\t29: Abort\nB7:\n\t30: MoveLoc[6](loc2: u64)\n\t31: StLoc[4](loc0: u64)\n\t32: Branch(37)\nB8:\n\t33: CopyLoc[0](Arg0: &mut Kiosk)\n\t34: ImmBorrowField[3](Kiosk.profits: Balance<SUI>)\n\t35: Call balance::value<SUI>(&Balance<SUI>): u64\n\t36: StLoc[4](loc0: u64)\nB9:\n\t37: MoveLoc[4](loc0: u64)\n\t38: StLoc[5](loc1: u64)\n\t39: MoveLoc[0](Arg0: &mut Kiosk)\n\t40: MutBorrowField[3](Kiosk.profits: Balance<SUI>)\n\t41: MoveLoc[5](loc1: u64)\n\t42: MoveLoc[3](Arg3: &mut TxContext)\n\t43: Call coin::take<SUI>(&mut Balance<SUI>, u64, &mut TxContext): Coin<SUI>\n\t44: Ret\n}\n\npublic(friend) lock_internal<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: Ty0) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MutBorrowField[2](Kiosk.id: UID)\n\t2: ImmBorrowLoc[1](Arg1: Ty0)\n\t3: Call object::id<Ty0>(&Ty0): ID\n\t4: Pack[6](Lock)\n\t5: LdTrue\n\t6: Call dynamic_field::add<Lock, bool>(&mut UID, Lock, bool)\n\t7: MoveLoc[0](Arg0: &mut Kiosk)\n\t8: MoveLoc[1](Arg1: Ty0)\n\t9: Call place_internal<Ty0>(&mut Kiosk, Ty0)\n\t10: Ret\n}\n\npublic(friend) place_internal<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: Ty0) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: ImmBorrowField[1](Kiosk.item_count: u32)\n\t2: ReadRef\n\t3: LdU32(1)\n\t4: Add\n\t5: CopyLoc[0](Arg0: &mut Kiosk)\n\t6: MutBorrowField[1](Kiosk.item_count: u32)\n\t7: WriteRef\n\t8: MoveLoc[0](Arg0: &mut Kiosk)\n\t9: MutBorrowField[2](Kiosk.id: UID)\n\t10: ImmBorrowLoc[1](Arg1: Ty0)\n\t11: Call object::id<Ty0>(&Ty0): ID\n\t12: Pack[4](Item)\n\t13: MoveLoc[1](Arg1: Ty0)\n\t14: Call dynamic_object_field::add<Item, Ty0>(&mut UID, Item, Ty0)\n\t15: Ret\n}\n\npublic(friend) uid_mut_internal(Arg0: &mut Kiosk): &mut UID {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Kiosk)\n\t1: MutBorrowField[2](Kiosk.id: UID)\n\t2: Ret\n}\n\npublic has_item(Arg0: &Kiosk, Arg1: ID): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[2](Kiosk.id: UID)\n\t2: MoveLoc[1](Arg1: ID)\n\t3: Pack[4](Item)\n\t4: Call dynamic_object_field::exists_<Item>(&UID, Item): bool\n\t5: Ret\n}\n\npublic has_item_with_type<Ty0: store + key>(Arg0: &Kiosk, Arg1: ID): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[2](Kiosk.id: UID)\n\t2: MoveLoc[1](Arg1: ID)\n\t3: Pack[4](Item)\n\t4: Call dynamic_object_field::exists_with_type<Item, Ty0>(&UID, Item): bool\n\t5: Ret\n}\n\npublic is_locked(Arg0: &Kiosk, Arg1: ID): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[2](Kiosk.id: UID)\n\t2: MoveLoc[1](Arg1: ID)\n\t3: Pack[6](Lock)\n\t4: Call dynamic_field::exists_<Lock>(&UID, Lock): bool\n\t5: Ret\n}\n\npublic is_listed(Arg0: &Kiosk, Arg1: ID): bool {\nL2:\tloc0: bool\nB0:\n\t0: CopyLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[2](Kiosk.id: UID)\n\t2: CopyLoc[1](Arg1: ID)\n\t3: LdFalse\n\t4: Pack[5](Listing)\n\t5: Call dynamic_field::exists_<Listing>(&UID, Listing): bool\n\t6: BrFalse(12)\nB1:\n\t7: MoveLoc[0](Arg0: &Kiosk)\n\t8: Pop\n\t9: LdTrue\n\t10: StLoc[2](loc0: bool)\n\t11: Branch(16)\nB2:\n\t12: MoveLoc[0](Arg0: &Kiosk)\n\t13: MoveLoc[1](Arg1: ID)\n\t14: Call is_listed_exclusively(&Kiosk, ID): bool\n\t15: StLoc[2](loc0: bool)\nB3:\n\t16: MoveLoc[2](loc0: bool)\n\t17: Ret\n}\n\npublic is_listed_exclusively(Arg0: &Kiosk, Arg1: ID): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[2](Kiosk.id: UID)\n\t2: MoveLoc[1](Arg1: ID)\n\t3: LdTrue\n\t4: Pack[5](Listing)\n\t5: Call dynamic_field::exists_<Listing>(&UID, Listing): bool\n\t6: Ret\n}\n\npublic has_access(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Kiosk)\n\t1: FreezeRef\n\t2: Call object::id<Kiosk>(&Kiosk): ID\n\t3: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t4: ImmBorrowField[4](KioskOwnerCap.for: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: Ret\n}\n\npublic uid_mut_as_owner(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap): &mut UID {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: MoveLoc[0](Arg0: &mut Kiosk)\n\t10: MutBorrowField[2](Kiosk.id: UID)\n\t11: Ret\n}\n\npublic set_allow_extensions(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: bool) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: MoveLoc[2](Arg2: bool)\n\t10: MoveLoc[0](Arg0: &mut Kiosk)\n\t11: MutBorrowField[5](Kiosk.allow_extensions: bool)\n\t12: WriteRef\n\t13: Ret\n}\n\npublic uid(Arg0: &Kiosk): &UID {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[2](Kiosk.id: UID)\n\t2: Ret\n}\n\npublic uid_mut(Arg0: &mut Kiosk): &mut UID {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: ImmBorrowField[5](Kiosk.allow_extensions: bool)\n\t2: ReadRef\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[7](u64: 7)\n\t8: Abort\nB3:\n\t9: MoveLoc[0](Arg0: &mut Kiosk)\n\t10: MutBorrowField[2](Kiosk.id: UID)\n\t11: Ret\n}\n\npublic owner(Arg0: &Kiosk): address {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[0](Kiosk.owner: address)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic item_count(Arg0: &Kiosk): u32 {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[1](Kiosk.item_count: u32)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic profits_amount(Arg0: &Kiosk): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: ImmBorrowField[3](Kiosk.profits: Balance<SUI>)\n\t2: Call balance::value<SUI>(&Balance<SUI>): u64\n\t3: Ret\n}\n\npublic profits_mut(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap): &mut Balance<SUI> {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: MoveLoc[0](Arg0: &mut Kiosk)\n\t10: MutBorrowField[3](Kiosk.profits: Balance<SUI>)\n\t11: Ret\n}\n\npublic borrow<Ty0: store + key>(Arg0: &Kiosk, Arg1: &KioskOwnerCap, Arg2: ID): &Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: &Kiosk)\n\t1: Call object::id<Kiosk>(&Kiosk): ID\n\t2: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t3: ImmBorrowField[4](KioskOwnerCap.for: ID)\n\t4: ReadRef\n\t5: Eq\n\t6: BrFalse(8)\nB1:\n\t7: Branch(12)\nB2:\n\t8: MoveLoc[0](Arg0: &Kiosk)\n\t9: Pop\n\t10: LdConst[0](u64: 0)\n\t11: Abort\nB3:\n\t12: CopyLoc[0](Arg0: &Kiosk)\n\t13: CopyLoc[2](Arg2: ID)\n\t14: Call has_item(&Kiosk, ID): bool\n\t15: BrFalse(17)\nB4:\n\t16: Branch(21)\nB5:\n\t17: MoveLoc[0](Arg0: &Kiosk)\n\t18: Pop\n\t19: LdConst[11](u64: 11)\n\t20: Abort\nB6:\n\t21: MoveLoc[0](Arg0: &Kiosk)\n\t22: ImmBorrowField[2](Kiosk.id: UID)\n\t23: MoveLoc[2](Arg2: ID)\n\t24: Pack[4](Item)\n\t25: Call dynamic_object_field::borrow<Item, Ty0>(&UID, Item): &Ty0\n\t26: Ret\n}\n\npublic borrow_mut<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: ID): &mut Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut Kiosk)\n\t10: FreezeRef\n\t11: CopyLoc[2](Arg2: ID)\n\t12: Call has_item(&Kiosk, ID): bool\n\t13: BrFalse(15)\nB4:\n\t14: Branch(19)\nB5:\n\t15: MoveLoc[0](Arg0: &mut Kiosk)\n\t16: Pop\n\t17: LdConst[11](u64: 11)\n\t18: Abort\nB6:\n\t19: CopyLoc[0](Arg0: &mut Kiosk)\n\t20: FreezeRef\n\t21: CopyLoc[2](Arg2: ID)\n\t22: Call is_listed(&Kiosk, ID): bool\n\t23: Not\n\t24: BrFalse(26)\nB7:\n\t25: Branch(30)\nB8:\n\t26: MoveLoc[0](Arg0: &mut Kiosk)\n\t27: Pop\n\t28: LdConst[9](u64: 9)\n\t29: Abort\nB9:\n\t30: MoveLoc[0](Arg0: &mut Kiosk)\n\t31: MutBorrowField[2](Kiosk.id: UID)\n\t32: MoveLoc[2](Arg2: ID)\n\t33: Pack[4](Item)\n\t34: Call dynamic_object_field::borrow_mut<Item, Ty0>(&mut UID, Item): &mut Ty0\n\t35: Ret\n}\n\npublic borrow_val<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap, Arg2: ID): Ty0 * Borrow {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut Kiosk)\n\t10: FreezeRef\n\t11: CopyLoc[2](Arg2: ID)\n\t12: Call has_item(&Kiosk, ID): bool\n\t13: BrFalse(15)\nB4:\n\t14: Branch(19)\nB5:\n\t15: MoveLoc[0](Arg0: &mut Kiosk)\n\t16: Pop\n\t17: LdConst[11](u64: 11)\n\t18: Abort\nB6:\n\t19: CopyLoc[0](Arg0: &mut Kiosk)\n\t20: FreezeRef\n\t21: CopyLoc[2](Arg2: ID)\n\t22: Call is_listed(&Kiosk, ID): bool\n\t23: Not\n\t24: BrFalse(26)\nB7:\n\t25: Branch(30)\nB8:\n\t26: MoveLoc[0](Arg0: &mut Kiosk)\n\t27: Pop\n\t28: LdConst[9](u64: 9)\n\t29: Abort\nB9:\n\t30: CopyLoc[0](Arg0: &mut Kiosk)\n\t31: MutBorrowField[2](Kiosk.id: UID)\n\t32: CopyLoc[2](Arg2: ID)\n\t33: Pack[4](Item)\n\t34: Call dynamic_object_field::remove<Item, Ty0>(&mut UID, Item): Ty0\n\t35: MoveLoc[0](Arg0: &mut Kiosk)\n\t36: FreezeRef\n\t37: Call object::id<Kiosk>(&Kiosk): ID\n\t38: MoveLoc[2](Arg2: ID)\n\t39: Pack[3](Borrow)\n\t40: Ret\n}\n\npublic return_val<Ty0: store + key>(Arg0: &mut Kiosk, Arg1: Ty0, Arg2: Borrow) {\nL3:\tloc0: ID\nL4:\tloc1: ID\nB0:\n\t0: MoveLoc[2](Arg2: Borrow)\n\t1: Unpack[3](Borrow)\n\t2: StLoc[3](loc0: ID)\n\t3: StLoc[4](loc1: ID)\n\t4: CopyLoc[0](Arg0: &mut Kiosk)\n\t5: FreezeRef\n\t6: Call object::id<Kiosk>(&Kiosk): ID\n\t7: MoveLoc[4](loc1: ID)\n\t8: Eq\n\t9: BrFalse(11)\nB1:\n\t10: Branch(15)\nB2:\n\t11: MoveLoc[0](Arg0: &mut Kiosk)\n\t12: Pop\n\t13: LdConst[5](u64: 5)\n\t14: Abort\nB3:\n\t15: ImmBorrowLoc[1](Arg1: Ty0)\n\t16: Call object::id<Ty0>(&Ty0): ID\n\t17: CopyLoc[3](loc0: ID)\n\t18: Eq\n\t19: BrFalse(21)\nB4:\n\t20: Branch(25)\nB5:\n\t21: MoveLoc[0](Arg0: &mut Kiosk)\n\t22: Pop\n\t23: LdConst[10](u64: 10)\n\t24: Abort\nB6:\n\t25: MoveLoc[0](Arg0: &mut Kiosk)\n\t26: MutBorrowField[2](Kiosk.id: UID)\n\t27: MoveLoc[3](loc0: ID)\n\t28: Pack[4](Item)\n\t29: MoveLoc[1](Arg1: Ty0)\n\t30: Call dynamic_object_field::add<Item, Ty0>(&mut UID, Item, Ty0)\n\t31: Ret\n}\n\npublic kiosk_owner_cap_for(Arg0: &KioskOwnerCap): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &KioskOwnerCap)\n\t1: ImmBorrowField[4](KioskOwnerCap.for: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic purchase_cap_kiosk<Ty0: store + key>(Arg0: &PurchaseCap<Ty0>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &PurchaseCap<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](PurchaseCap.kiosk_id: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic purchase_cap_item<Ty0: store + key>(Arg0: &PurchaseCap<Ty0>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &PurchaseCap<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](PurchaseCap.item_id: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic purchase_cap_min_price<Ty0: store + key>(Arg0: &PurchaseCap<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &PurchaseCap<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](PurchaseCap.min_price: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u64: 5\n\t6 => u64: 6\n\t7 => u64: 7\n\t8 => u64: 8\n\t9 => u64: 9\n\t10 => u64: 10\n\t11 => u64: 11\n\t12 => u64: 12\n]\n}\n","kiosk_extension":"// Move bytecode v6\nmodule 2.kiosk_extension {\nuse 0000000000000000000000000000000000000000000000000000000000000002::bag;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::kiosk;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer_policy;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Extension has store {\n\tstorage: Bag,\n\tpermissions: u128,\n\tis_enabled: bool\n}\n\nstruct ExtensionKey<phantom Ty0> has copy, drop, store {\n\tdummy_field: bool\n}\n\npublic add<Ty0: drop>(Arg0: Ty0, Arg1: &mut Kiosk, Arg2: &KioskOwnerCap, Arg3: u128, Arg4: &mut TxContext) {\nB0:\n\t0: CopyLoc[1](Arg1: &mut Kiosk)\n\t1: CopyLoc[2](Arg2: &KioskOwnerCap)\n\t2: Call kiosk::has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(13)\nB2:\n\t5: MoveLoc[1](Arg1: &mut Kiosk)\n\t6: Pop\n\t7: MoveLoc[4](Arg4: &mut TxContext)\n\t8: Pop\n\t9: MoveLoc[2](Arg2: &KioskOwnerCap)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: MoveLoc[1](Arg1: &mut Kiosk)\n\t14: MoveLoc[2](Arg2: &KioskOwnerCap)\n\t15: Call kiosk::uid_mut_as_owner(&mut Kiosk, &KioskOwnerCap): &mut UID\n\t16: LdFalse\n\t17: PackGeneric[0](ExtensionKey<Ty0>)\n\t18: MoveLoc[4](Arg4: &mut TxContext)\n\t19: Call bag::new(&mut TxContext): Bag\n\t20: MoveLoc[3](Arg3: u128)\n\t21: LdTrue\n\t22: Pack[0](Extension)\n\t23: Call dynamic_field::add<ExtensionKey<Ty0>, Extension>(&mut UID, ExtensionKey<Ty0>, Extension)\n\t24: Ret\n}\n\npublic disable<Ty0: drop>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call kiosk::has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut Kiosk)\n\t10: FreezeRef\n\t11: Call is_installed<Ty0>(&Kiosk): bool\n\t12: BrFalse(14)\nB4:\n\t13: Branch(18)\nB5:\n\t14: MoveLoc[0](Arg0: &mut Kiosk)\n\t15: Pop\n\t16: LdConst[2](u64: 3)\n\t17: Abort\nB6:\n\t18: LdFalse\n\t19: MoveLoc[0](Arg0: &mut Kiosk)\n\t20: Call extension_mut<Ty0>(&mut Kiosk): &mut Extension\n\t21: MutBorrowField[0](Extension.is_enabled: bool)\n\t22: WriteRef\n\t23: Ret\n}\n\npublic enable<Ty0: drop>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call kiosk::has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[0](u64: 0)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut Kiosk)\n\t10: FreezeRef\n\t11: Call is_installed<Ty0>(&Kiosk): bool\n\t12: BrFalse(14)\nB4:\n\t13: Branch(18)\nB5:\n\t14: MoveLoc[0](Arg0: &mut Kiosk)\n\t15: Pop\n\t16: LdConst[2](u64: 3)\n\t17: Abort\nB6:\n\t18: LdTrue\n\t19: MoveLoc[0](Arg0: &mut Kiosk)\n\t20: Call extension_mut<Ty0>(&mut Kiosk): &mut Extension\n\t21: MutBorrowField[0](Extension.is_enabled: bool)\n\t22: WriteRef\n\t23: Ret\n}\n\npublic remove<Ty0: drop>(Arg0: &mut Kiosk, Arg1: &KioskOwnerCap) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Kiosk)\n\t1: CopyLoc[1](Arg1: &KioskOwnerCap)\n\t2: Call kiosk::has_access(&mut Kiosk, &KioskOwnerCap): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut Kiosk)\n\t6: Pop\n\t7: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut Kiosk)\n\t12: FreezeRef\n\t13: Call is_installed<Ty0>(&Kiosk): bool\n\t14: BrFalse(16)\nB4:\n\t15: Branch(22)\nB5:\n\t16: MoveLoc[0](Arg0: &mut Kiosk)\n\t17: Pop\n\t18: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t19: Pop\n\t20: LdConst[2](u64: 3)\n\t21: Abort\nB6:\n\t22: MoveLoc[0](Arg0: &mut Kiosk)\n\t23: MoveLoc[1](Arg1: &KioskOwnerCap)\n\t24: Call kiosk::uid_mut_as_owner(&mut Kiosk, &KioskOwnerCap): &mut UID\n\t25: LdFalse\n\t26: PackGeneric[0](ExtensionKey<Ty0>)\n\t27: Call dynamic_field::remove<ExtensionKey<Ty0>, Extension>(&mut UID, ExtensionKey<Ty0>): Extension\n\t28: Unpack[0](Extension)\n\t29: Pop\n\t30: Pop\n\t31: Call bag::destroy_empty(Bag)\n\t32: Ret\n}\n\npublic storage<Ty0: drop>(Arg0: Ty0, Arg1: &Kiosk): &Bag {\nB0:\n\t0: CopyLoc[1](Arg1: &Kiosk)\n\t1: Call is_installed<Ty0>(&Kiosk): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(8)\nB2:\n\t4: MoveLoc[1](Arg1: &Kiosk)\n\t5: Pop\n\t6: LdConst[2](u64: 3)\n\t7: Abort\nB3:\n\t8: MoveLoc[1](Arg1: &Kiosk)\n\t9: Call extension<Ty0>(&Kiosk): &Extension\n\t10: ImmBorrowField[1](Extension.storage: Bag)\n\t11: Ret\n}\n\npublic storage_mut<Ty0: drop>(Arg0: Ty0, Arg1: &mut Kiosk): &mut Bag {\nB0:\n\t0: CopyLoc[1](Arg1: &mut Kiosk)\n\t1: FreezeRef\n\t2: Call is_installed<Ty0>(&Kiosk): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[1](Arg1: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[2](u64: 3)\n\t8: Abort\nB3:\n\t9: MoveLoc[1](Arg1: &mut Kiosk)\n\t10: Call extension_mut<Ty0>(&mut Kiosk): &mut Extension\n\t11: MutBorrowField[1](Extension.storage: Bag)\n\t12: Ret\n}\n\npublic place<Ty0: drop, Ty1: store + key>(Arg0: Ty0, Arg1: &mut Kiosk, Arg2: Ty1, Arg3: &TransferPolicy<Ty1>) {\nL4:\tloc0: bool\nB0:\n\t0: CopyLoc[1](Arg1: &mut Kiosk)\n\t1: FreezeRef\n\t2: Call is_installed<Ty0>(&Kiosk): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[1](Arg1: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[2](u64: 3)\n\t8: Abort\nB3:\n\t9: CopyLoc[1](Arg1: &mut Kiosk)\n\t10: FreezeRef\n\t11: Call can_place<Ty0>(&Kiosk): bool\n\t12: BrFalse(16)\nB4:\n\t13: LdTrue\n\t14: StLoc[4](loc0: bool)\n\t15: Branch(20)\nB5:\n\t16: CopyLoc[1](Arg1: &mut Kiosk)\n\t17: FreezeRef\n\t18: Call can_lock<Ty0>(&Kiosk): bool\n\t19: StLoc[4](loc0: bool)\nB6:\n\t20: MoveLoc[4](loc0: bool)\n\t21: BrFalse(23)\nB7:\n\t22: Branch(27)\nB8:\n\t23: MoveLoc[1](Arg1: &mut Kiosk)\n\t24: Pop\n\t25: LdConst[1](u64: 2)\n\t26: Abort\nB9:\n\t27: MoveLoc[1](Arg1: &mut Kiosk)\n\t28: MoveLoc[2](Arg2: Ty1)\n\t29: Call kiosk::place_internal<Ty1>(&mut Kiosk, Ty1)\n\t30: Ret\n}\n\npublic lock<Ty0: drop, Ty1: store + key>(Arg0: Ty0, Arg1: &mut Kiosk, Arg2: Ty1, Arg3: &TransferPolicy<Ty1>) {\nB0:\n\t0: CopyLoc[1](Arg1: &mut Kiosk)\n\t1: FreezeRef\n\t2: Call is_installed<Ty0>(&Kiosk): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[1](Arg1: &mut Kiosk)\n\t6: Pop\n\t7: LdConst[2](u64: 3)\n\t8: Abort\nB3:\n\t9: CopyLoc[1](Arg1: &mut Kiosk)\n\t10: FreezeRef\n\t11: Call can_lock<Ty0>(&Kiosk): bool\n\t12: BrFalse(14)\nB4:\n\t13: Branch(18)\nB5:\n\t14: MoveLoc[1](Arg1: &mut Kiosk)\n\t15: Pop\n\t16: LdConst[1](u64: 2)\n\t17: Abort\nB6:\n\t18: MoveLoc[1](Arg1: &mut Kiosk)\n\t19: MoveLoc[2](Arg2: Ty1)\n\t20: Call kiosk::lock_internal<Ty1>(&mut Kiosk, Ty1)\n\t21: Ret\n}\n\npublic is_installed<Ty0: drop>(Arg0: &Kiosk): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: Call kiosk::uid(&Kiosk): &UID\n\t2: LdFalse\n\t3: PackGeneric[0](ExtensionKey<Ty0>)\n\t4: Call dynamic_field::exists_<ExtensionKey<Ty0>>(&UID, ExtensionKey<Ty0>): bool\n\t5: Ret\n}\n\npublic is_enabled<Ty0: drop>(Arg0: &Kiosk): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: Call extension<Ty0>(&Kiosk): &Extension\n\t2: ImmBorrowField[0](Extension.is_enabled: bool)\n\t3: ReadRef\n\t4: Ret\n}\n\npublic can_place<Ty0: drop>(Arg0: &Kiosk): bool {\nL1:\tloc0: bool\nB0:\n\t0: CopyLoc[0](Arg0: &Kiosk)\n\t1: Call is_enabled<Ty0>(&Kiosk): bool\n\t2: BrFalse(13)\nB1:\n\t3: MoveLoc[0](Arg0: &Kiosk)\n\t4: Call extension<Ty0>(&Kiosk): &Extension\n\t5: ImmBorrowField[2](Extension.permissions: u128)\n\t6: ReadRef\n\t7: LdConst[3](u128: 1)\n\t8: BitAnd\n\t9: LdU128(0)\n\t10: Neq\n\t11: StLoc[1](loc0: bool)\n\t12: Branch(17)\nB2:\n\t13: MoveLoc[0](Arg0: &Kiosk)\n\t14: Pop\n\t15: LdFalse\n\t16: StLoc[1](loc0: bool)\nB3:\n\t17: MoveLoc[1](loc0: bool)\n\t18: Ret\n}\n\npublic can_lock<Ty0: drop>(Arg0: &Kiosk): bool {\nL1:\tloc0: bool\nB0:\n\t0: CopyLoc[0](Arg0: &Kiosk)\n\t1: Call is_enabled<Ty0>(&Kiosk): bool\n\t2: BrFalse(13)\nB1:\n\t3: MoveLoc[0](Arg0: &Kiosk)\n\t4: Call extension<Ty0>(&Kiosk): &Extension\n\t5: ImmBorrowField[2](Extension.permissions: u128)\n\t6: ReadRef\n\t7: LdConst[4](u128: 2)\n\t8: BitAnd\n\t9: LdU128(0)\n\t10: Neq\n\t11: StLoc[1](loc0: bool)\n\t12: Branch(17)\nB2:\n\t13: MoveLoc[0](Arg0: &Kiosk)\n\t14: Pop\n\t15: LdFalse\n\t16: StLoc[1](loc0: bool)\nB3:\n\t17: MoveLoc[1](loc0: bool)\n\t18: Ret\n}\n\nextension<Ty0: drop>(Arg0: &Kiosk): &Extension {\nB0:\n\t0: MoveLoc[0](Arg0: &Kiosk)\n\t1: Call kiosk::uid(&Kiosk): &UID\n\t2: LdFalse\n\t3: PackGeneric[0](ExtensionKey<Ty0>)\n\t4: Call dynamic_field::borrow<ExtensionKey<Ty0>, Extension>(&UID, ExtensionKey<Ty0>): &Extension\n\t5: Ret\n}\n\nextension_mut<Ty0: drop>(Arg0: &mut Kiosk): &mut Extension {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Kiosk)\n\t1: Call kiosk::uid_mut_internal(&mut Kiosk): &mut UID\n\t2: LdFalse\n\t3: PackGeneric[0](ExtensionKey<Ty0>)\n\t4: Call dynamic_field::borrow_mut<ExtensionKey<Ty0>, Extension>(&mut UID, ExtensionKey<Ty0>): &mut Extension\n\t5: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 2\n\t2 => u64: 3\n\t3 => u128: 1\n\t4 => u128: 2\n]\n}\n","linked_table":"// Move bytecode v6\nmodule 2.linked_table {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct LinkedTable<Ty0: copy + drop + store, phantom Ty1: store> has store, key {\n\tid: UID,\n\tsize: u64,\n\thead: Option<Ty0>,\n\ttail: Option<Ty0>\n}\n\nstruct Node<Ty0: copy + drop + store, Ty1: store> has store {\n\tprev: Option<Ty0>,\n\tnext: Option<Ty0>,\n\tvalue: Ty1\n}\n\npublic new<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut TxContext): LinkedTable<Ty0, Ty1> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: LdU64(0)\n\t3: Call option::none<Ty0>(): Option<Ty0>\n\t4: Call option::none<Ty0>(): Option<Ty0>\n\t5: PackGeneric[0](LinkedTable<Ty0, Ty1>)\n\t6: Ret\n}\n\npublic front<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>): &Option<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t2: Ret\n}\n\npublic back<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>): &Option<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t2: Ret\n}\n\npublic push_front<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut LinkedTable<Ty0, Ty1>, Arg1: Ty0, Arg2: Ty1) {\nL3:\tloc0: Option<Ty0>\nL4:\tloc1: Option<Ty0>\nL5:\tloc2: Option<Ty0>\nL6:\tloc3: Ty0\nL7:\tloc4: Option<Ty0>\nB0:\n\t0: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t2: CopyLoc[1](Arg1: Ty0)\n\t3: Call option::swap_or_fill<Ty0>(&mut Option<Ty0>, Ty0): Option<Ty0>\n\t4: StLoc[5](loc2: Option<Ty0>)\n\t5: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t6: ImmBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t7: Call option::is_none<Ty0>(&Option<Ty0>): bool\n\t8: BrFalse(13)\nB1:\n\t9: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t10: MutBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t11: CopyLoc[1](Arg1: Ty0)\n\t12: Call option::fill<Ty0>(&mut Option<Ty0>, Ty0)\nB2:\n\t13: Call option::none<Ty0>(): Option<Ty0>\n\t14: StLoc[7](loc4: Option<Ty0>)\n\t15: ImmBorrowLoc[5](loc2: Option<Ty0>)\n\t16: Call option::is_some<Ty0>(&Option<Ty0>): bool\n\t17: BrFalse(33)\nB3:\n\t18: MoveLoc[5](loc2: Option<Ty0>)\n\t19: Call option::destroy_some<Ty0>(Option<Ty0>): Ty0\n\t20: StLoc[6](loc3: Ty0)\n\t21: CopyLoc[1](Arg1: Ty0)\n\t22: Call option::some<Ty0>(Ty0): Option<Ty0>\n\t23: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t24: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t25: CopyLoc[6](loc3: Ty0)\n\t26: Call dynamic_field::borrow_mut<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0): &mut Node<Ty0, Ty1>\n\t27: MutBorrowFieldGeneric[3](Node.prev: Option<Ty0>)\n\t28: WriteRef\n\t29: MoveLoc[6](loc3: Ty0)\n\t30: Call option::some<Ty0>(Ty0): Option<Ty0>\n\t31: StLoc[3](loc0: Option<Ty0>)\n\t32: Branch(35)\nB4:\n\t33: Call option::none<Ty0>(): Option<Ty0>\n\t34: StLoc[3](loc0: Option<Ty0>)\nB5:\n\t35: MoveLoc[3](loc0: Option<Ty0>)\n\t36: StLoc[4](loc1: Option<Ty0>)\n\t37: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t38: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t39: MoveLoc[1](Arg1: Ty0)\n\t40: MoveLoc[7](loc4: Option<Ty0>)\n\t41: MoveLoc[4](loc1: Option<Ty0>)\n\t42: MoveLoc[2](Arg2: Ty1)\n\t43: PackGeneric[1](Node<Ty0, Ty1>)\n\t44: Call dynamic_field::add<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0, Node<Ty0, Ty1>)\n\t45: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t46: ImmBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t47: ReadRef\n\t48: LdU64(1)\n\t49: Add\n\t50: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t51: MutBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t52: WriteRef\n\t53: Ret\n}\n\npublic push_back<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut LinkedTable<Ty0, Ty1>, Arg1: Ty0, Arg2: Ty1) {\nL3:\tloc0: Option<Ty0>\nL4:\tloc1: Option<Ty0>\nL5:\tloc2: Option<Ty0>\nL6:\tloc3: Ty0\nL7:\tloc4: Option<Ty0>\nB0:\n\t0: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t2: Call option::is_none<Ty0>(&Option<Ty0>): bool\n\t3: BrFalse(8)\nB1:\n\t4: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t5: MutBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t6: CopyLoc[1](Arg1: Ty0)\n\t7: Call option::fill<Ty0>(&mut Option<Ty0>, Ty0)\nB2:\n\t8: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t9: MutBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t10: CopyLoc[1](Arg1: Ty0)\n\t11: Call option::swap_or_fill<Ty0>(&mut Option<Ty0>, Ty0): Option<Ty0>\n\t12: StLoc[5](loc2: Option<Ty0>)\n\t13: ImmBorrowLoc[5](loc2: Option<Ty0>)\n\t14: Call option::is_some<Ty0>(&Option<Ty0>): bool\n\t15: BrFalse(31)\nB3:\n\t16: MoveLoc[5](loc2: Option<Ty0>)\n\t17: Call option::destroy_some<Ty0>(Option<Ty0>): Ty0\n\t18: StLoc[6](loc3: Ty0)\n\t19: CopyLoc[1](Arg1: Ty0)\n\t20: Call option::some<Ty0>(Ty0): Option<Ty0>\n\t21: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t22: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t23: CopyLoc[6](loc3: Ty0)\n\t24: Call dynamic_field::borrow_mut<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0): &mut Node<Ty0, Ty1>\n\t25: MutBorrowFieldGeneric[5](Node.next: Option<Ty0>)\n\t26: WriteRef\n\t27: MoveLoc[6](loc3: Ty0)\n\t28: Call option::some<Ty0>(Ty0): Option<Ty0>\n\t29: StLoc[3](loc0: Option<Ty0>)\n\t30: Branch(33)\nB4:\n\t31: Call option::none<Ty0>(): Option<Ty0>\n\t32: StLoc[3](loc0: Option<Ty0>)\nB5:\n\t33: MoveLoc[3](loc0: Option<Ty0>)\n\t34: StLoc[7](loc4: Option<Ty0>)\n\t35: Call option::none<Ty0>(): Option<Ty0>\n\t36: StLoc[4](loc1: Option<Ty0>)\n\t37: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t38: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t39: MoveLoc[1](Arg1: Ty0)\n\t40: MoveLoc[7](loc4: Option<Ty0>)\n\t41: MoveLoc[4](loc1: Option<Ty0>)\n\t42: MoveLoc[2](Arg2: Ty1)\n\t43: PackGeneric[1](Node<Ty0, Ty1>)\n\t44: Call dynamic_field::add<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0, Node<Ty0, Ty1>)\n\t45: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t46: ImmBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t47: ReadRef\n\t48: LdU64(1)\n\t49: Add\n\t50: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t51: MutBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t52: WriteRef\n\t53: Ret\n}\n\npublic borrow<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>, Arg1: Ty0): &Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow<Ty0, Node<Ty0, Ty1>>(&UID, Ty0): &Node<Ty0, Ty1>\n\t4: ImmBorrowFieldGeneric[6](Node.value: Ty1)\n\t5: Ret\n}\n\npublic borrow_mut<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut LinkedTable<Ty0, Ty1>, Arg1: Ty0): &mut Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow_mut<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0): &mut Node<Ty0, Ty1>\n\t4: MutBorrowFieldGeneric[6](Node.value: Ty1)\n\t5: Ret\n}\n\npublic prev<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>, Arg1: Ty0): &Option<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow<Ty0, Node<Ty0, Ty1>>(&UID, Ty0): &Node<Ty0, Ty1>\n\t4: ImmBorrowFieldGeneric[3](Node.prev: Option<Ty0>)\n\t5: Ret\n}\n\npublic next<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>, Arg1: Ty0): &Option<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow<Ty0, Node<Ty0, Ty1>>(&UID, Ty0): &Node<Ty0, Ty1>\n\t4: ImmBorrowFieldGeneric[5](Node.next: Option<Ty0>)\n\t5: Ret\n}\n\npublic remove<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut LinkedTable<Ty0, Ty1>, Arg1: Ty0): Ty1 {\nL2:\tloc0: Option<Ty0>\nL3:\tloc1: Option<Ty0>\nL4:\tloc2: Ty1\nB0:\n\t0: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t2: CopyLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::remove<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0): Node<Ty0, Ty1>\n\t4: UnpackGeneric[1](Node<Ty0, Ty1>)\n\t5: StLoc[4](loc2: Ty1)\n\t6: StLoc[2](loc0: Option<Ty0>)\n\t7: StLoc[3](loc1: Option<Ty0>)\n\t8: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t9: ImmBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t10: ReadRef\n\t11: LdU64(1)\n\t12: Sub\n\t13: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t14: MutBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t15: WriteRef\n\t16: ImmBorrowLoc[3](loc1: Option<Ty0>)\n\t17: Call option::is_some<Ty0>(&Option<Ty0>): bool\n\t18: BrFalse(28)\nB1:\n\t19: CopyLoc[2](loc0: Option<Ty0>)\n\t20: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t21: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t22: ImmBorrowLoc[3](loc1: Option<Ty0>)\n\t23: Call option::borrow<Ty0>(&Option<Ty0>): &Ty0\n\t24: ReadRef\n\t25: Call dynamic_field::borrow_mut<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0): &mut Node<Ty0, Ty1>\n\t26: MutBorrowFieldGeneric[5](Node.next: Option<Ty0>)\n\t27: WriteRef\nB2:\n\t28: ImmBorrowLoc[2](loc0: Option<Ty0>)\n\t29: Call option::is_some<Ty0>(&Option<Ty0>): bool\n\t30: BrFalse(40)\nB3:\n\t31: CopyLoc[3](loc1: Option<Ty0>)\n\t32: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t33: MutBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t34: ImmBorrowLoc[2](loc0: Option<Ty0>)\n\t35: Call option::borrow<Ty0>(&Option<Ty0>): &Ty0\n\t36: ReadRef\n\t37: Call dynamic_field::borrow_mut<Ty0, Node<Ty0, Ty1>>(&mut UID, Ty0): &mut Node<Ty0, Ty1>\n\t38: MutBorrowFieldGeneric[3](Node.prev: Option<Ty0>)\n\t39: WriteRef\nB4:\n\t40: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t41: ImmBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t42: Call option::borrow<Ty0>(&Option<Ty0>): &Ty0\n\t43: ImmBorrowLoc[1](Arg1: Ty0)\n\t44: Eq\n\t45: BrFalse(50)\nB5:\n\t46: MoveLoc[2](loc0: Option<Ty0>)\n\t47: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t48: MutBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t49: WriteRef\nB6:\n\t50: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t51: ImmBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t52: Call option::borrow<Ty0>(&Option<Ty0>): &Ty0\n\t53: ImmBorrowLoc[1](Arg1: Ty0)\n\t54: Eq\n\t55: BrFalse(61)\nB7:\n\t56: MoveLoc[3](loc1: Option<Ty0>)\n\t57: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t58: MutBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t59: WriteRef\n\t60: Branch(63)\nB8:\n\t61: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t62: Pop\nB9:\n\t63: MoveLoc[4](loc2: Ty1)\n\t64: Ret\n}\n\npublic pop_front<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut LinkedTable<Ty0, Ty1>): Ty0 * Ty1 {\nL1:\tloc0: Ty0\nB0:\n\t0: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t2: Call option::is_some<Ty0>(&Option<Ty0>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t6: Pop\n\t7: LdConst[1](u64: 1)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t10: ImmBorrowFieldGeneric[0](LinkedTable.head: Option<Ty0>)\n\t11: Call option::borrow<Ty0>(&Option<Ty0>): &Ty0\n\t12: ReadRef\n\t13: StLoc[1](loc0: Ty0)\n\t14: CopyLoc[1](loc0: Ty0)\n\t15: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t16: MoveLoc[1](loc0: Ty0)\n\t17: Call remove<Ty0, Ty1>(&mut LinkedTable<Ty0, Ty1>, Ty0): Ty1\n\t18: Ret\n}\n\npublic pop_back<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut LinkedTable<Ty0, Ty1>): Ty0 * Ty1 {\nL1:\tloc0: Ty0\nB0:\n\t0: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t2: Call option::is_some<Ty0>(&Option<Ty0>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t6: Pop\n\t7: LdConst[1](u64: 1)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t10: ImmBorrowFieldGeneric[1](LinkedTable.tail: Option<Ty0>)\n\t11: Call option::borrow<Ty0>(&Option<Ty0>): &Ty0\n\t12: ReadRef\n\t13: StLoc[1](loc0: Ty0)\n\t14: CopyLoc[1](loc0: Ty0)\n\t15: MoveLoc[0](Arg0: &mut LinkedTable<Ty0, Ty1>)\n\t16: MoveLoc[1](loc0: Ty0)\n\t17: Call remove<Ty0, Ty1>(&mut LinkedTable<Ty0, Ty1>, Ty0): Ty1\n\t18: Ret\n}\n\npublic contains<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>, Arg1: Ty0): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[2](LinkedTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::exists_with_type<Ty0, Node<Ty0, Ty1>>(&UID, Ty0): bool\n\t4: Ret\n}\n\npublic length<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic is_empty<Ty0: copy + drop + store, Ty1: store>(Arg0: &LinkedTable<Ty0, Ty1>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &LinkedTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[4](LinkedTable.size: u64)\n\t2: ReadRef\n\t3: LdU64(0)\n\t4: Eq\n\t5: Ret\n}\n\npublic destroy_empty<Ty0: copy + drop + store, Ty1: store>(Arg0: LinkedTable<Ty0, Ty1>) {\nL1:\tloc0: UID\nL2:\tloc1: u64\nB0:\n\t0: MoveLoc[0](Arg0: LinkedTable<Ty0, Ty1>)\n\t1: UnpackGeneric[0](LinkedTable<Ty0, Ty1>)\n\t2: Pop\n\t3: Pop\n\t4: StLoc[2](loc1: u64)\n\t5: StLoc[1](loc0: UID)\n\t6: MoveLoc[2](loc1: u64)\n\t7: LdU64(0)\n\t8: Eq\n\t9: BrFalse(11)\nB1:\n\t10: Branch(13)\nB2:\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: MoveLoc[1](loc0: UID)\n\t14: Call object::delete(UID)\n\t15: Ret\n}\n\npublic drop<Ty0: copy + drop + store, Ty1: drop + store>(Arg0: LinkedTable<Ty0, Ty1>) {\nB0:\n\t0: MoveLoc[0](Arg0: LinkedTable<Ty0, Ty1>)\n\t1: UnpackGeneric[0](LinkedTable<Ty0, Ty1>)\n\t2: Pop\n\t3: Pop\n\t4: Pop\n\t5: Call object::delete(UID)\n\t6: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n]\n}\n","math":"// Move bytecode v6\nmodule 2.math {\nuse 0000000000000000000000000000000000000000000000000000000000000001::u128;\nuse 0000000000000000000000000000000000000000000000000000000000000001::u64;\n\npublic max(Arg0: u64, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call u64::max(u64, u64): u64\n\t3: Ret\n}\n\npublic min(Arg0: u64, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call u64::min(u64, u64): u64\n\t3: Ret\n}\n\npublic diff(Arg0: u64, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call u64::diff(u64, u64): u64\n\t3: Ret\n}\n\npublic pow(Arg0: u64, Arg1: u8): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u8)\n\t2: Call u64::pow(u64, u8): u64\n\t3: Ret\n}\n\npublic sqrt(Arg0: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: Call u64::sqrt(u64): u64\n\t2: Ret\n}\n\npublic sqrt_u128(Arg0: u128): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: Call u128::sqrt(u128): u128\n\t2: Ret\n}\n\npublic divide_and_round_up(Arg0: u64, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call u64::divide_and_round_up(u64, u64): u64\n\t3: Ret\n}\n\n}\n","nitro_attestation":"// Move bytecode v6\nmodule 2.nitro_attestation {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::clock;\n\nstruct PCREntry has drop {\n\tindex: u8,\n\tvalue: vector<u8>\n}\n\nstruct NitroAttestationDocument has drop {\n\tmodule_id: vector<u8>,\n\ttimestamp: u64,\n\tdigest: vector<u8>,\n\tpcrs: vector<PCREntry>,\n\tpublic_key: Option<vector<u8>>,\n\tuser_data: Option<vector<u8>>,\n\tnonce: Option<vector<u8>>\n}\n\nentry load_nitro_attestation(Arg0: vector<u8>, Arg1: &Clock): NitroAttestationDocument {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t1: MoveLoc[1](Arg1: &Clock)\n\t2: Call clock::timestamp_ms(&Clock): u64\n\t3: Call load_nitro_attestation_internal(&vector<u8>, u64): NitroAttestationDocument\n\t4: Ret\n}\n\npublic module_id(Arg0: &NitroAttestationDocument): &vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &NitroAttestationDocument)\n\t1: ImmBorrowField[0](NitroAttestationDocument.module_id: vector<u8>)\n\t2: Ret\n}\n\npublic timestamp(Arg0: &NitroAttestationDocument): &u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &NitroAttestationDocument)\n\t1: ImmBorrowField[1](NitroAttestationDocument.timestamp: u64)\n\t2: Ret\n}\n\npublic digest(Arg0: &NitroAttestationDocument): &vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &NitroAttestationDocument)\n\t1: ImmBorrowField[2](NitroAttestationDocument.digest: vector<u8>)\n\t2: Ret\n}\n\npublic pcrs(Arg0: &NitroAttestationDocument): &vector<PCREntry> {\nB0:\n\t0: MoveLoc[0](Arg0: &NitroAttestationDocument)\n\t1: ImmBorrowField[3](NitroAttestationDocument.pcrs: vector<PCREntry>)\n\t2: Ret\n}\n\npublic public_key(Arg0: &NitroAttestationDocument): &Option<vector<u8>> {\nB0:\n\t0: MoveLoc[0](Arg0: &NitroAttestationDocument)\n\t1: ImmBorrowField[4](NitroAttestationDocument.public_key: Option<vector<u8>>)\n\t2: Ret\n}\n\npublic user_data(Arg0: &NitroAttestationDocument): &Option<vector<u8>> {\nB0:\n\t0: MoveLoc[0](Arg0: &NitroAttestationDocument)\n\t1: ImmBorrowField[5](NitroAttestationDocument.user_data: Option<vector<u8>>)\n\t2: Ret\n}\n\npublic nonce(Arg0: &NitroAttestationDocument): &Option<vector<u8>> {\nB0:\n\t0: MoveLoc[0](Arg0: &NitroAttestationDocument)\n\t1: ImmBorrowField[6](NitroAttestationDocument.nonce: Option<vector<u8>>)\n\t2: Ret\n}\n\npublic index(Arg0: &PCREntry): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: &PCREntry)\n\t1: ImmBorrowField[7](PCREntry.index: u8)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic value(Arg0: &PCREntry): &vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &PCREntry)\n\t1: ImmBorrowField[8](PCREntry.value: vector<u8>)\n\t2: Ret\n}\n\nnative load_nitro_attestation_internal(Arg0: &vector<u8>, Arg1: u64): NitroAttestationDocument;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n]\n}\n","object":"// Move bytecode v6\nmodule 2.object {\nuse 0000000000000000000000000000000000000000000000000000000000000001::bcs;\nuse 0000000000000000000000000000000000000000000000000000000000000002::address;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct ID has copy, drop, store {\n\tbytes: address\n}\n\nstruct UID has store {\n\tid: ID\n}\n\npublic id_to_bytes(Arg0: &ID): vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &ID)\n\t1: ImmBorrowField[0](ID.bytes: address)\n\t2: Call bcs::to_bytes<address>(&address): vector<u8>\n\t3: Ret\n}\n\npublic id_to_address(Arg0: &ID): address {\nB0:\n\t0: MoveLoc[0](Arg0: &ID)\n\t1: ImmBorrowField[0](ID.bytes: address)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic id_from_bytes(Arg0: vector<u8>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: vector<u8>)\n\t1: Call address::from_bytes(vector<u8>): address\n\t2: Call id_from_address(address): ID\n\t3: Ret\n}\n\npublic id_from_address(Arg0: address): ID {\nB0:\n\t0: MoveLoc[0](Arg0: address)\n\t1: Pack[0](ID)\n\t2: Ret\n}\n\nsui_system_state(Arg0: &TxContext): UID {\nB0:\n\t0: MoveLoc[0](Arg0: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[9](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[8](u64: 0)\n\t7: Abort\nB3:\n\t8: LdConst[0](address: 0x00..)\n\t9: Pack[0](ID)\n\t10: Pack[1](UID)\n\t11: Ret\n}\n\npublic(friend) clock(): UID {\nB0:\n\t0: LdConst[1](address: 0x00..)\n\t1: Pack[0](ID)\n\t2: Pack[1](UID)\n\t3: Ret\n}\n\npublic(friend) authenticator_state(): UID {\nB0:\n\t0: LdConst[2](address: 0x00..)\n\t1: Pack[0](ID)\n\t2: Pack[1](UID)\n\t3: Ret\n}\n\npublic(friend) randomness_state(): UID {\nB0:\n\t0: LdConst[3](address: 0x00..)\n\t1: Pack[0](ID)\n\t2: Pack[1](UID)\n\t3: Ret\n}\n\npublic(friend) sui_deny_list_object_id(): UID {\nB0:\n\t0: LdConst[4](address: 0x00..)\n\t1: Pack[0](ID)\n\t2: Pack[1](UID)\n\t3: Ret\n}\n\npublic(friend) sui_accumulator_root_object_id(): UID {\nB0:\n\t0: LdConst[5](address: 0x00..)\n\t1: Pack[0](ID)\n\t2: Pack[1](UID)\n\t3: Ret\n}\n\npublic(friend) sui_accumulator_root_address(): address {\nB0:\n\t0: LdConst[5](address: 0x00..)\n\t1: Ret\n}\n\npublic(friend) sui_coin_registry_object_id(): UID {\nB0:\n\t0: LdConst[7](address: 0x00..)\n\t1: Pack[0](ID)\n\t2: Pack[1](UID)\n\t3: Ret\n}\n\npublic(friend) sui_coin_registry_address(): address {\nB0:\n\t0: LdConst[7](address: 0x00..)\n\t1: Ret\n}\n\nbridge(): UID {\nB0:\n\t0: LdConst[6](address: 0x00..)\n\t1: Pack[0](ID)\n\t2: Pack[1](UID)\n\t3: Ret\n}\n\npublic uid_as_inner(Arg0: &UID): &ID {\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: ImmBorrowField[1](UID.id: ID)\n\t2: Ret\n}\n\npublic uid_to_inner(Arg0: &UID): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: ImmBorrowField[1](UID.id: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic uid_to_bytes(Arg0: &UID): vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: ImmBorrowField[1](UID.id: ID)\n\t2: ImmBorrowField[0](ID.bytes: address)\n\t3: Call bcs::to_bytes<address>(&address): vector<u8>\n\t4: Ret\n}\n\npublic uid_to_address(Arg0: &UID): address {\nB0:\n\t0: MoveLoc[0](Arg0: &UID)\n\t1: ImmBorrowField[1](UID.id: ID)\n\t2: ImmBorrowField[0](ID.bytes: address)\n\t3: ReadRef\n\t4: Ret\n}\n\npublic new(Arg0: &mut TxContext): UID {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call tx_context::fresh_object_address(&mut TxContext): address\n\t2: Pack[0](ID)\n\t3: Pack[1](UID)\n\t4: Ret\n}\n\npublic delete(Arg0: UID) {\nB0:\n\t0: MoveLoc[0](Arg0: UID)\n\t1: Unpack[1](UID)\n\t2: Unpack[0](ID)\n\t3: Call delete_impl(address)\n\t4: Ret\n}\n\npublic id<Ty0: key>(Arg0: &Ty0): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &Ty0)\n\t1: Call borrow_uid<Ty0>(&Ty0): &UID\n\t2: ImmBorrowField[1](UID.id: ID)\n\t3: ReadRef\n\t4: Ret\n}\n\npublic borrow_id<Ty0: key>(Arg0: &Ty0): &ID {\nB0:\n\t0: MoveLoc[0](Arg0: &Ty0)\n\t1: Call borrow_uid<Ty0>(&Ty0): &UID\n\t2: ImmBorrowField[1](UID.id: ID)\n\t3: Ret\n}\n\npublic id_bytes<Ty0: key>(Arg0: &Ty0): vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &Ty0)\n\t1: Call borrow_uid<Ty0>(&Ty0): &UID\n\t2: ImmBorrowField[1](UID.id: ID)\n\t3: Call bcs::to_bytes<ID>(&ID): vector<u8>\n\t4: Ret\n}\n\npublic id_address<Ty0: key>(Arg0: &Ty0): address {\nB0:\n\t0: MoveLoc[0](Arg0: &Ty0)\n\t1: Call borrow_uid<Ty0>(&Ty0): &UID\n\t2: ImmBorrowField[1](UID.id: ID)\n\t3: ImmBorrowField[0](ID.bytes: address)\n\t4: ReadRef\n\t5: Ret\n}\n\nnative borrow_uid<Ty0: key>(Arg0: &Ty0): &UID;\n\npublic(friend) new_uid_from_hash(Arg0: address): UID {\nB0:\n\t0: CopyLoc[0](Arg0: address)\n\t1: Call record_new_uid(address)\n\t2: MoveLoc[0](Arg0: address)\n\t3: Pack[0](ID)\n\t4: Pack[1](UID)\n\t5: Ret\n}\n\nnative delete_impl(Arg0: address);\n\nnative record_new_uid(Arg0: address);\n\nConstants [\n\t0 => address: 0x0000000000000000000000000000000000000000000000000000000000000005\n\t1 => address: 0x0000000000000000000000000000000000000000000000000000000000000006\n\t2 => address: 0x0000000000000000000000000000000000000000000000000000000000000007\n\t3 => address: 0x0000000000000000000000000000000000000000000000000000000000000008\n\t4 => address: 0x0000000000000000000000000000000000000000000000000000000000000403\n\t5 => address: 0x0000000000000000000000000000000000000000000000000000000000000acc\n\t6 => address: 0x0000000000000000000000000000000000000000000000000000000000000009\n\t7 => address: 0x000000000000000000000000000000000000000000000000000000000000000c\n\t8 => u64: 0\n\t9 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","object_bag":"// Move bytecode v6\nmodule 2.object_bag {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_object_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct ObjectBag has store, key {\n\tid: UID,\n\tsize: u64\n}\n\npublic new(Arg0: &mut TxContext): ObjectBag {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: LdU64(0)\n\t3: Pack[0](ObjectBag)\n\t4: Ret\n}\n\npublic add<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut ObjectBag, Arg1: Ty0, Arg2: Ty1) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut ObjectBag)\n\t1: MutBorrowField[0](ObjectBag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: MoveLoc[2](Arg2: Ty1)\n\t4: Call dynamic_object_field::add<Ty0, Ty1>(&mut UID, Ty0, Ty1)\n\t5: CopyLoc[0](Arg0: &mut ObjectBag)\n\t6: ImmBorrowField[1](ObjectBag.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Add\n\t10: MoveLoc[0](Arg0: &mut ObjectBag)\n\t11: MutBorrowField[1](ObjectBag.size: u64)\n\t12: WriteRef\n\t13: Ret\n}\n\npublic borrow<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &ObjectBag, Arg1: Ty0): &Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectBag)\n\t1: ImmBorrowField[0](ObjectBag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::borrow<Ty0, Ty1>(&UID, Ty0): &Ty1\n\t4: Ret\n}\n\npublic borrow_mut<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut ObjectBag, Arg1: Ty0): &mut Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut ObjectBag)\n\t1: MutBorrowField[0](ObjectBag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::borrow_mut<Ty0, Ty1>(&mut UID, Ty0): &mut Ty1\n\t4: Ret\n}\n\npublic remove<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut ObjectBag, Arg1: Ty0): Ty1 {\nL2:\tloc0: Ty1\nB0:\n\t0: CopyLoc[0](Arg0: &mut ObjectBag)\n\t1: MutBorrowField[0](ObjectBag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::remove<Ty0, Ty1>(&mut UID, Ty0): Ty1\n\t4: StLoc[2](loc0: Ty1)\n\t5: CopyLoc[0](Arg0: &mut ObjectBag)\n\t6: ImmBorrowField[1](ObjectBag.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Sub\n\t10: MoveLoc[0](Arg0: &mut ObjectBag)\n\t11: MutBorrowField[1](ObjectBag.size: u64)\n\t12: WriteRef\n\t13: MoveLoc[2](loc0: Ty1)\n\t14: Ret\n}\n\npublic contains<Ty0: copy + drop + store>(Arg0: &ObjectBag, Arg1: Ty0): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectBag)\n\t1: ImmBorrowField[0](ObjectBag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::exists_<Ty0>(&UID, Ty0): bool\n\t4: Ret\n}\n\npublic contains_with_type<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &ObjectBag, Arg1: Ty0): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectBag)\n\t1: ImmBorrowField[0](ObjectBag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::exists_with_type<Ty0, Ty1>(&UID, Ty0): bool\n\t4: Ret\n}\n\npublic length(Arg0: &ObjectBag): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectBag)\n\t1: ImmBorrowField[1](ObjectBag.size: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic is_empty(Arg0: &ObjectBag): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectBag)\n\t1: ImmBorrowField[1](ObjectBag.size: u64)\n\t2: ReadRef\n\t3: LdU64(0)\n\t4: Eq\n\t5: Ret\n}\n\npublic destroy_empty(Arg0: ObjectBag) {\nL1:\tloc0: UID\nL2:\tloc1: u64\nB0:\n\t0: MoveLoc[0](Arg0: ObjectBag)\n\t1: Unpack[0](ObjectBag)\n\t2: StLoc[2](loc1: u64)\n\t3: StLoc[1](loc0: UID)\n\t4: MoveLoc[2](loc1: u64)\n\t5: LdU64(0)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(11)\nB2:\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[1](loc0: UID)\n\t12: Call object::delete(UID)\n\t13: Ret\n}\n\npublic value_id<Ty0: copy + drop + store>(Arg0: &ObjectBag, Arg1: Ty0): Option<ID> {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectBag)\n\t1: ImmBorrowField[0](ObjectBag.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::id<Ty0>(&UID, Ty0): Option<ID>\n\t4: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n","object_table":"// Move bytecode v6\nmodule 2.object_table {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_object_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct ObjectTable<phantom Ty0: copy + drop + store, phantom Ty1: store + key> has store, key {\n\tid: UID,\n\tsize: u64\n}\n\npublic new<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut TxContext): ObjectTable<Ty0, Ty1> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: LdU64(0)\n\t3: PackGeneric[0](ObjectTable<Ty0, Ty1>)\n\t4: Ret\n}\n\npublic add<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut ObjectTable<Ty0, Ty1>, Arg1: Ty0, Arg2: Ty1) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut ObjectTable<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[0](ObjectTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: MoveLoc[2](Arg2: Ty1)\n\t4: Call dynamic_object_field::add<Ty0, Ty1>(&mut UID, Ty0, Ty1)\n\t5: CopyLoc[0](Arg0: &mut ObjectTable<Ty0, Ty1>)\n\t6: ImmBorrowFieldGeneric[1](ObjectTable.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Add\n\t10: MoveLoc[0](Arg0: &mut ObjectTable<Ty0, Ty1>)\n\t11: MutBorrowFieldGeneric[1](ObjectTable.size: u64)\n\t12: WriteRef\n\t13: Ret\n}\n\npublic borrow<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &ObjectTable<Ty0, Ty1>, Arg1: Ty0): &Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](ObjectTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::borrow<Ty0, Ty1>(&UID, Ty0): &Ty1\n\t4: Ret\n}\n\npublic borrow_mut<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut ObjectTable<Ty0, Ty1>, Arg1: Ty0): &mut Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut ObjectTable<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[0](ObjectTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::borrow_mut<Ty0, Ty1>(&mut UID, Ty0): &mut Ty1\n\t4: Ret\n}\n\npublic remove<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &mut ObjectTable<Ty0, Ty1>, Arg1: Ty0): Ty1 {\nL2:\tloc0: Ty1\nB0:\n\t0: CopyLoc[0](Arg0: &mut ObjectTable<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[0](ObjectTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::remove<Ty0, Ty1>(&mut UID, Ty0): Ty1\n\t4: StLoc[2](loc0: Ty1)\n\t5: CopyLoc[0](Arg0: &mut ObjectTable<Ty0, Ty1>)\n\t6: ImmBorrowFieldGeneric[1](ObjectTable.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Sub\n\t10: MoveLoc[0](Arg0: &mut ObjectTable<Ty0, Ty1>)\n\t11: MutBorrowFieldGeneric[1](ObjectTable.size: u64)\n\t12: WriteRef\n\t13: MoveLoc[2](loc0: Ty1)\n\t14: Ret\n}\n\npublic contains<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &ObjectTable<Ty0, Ty1>, Arg1: Ty0): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](ObjectTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::exists_<Ty0>(&UID, Ty0): bool\n\t4: Ret\n}\n\npublic length<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &ObjectTable<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[1](ObjectTable.size: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic is_empty<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &ObjectTable<Ty0, Ty1>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[1](ObjectTable.size: u64)\n\t2: ReadRef\n\t3: LdU64(0)\n\t4: Eq\n\t5: Ret\n}\n\npublic destroy_empty<Ty0: copy + drop + store, Ty1: store + key>(Arg0: ObjectTable<Ty0, Ty1>) {\nL1:\tloc0: UID\nL2:\tloc1: u64\nB0:\n\t0: MoveLoc[0](Arg0: ObjectTable<Ty0, Ty1>)\n\t1: UnpackGeneric[0](ObjectTable<Ty0, Ty1>)\n\t2: StLoc[2](loc1: u64)\n\t3: StLoc[1](loc0: UID)\n\t4: MoveLoc[2](loc1: u64)\n\t5: LdU64(0)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(11)\nB2:\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[1](loc0: UID)\n\t12: Call object::delete(UID)\n\t13: Ret\n}\n\npublic value_id<Ty0: copy + drop + store, Ty1: store + key>(Arg0: &ObjectTable<Ty0, Ty1>, Arg1: Ty0): Option<ID> {\nB0:\n\t0: MoveLoc[0](Arg0: &ObjectTable<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](ObjectTable.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_object_field::id<Ty0>(&UID, Ty0): Option<ID>\n\t4: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n","package":"// Move bytecode v6\nmodule 2.package {\nuse 0000000000000000000000000000000000000000000000000000000000000001::ascii;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::types;\n\nstruct Publisher has store, key {\n\tid: UID,\n\tpackage: String,\n\tmodule_name: String\n}\n\nstruct UpgradeCap has store, key {\n\tid: UID,\n\tpackage: ID,\n\tversion: u64,\n\tpolicy: u8\n}\n\nstruct UpgradeTicket {\n\tcap: ID,\n\tpackage: ID,\n\tpolicy: u8,\n\tdigest: vector<u8>\n}\n\nstruct UpgradeReceipt {\n\tcap: ID,\n\tpackage: ID\n}\n\npublic claim<Ty0: drop>(Arg0: Ty0, Arg1: &mut TxContext): Publisher {\nL2:\tloc0: TypeName\nB0:\n\t0: ImmBorrowLoc[0](Arg0: Ty0)\n\t1: Call types::is_one_time_witness<Ty0>(&Ty0): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(8)\nB2:\n\t4: MoveLoc[1](Arg1: &mut TxContext)\n\t5: Pop\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: Call type_name::with_original_ids<Ty0>(): TypeName\n\t9: StLoc[2](loc0: TypeName)\n\t10: MoveLoc[1](Arg1: &mut TxContext)\n\t11: Call object::new(&mut TxContext): UID\n\t12: ImmBorrowLoc[2](loc0: TypeName)\n\t13: Call type_name::address_string(&TypeName): String\n\t14: ImmBorrowLoc[2](loc0: TypeName)\n\t15: Call type_name::module_string(&TypeName): String\n\t16: Pack[0](Publisher)\n\t17: Ret\n}\n\npublic claim_and_keep<Ty0: drop>(Arg0: Ty0, Arg1: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: CopyLoc[1](Arg1: &mut TxContext)\n\t2: Call claim<Ty0>(Ty0, &mut TxContext): Publisher\n\t3: MoveLoc[1](Arg1: &mut TxContext)\n\t4: FreezeRef\n\t5: Call tx_context::sender(&TxContext): address\n\t6: Call transfer::public_transfer<Publisher>(Publisher, address)\n\t7: Ret\n}\n\npublic burn_publisher(Arg0: Publisher) {\nB0:\n\t0: MoveLoc[0](Arg0: Publisher)\n\t1: Unpack[0](Publisher)\n\t2: Pop\n\t3: Pop\n\t4: Call object::delete(UID)\n\t5: Ret\n}\n\npublic from_package<Ty0>(Arg0: &Publisher): bool {\nL1:\tloc0: TypeName\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: StLoc[1](loc0: TypeName)\n\t2: ImmBorrowLoc[1](loc0: TypeName)\n\t3: Call type_name::address_string(&TypeName): String\n\t4: MoveLoc[0](Arg0: &Publisher)\n\t5: ImmBorrowField[0](Publisher.package: String)\n\t6: ReadRef\n\t7: Eq\n\t8: Ret\n}\n\npublic from_module<Ty0>(Arg0: &Publisher): bool {\nL1:\tloc0: bool\nL2:\tloc1: TypeName\nB0:\n\t0: Call type_name::with_original_ids<Ty0>(): TypeName\n\t1: StLoc[2](loc1: TypeName)\n\t2: ImmBorrowLoc[2](loc1: TypeName)\n\t3: Call type_name::address_string(&TypeName): String\n\t4: CopyLoc[0](Arg0: &Publisher)\n\t5: ImmBorrowField[0](Publisher.package: String)\n\t6: ReadRef\n\t7: Eq\n\t8: BrFalse(17)\nB1:\n\t9: ImmBorrowLoc[2](loc1: TypeName)\n\t10: Call type_name::module_string(&TypeName): String\n\t11: MoveLoc[0](Arg0: &Publisher)\n\t12: ImmBorrowField[1](Publisher.module_name: String)\n\t13: ReadRef\n\t14: Eq\n\t15: StLoc[1](loc0: bool)\n\t16: Branch(21)\nB2:\n\t17: MoveLoc[0](Arg0: &Publisher)\n\t18: Pop\n\t19: LdFalse\n\t20: StLoc[1](loc0: bool)\nB3:\n\t21: MoveLoc[1](loc0: bool)\n\t22: Ret\n}\n\npublic published_module(Arg0: &Publisher): &String {\nB0:\n\t0: MoveLoc[0](Arg0: &Publisher)\n\t1: ImmBorrowField[1](Publisher.module_name: String)\n\t2: Ret\n}\n\npublic published_package(Arg0: &Publisher): &String {\nB0:\n\t0: MoveLoc[0](Arg0: &Publisher)\n\t1: ImmBorrowField[0](Publisher.package: String)\n\t2: Ret\n}\n\npublic upgrade_package(Arg0: &UpgradeCap): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeCap)\n\t1: ImmBorrowField[2](UpgradeCap.package: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic version(Arg0: &UpgradeCap): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeCap)\n\t1: ImmBorrowField[3](UpgradeCap.version: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic upgrade_policy(Arg0: &UpgradeCap): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeCap)\n\t1: ImmBorrowField[4](UpgradeCap.policy: u8)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic ticket_package(Arg0: &UpgradeTicket): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeTicket)\n\t1: ImmBorrowField[5](UpgradeTicket.package: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic ticket_policy(Arg0: &UpgradeTicket): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeTicket)\n\t1: ImmBorrowField[6](UpgradeTicket.policy: u8)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic receipt_cap(Arg0: &UpgradeReceipt): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeReceipt)\n\t1: ImmBorrowField[7](UpgradeReceipt.cap: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic receipt_package(Arg0: &UpgradeReceipt): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeReceipt)\n\t1: ImmBorrowField[8](UpgradeReceipt.package: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic ticket_digest(Arg0: &UpgradeTicket): &vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &UpgradeTicket)\n\t1: ImmBorrowField[9](UpgradeTicket.digest: vector<u8>)\n\t2: Ret\n}\n\npublic compatible_policy(): u8 {\nB0:\n\t0: LdConst[5](u8: 0)\n\t1: Ret\n}\n\npublic additive_policy(): u8 {\nB0:\n\t0: LdConst[6](u8: 128)\n\t1: Ret\n}\n\npublic dep_only_policy(): u8 {\nB0:\n\t0: LdConst[7](u8: 192)\n\t1: Ret\n}\n\nentry public only_additive_upgrades(Arg0: &mut UpgradeCap) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t1: LdConst[6](u8: 128)\n\t2: Call restrict(&mut UpgradeCap, u8)\n\t3: Ret\n}\n\nentry public only_dep_upgrades(Arg0: &mut UpgradeCap) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t1: LdConst[7](u8: 192)\n\t2: Call restrict(&mut UpgradeCap, u8)\n\t3: Ret\n}\n\nentry public make_immutable(Arg0: UpgradeCap) {\nB0:\n\t0: MoveLoc[0](Arg0: UpgradeCap)\n\t1: Unpack[1](UpgradeCap)\n\t2: Pop\n\t3: Pop\n\t4: Pop\n\t5: Call object::delete(UID)\n\t6: Ret\n}\n\npublic authorize_upgrade(Arg0: &mut UpgradeCap, Arg1: u8, Arg2: vector<u8>): UpgradeTicket {\nL3:\tloc0: ID\nL4:\tloc1: ID\nB0:\n\t0: LdConst[8](address: 0x00..)\n\t1: Call object::id_from_address(address): ID\n\t2: StLoc[3](loc0: ID)\n\t3: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t4: ImmBorrowField[2](UpgradeCap.package: ID)\n\t5: ReadRef\n\t6: CopyLoc[3](loc0: ID)\n\t7: Neq\n\t8: BrFalse(10)\nB1:\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t11: Pop\n\t12: LdConst[2](u64: 2)\n\t13: Abort\nB3:\n\t14: CopyLoc[1](Arg1: u8)\n\t15: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t16: ImmBorrowField[4](UpgradeCap.policy: u8)\n\t17: ReadRef\n\t18: Ge\n\t19: BrFalse(21)\nB4:\n\t20: Branch(25)\nB5:\n\t21: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t22: Pop\n\t23: LdConst[1](u64: 1)\n\t24: Abort\nB6:\n\t25: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t26: ImmBorrowField[2](UpgradeCap.package: ID)\n\t27: ReadRef\n\t28: StLoc[4](loc1: ID)\n\t29: MoveLoc[3](loc0: ID)\n\t30: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t31: MutBorrowField[2](UpgradeCap.package: ID)\n\t32: WriteRef\n\t33: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t34: FreezeRef\n\t35: Call object::id<UpgradeCap>(&UpgradeCap): ID\n\t36: MoveLoc[4](loc1: ID)\n\t37: MoveLoc[1](Arg1: u8)\n\t38: MoveLoc[2](Arg2: vector<u8>)\n\t39: Pack[2](UpgradeTicket)\n\t40: Ret\n}\n\npublic commit_upgrade(Arg0: &mut UpgradeCap, Arg1: UpgradeReceipt) {\nL2:\tloc0: ID\nL3:\tloc1: ID\nB0:\n\t0: MoveLoc[1](Arg1: UpgradeReceipt)\n\t1: Unpack[3](UpgradeReceipt)\n\t2: StLoc[3](loc1: ID)\n\t3: StLoc[2](loc0: ID)\n\t4: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t5: FreezeRef\n\t6: Call object::id<UpgradeCap>(&UpgradeCap): ID\n\t7: MoveLoc[2](loc0: ID)\n\t8: Eq\n\t9: BrFalse(11)\nB1:\n\t10: Branch(15)\nB2:\n\t11: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t12: Pop\n\t13: LdConst[4](u64: 4)\n\t14: Abort\nB3:\n\t15: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t16: ImmBorrowField[2](UpgradeCap.package: ID)\n\t17: Call object::id_to_address(&ID): address\n\t18: LdConst[8](address: 0x00..)\n\t19: Eq\n\t20: BrFalse(22)\nB4:\n\t21: Branch(26)\nB5:\n\t22: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t23: Pop\n\t24: LdConst[3](u64: 3)\n\t25: Abort\nB6:\n\t26: MoveLoc[3](loc1: ID)\n\t27: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t28: MutBorrowField[2](UpgradeCap.package: ID)\n\t29: WriteRef\n\t30: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t31: ImmBorrowField[3](UpgradeCap.version: u64)\n\t32: ReadRef\n\t33: LdU64(1)\n\t34: Add\n\t35: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t36: MutBorrowField[3](UpgradeCap.version: u64)\n\t37: WriteRef\n\t38: Ret\n}\n\nrestrict(Arg0: &mut UpgradeCap, Arg1: u8) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut UpgradeCap)\n\t1: ImmBorrowField[4](UpgradeCap.policy: u8)\n\t2: ReadRef\n\t3: CopyLoc[1](Arg1: u8)\n\t4: Le\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t8: Pop\n\t9: LdConst[1](u64: 1)\n\t10: Abort\nB3:\n\t11: MoveLoc[1](Arg1: u8)\n\t12: MoveLoc[0](Arg0: &mut UpgradeCap)\n\t13: MutBorrowField[4](UpgradeCap.policy: u8)\n\t14: WriteRef\n\t15: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u8: 0\n\t6 => u8: 128\n\t7 => u8: 192\n\t8 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n]\n}\n","party":"// Move bytecode v6\nmodule 2.party {\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::vec_map;\n\nstruct Party has copy, drop {\n\tdefault: Permissions,\n\tmembers: VecMap<address, Permissions>\n}\n\nstruct Permissions has copy, drop {\n\tpos0: u64\n}\n\npublic single_owner(Arg0: address): Party {\nL1:\tloc0: Party\nB0:\n\t0: Call empty(): Party\n\t1: StLoc[1](loc0: Party)\n\t2: MutBorrowLoc[1](loc0: Party)\n\t3: MoveLoc[0](Arg0: address)\n\t4: LdConst[5](u64: 15)\n\t5: Pack[1](Permissions)\n\t6: Call set_permissions(&mut Party, address, Permissions)\n\t7: MoveLoc[1](loc0: Party)\n\t8: Ret\n}\n\nempty(): Party {\nB0:\n\t0: LdConst[4](u64: 0)\n\t1: Pack[1](Permissions)\n\t2: Call vec_map::empty<address, Permissions>(): VecMap<address, Permissions>\n\t3: Pack[0](Party)\n\t4: Ret\n}\n\nset_permissions(Arg0: &mut Party, Arg1: address, Arg2: Permissions) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Party)\n\t1: ImmBorrowField[0](Party.members: VecMap<address, Permissions>)\n\t2: ImmBorrowLoc[1](Arg1: address)\n\t3: Call vec_map::contains<address, Permissions>(&VecMap<address, Permissions>, &address): bool\n\t4: BrFalse(11)\nB1:\n\t5: CopyLoc[0](Arg0: &mut Party)\n\t6: MutBorrowField[0](Party.members: VecMap<address, Permissions>)\n\t7: ImmBorrowLoc[1](Arg1: address)\n\t8: Call vec_map::remove<address, Permissions>(&mut VecMap<address, Permissions>, &address): address * Permissions\n\t9: Pop\n\t10: Pop\nB2:\n\t11: MoveLoc[0](Arg0: &mut Party)\n\t12: MutBorrowField[0](Party.members: VecMap<address, Permissions>)\n\t13: MoveLoc[1](Arg1: address)\n\t14: MoveLoc[2](Arg2: Permissions)\n\t15: Call vec_map::insert<address, Permissions>(&mut VecMap<address, Permissions>, address, Permissions)\n\t16: Ret\n}\n\npublic(friend) is_single_owner(Arg0: &Party): bool {\nL1:\tloc0: bool\nL2:\tloc1: &Permissions\nB0:\n\t0: CopyLoc[0](Arg0: &Party)\n\t1: ImmBorrowField[1](Party.default: Permissions)\n\t2: ImmBorrowField[2](Permissions.pos0: u64)\n\t3: ReadRef\n\t4: LdConst[4](u64: 0)\n\t5: Eq\n\t6: BrFalse(31)\nB1:\n\t7: CopyLoc[0](Arg0: &Party)\n\t8: ImmBorrowField[0](Party.members: VecMap<address, Permissions>)\n\t9: Call vec_map::length<address, Permissions>(&VecMap<address, Permissions>): u64\n\t10: LdU64(1)\n\t11: Eq\n\t12: BrFalse(26)\nB2:\n\t13: MoveLoc[0](Arg0: &Party)\n\t14: ImmBorrowField[0](Party.members: VecMap<address, Permissions>)\n\t15: LdU64(0)\n\t16: Call vec_map::get_entry_by_idx<address, Permissions>(&VecMap<address, Permissions>, u64): &address * &Permissions\n\t17: StLoc[2](loc1: &Permissions)\n\t18: Pop\n\t19: MoveLoc[2](loc1: &Permissions)\n\t20: ImmBorrowField[2](Permissions.pos0: u64)\n\t21: ReadRef\n\t22: LdConst[5](u64: 15)\n\t23: Eq\n\t24: StLoc[1](loc0: bool)\n\t25: Branch(35)\nB3:\n\t26: MoveLoc[0](Arg0: &Party)\n\t27: Pop\n\t28: LdFalse\n\t29: StLoc[1](loc0: bool)\n\t30: Branch(35)\nB4:\n\t31: MoveLoc[0](Arg0: &Party)\n\t32: Pop\n\t33: LdFalse\n\t34: StLoc[1](loc0: bool)\nB5:\n\t35: MoveLoc[1](loc0: bool)\n\t36: Ret\n}\n\npublic(friend) into_native(Arg0: Party): u64 * vector<address> * vector<u64> {\nL1:\tloc0: u64\nL2:\tloc1: u64\nL3:\tloc2: &mut vector<u64>\nL4:\tloc3: vector<address>\nL5:\tloc4: Permissions\nL6:\tloc5: Permissions\nL7:\tloc6: u64\nL8:\tloc7: VecMap<address, Permissions>\nL9:\tloc8: vector<Permissions>\nL10:\tloc9: vector<u64>\nL11:\tloc10: vector<u64>\nL12:\tloc11: u64\nL13:\tloc12: vector<Permissions>\nL14:\tloc13: vector<Permissions>\nB0:\n\t0: MoveLoc[0](Arg0: Party)\n\t1: Unpack[0](Party)\n\t2: StLoc[8](loc7: VecMap<address, Permissions>)\n\t3: StLoc[5](loc4: Permissions)\n\t4: MoveLoc[8](loc7: VecMap<address, Permissions>)\n\t5: Call vec_map::into_keys_values<address, Permissions>(VecMap<address, Permissions>): vector<address> * vector<Permissions>\n\t6: StLoc[9](loc8: vector<Permissions>)\n\t7: StLoc[4](loc3: vector<address>)\n\t8: MoveLoc[9](loc8: vector<Permissions>)\n\t9: StLoc[13](loc12: vector<Permissions>)\n\t10: LdConst[6](vector<u64>: 00)\n\t11: StLoc[11](loc10: vector<u64>)\n\t12: MoveLoc[13](loc12: vector<Permissions>)\n\t13: StLoc[14](loc13: vector<Permissions>)\n\t14: MutBorrowLoc[14](loc13: vector<Permissions>)\n\t15: Call vector::reverse<Permissions>(&mut vector<Permissions>)\n\t16: ImmBorrowLoc[14](loc13: vector<Permissions>)\n\t17: VecLen(20)\n\t18: StLoc[1](loc0: u64)\n\t19: LdU64(0)\n\t20: StLoc[7](loc6: u64)\n\t21: MoveLoc[1](loc0: u64)\n\t22: StLoc[12](loc11: u64)\nB1:\n\t23: CopyLoc[7](loc6: u64)\n\t24: CopyLoc[12](loc11: u64)\n\t25: Lt\n\t26: BrFalse(45)\nB2:\n\t27: CopyLoc[7](loc6: u64)\n\t28: Pop\n\t29: MutBorrowLoc[14](loc13: vector<Permissions>)\n\t30: VecPopBack(20)\n\t31: StLoc[6](loc5: Permissions)\n\t32: MutBorrowLoc[11](loc10: vector<u64>)\n\t33: StLoc[3](loc2: &mut vector<u64>)\n\t34: MoveLoc[6](loc5: Permissions)\n\t35: Unpack[1](Permissions)\n\t36: StLoc[2](loc1: u64)\n\t37: MoveLoc[3](loc2: &mut vector<u64>)\n\t38: MoveLoc[2](loc1: u64)\n\t39: VecPushBack(15)\n\t40: MoveLoc[7](loc6: u64)\n\t41: LdU64(1)\n\t42: Add\n\t43: StLoc[7](loc6: u64)\n\t44: Branch(23)\nB3:\n\t45: MoveLoc[14](loc13: vector<Permissions>)\n\t46: VecUnpack(20, 0)\n\t47: MoveLoc[11](loc10: vector<u64>)\n\t48: StLoc[10](loc9: vector<u64>)\n\t49: ImmBorrowLoc[5](loc4: Permissions)\n\t50: ImmBorrowField[2](Permissions.pos0: u64)\n\t51: ReadRef\n\t52: MoveLoc[4](loc3: vector<address>)\n\t53: MoveLoc[10](loc9: vector<u64>)\n\t54: Ret\n}\n\nConstants [\n\t0 => u8: 1\n\t1 => u8: 2\n\t2 => u8: 4\n\t3 => u8: 8\n\t4 => u64: 0\n\t5 => u64: 15\n\t6 => vector<u64>: 00\n]\n}\n","pay":"// Move bytecode v6\nmodule 2.pay {\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\npublic keep<Ty0>(Arg0: Coin<Ty0>, Arg1: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: Coin<Ty0>)\n\t1: MoveLoc[1](Arg1: &TxContext)\n\t2: Call tx_context::sender(&TxContext): address\n\t3: Call transfer::public_transfer<Coin<Ty0>>(Coin<Ty0>, address)\n\t4: Ret\n}\n\nentry public split<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: u64, Arg2: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: CopyLoc[2](Arg2: &mut TxContext)\n\t3: Call coin::split<Ty0>(&mut Coin<Ty0>, u64, &mut TxContext): Coin<Ty0>\n\t4: MoveLoc[2](Arg2: &mut TxContext)\n\t5: FreezeRef\n\t6: Call keep<Ty0>(Coin<Ty0>, &TxContext)\n\t7: Ret\n}\n\nentry public split_vec<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: vector<u64>, Arg2: &mut TxContext) {\nL3:\tloc0: u64\nL4:\tloc1: u64\nL5:\tloc2: u64\nL6:\tloc3: u64\nL7:\tloc4: vector<u64>\nB0:\n\t0: MoveLoc[1](Arg1: vector<u64>)\n\t1: StLoc[7](loc4: vector<u64>)\n\t2: MutBorrowLoc[7](loc4: vector<u64>)\n\t3: Call vector::reverse<u64>(&mut vector<u64>)\n\t4: ImmBorrowLoc[7](loc4: vector<u64>)\n\t5: VecLen(14)\n\t6: StLoc[3](loc0: u64)\n\t7: LdU64(0)\n\t8: StLoc[5](loc2: u64)\n\t9: MoveLoc[3](loc0: u64)\n\t10: StLoc[6](loc3: u64)\nB1:\n\t11: CopyLoc[5](loc2: u64)\n\t12: CopyLoc[6](loc3: u64)\n\t13: Lt\n\t14: BrFalse(29)\nB2:\n\t15: CopyLoc[5](loc2: u64)\n\t16: Pop\n\t17: MutBorrowLoc[7](loc4: vector<u64>)\n\t18: VecPopBack(14)\n\t19: StLoc[4](loc1: u64)\n\t20: CopyLoc[0](Arg0: &mut Coin<Ty0>)\n\t21: MoveLoc[4](loc1: u64)\n\t22: CopyLoc[2](Arg2: &mut TxContext)\n\t23: Call split<Ty0>(&mut Coin<Ty0>, u64, &mut TxContext)\n\t24: MoveLoc[5](loc2: u64)\n\t25: LdU64(1)\n\t26: Add\n\t27: StLoc[5](loc2: u64)\n\t28: Branch(11)\nB3:\n\t29: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t30: Pop\n\t31: MoveLoc[2](Arg2: &mut TxContext)\n\t32: Pop\n\t33: MoveLoc[7](loc4: vector<u64>)\n\t34: VecUnpack(14, 0)\n\t35: Ret\n}\n\nentry public split_and_transfer<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: u64, Arg2: address, Arg3: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: MoveLoc[3](Arg3: &mut TxContext)\n\t3: Call coin::split<Ty0>(&mut Coin<Ty0>, u64, &mut TxContext): Coin<Ty0>\n\t4: MoveLoc[2](Arg2: address)\n\t5: Call transfer::public_transfer<Coin<Ty0>>(Coin<Ty0>, address)\n\t6: Ret\n}\n\nentry public divide_and_keep<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: u64, Arg2: &mut TxContext) {\nL3:\tloc0: u64\nL4:\tloc1: u64\nL5:\tloc2: u64\nL6:\tloc3: vector<Coin<Ty0>>\nB0:\n\t0: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: CopyLoc[2](Arg2: &mut TxContext)\n\t3: Call coin::divide_into_n<Ty0>(&mut Coin<Ty0>, u64, &mut TxContext): vector<Coin<Ty0>>\n\t4: StLoc[6](loc3: vector<Coin<Ty0>>)\n\t5: ImmBorrowLoc[6](loc3: vector<Coin<Ty0>>)\n\t6: VecLen(10)\n\t7: StLoc[3](loc0: u64)\n\t8: LdU64(0)\n\t9: StLoc[4](loc1: u64)\n\t10: MoveLoc[3](loc0: u64)\n\t11: StLoc[5](loc2: u64)\nB1:\n\t12: CopyLoc[4](loc1: u64)\n\t13: CopyLoc[5](loc2: u64)\n\t14: Lt\n\t15: BrFalse(29)\nB2:\n\t16: CopyLoc[4](loc1: u64)\n\t17: Pop\n\t18: MutBorrowLoc[6](loc3: vector<Coin<Ty0>>)\n\t19: VecPopBack(10)\n\t20: CopyLoc[2](Arg2: &mut TxContext)\n\t21: FreezeRef\n\t22: Call tx_context::sender(&TxContext): address\n\t23: Call transfer::public_transfer<Coin<Ty0>>(Coin<Ty0>, address)\n\t24: MoveLoc[4](loc1: u64)\n\t25: LdU64(1)\n\t26: Add\n\t27: StLoc[4](loc1: u64)\n\t28: Branch(12)\nB3:\n\t29: MoveLoc[2](Arg2: &mut TxContext)\n\t30: Pop\n\t31: MoveLoc[6](loc3: vector<Coin<Ty0>>)\n\t32: VecUnpack(10, 0)\n\t33: Ret\n}\n\nentry public join<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: Coin<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t1: MoveLoc[1](Arg1: Coin<Ty0>)\n\t2: Call coin::join<Ty0>(&mut Coin<Ty0>, Coin<Ty0>)\n\t3: Ret\n}\n\nentry public join_vec<Ty0>(Arg0: &mut Coin<Ty0>, Arg1: vector<Coin<Ty0>>) {\nL2:\tloc0: u64\nL3:\tloc1: Coin<Ty0>\nL4:\tloc2: u64\nL5:\tloc3: u64\nL6:\tloc4: vector<Coin<Ty0>>\nB0:\n\t0: MoveLoc[1](Arg1: vector<Coin<Ty0>>)\n\t1: StLoc[6](loc4: vector<Coin<Ty0>>)\n\t2: ImmBorrowLoc[6](loc4: vector<Coin<Ty0>>)\n\t3: VecLen(10)\n\t4: StLoc[2](loc0: u64)\n\t5: LdU64(0)\n\t6: StLoc[4](loc2: u64)\n\t7: MoveLoc[2](loc0: u64)\n\t8: StLoc[5](loc3: u64)\nB1:\n\t9: CopyLoc[4](loc2: u64)\n\t10: CopyLoc[5](loc3: u64)\n\t11: Lt\n\t12: BrFalse(26)\nB2:\n\t13: CopyLoc[4](loc2: u64)\n\t14: Pop\n\t15: MutBorrowLoc[6](loc4: vector<Coin<Ty0>>)\n\t16: VecPopBack(10)\n\t17: StLoc[3](loc1: Coin<Ty0>)\n\t18: CopyLoc[0](Arg0: &mut Coin<Ty0>)\n\t19: MoveLoc[3](loc1: Coin<Ty0>)\n\t20: Call coin::join<Ty0>(&mut Coin<Ty0>, Coin<Ty0>)\n\t21: MoveLoc[4](loc2: u64)\n\t22: LdU64(1)\n\t23: Add\n\t24: StLoc[4](loc2: u64)\n\t25: Branch(9)\nB3:\n\t26: MoveLoc[0](Arg0: &mut Coin<Ty0>)\n\t27: Pop\n\t28: MoveLoc[6](loc4: vector<Coin<Ty0>>)\n\t29: VecUnpack(10, 0)\n\t30: Ret\n}\n\nentry public join_vec_and_transfer<Ty0>(Arg0: vector<Coin<Ty0>>, Arg1: address) {\nL2:\tloc0: Coin<Ty0>\nB0:\n\t0: ImmBorrowLoc[0](Arg0: vector<Coin<Ty0>>)\n\t1: VecLen(10)\n\t2: LdU64(0)\n\t3: Gt\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: MutBorrowLoc[0](Arg0: vector<Coin<Ty0>>)\n\t9: VecPopBack(10)\n\t10: StLoc[2](loc0: Coin<Ty0>)\n\t11: MutBorrowLoc[2](loc0: Coin<Ty0>)\n\t12: MoveLoc[0](Arg0: vector<Coin<Ty0>>)\n\t13: Call join_vec<Ty0>(&mut Coin<Ty0>, vector<Coin<Ty0>>)\n\t14: MoveLoc[2](loc0: Coin<Ty0>)\n\t15: MoveLoc[1](Arg1: address)\n\t16: Call transfer::public_transfer<Coin<Ty0>>(Coin<Ty0>, address)\n\t17: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n","poseidon":"// Move bytecode v6\nmodule 2.poseidon {\nuse 0000000000000000000000000000000000000000000000000000000000000002::bcs;\n\npublic poseidon_bn254(Arg0: &vector<u256>): u256 {\nL1:\tloc0: BCS\nL2:\tloc1: vector<vector<u8>>\nL3:\tloc2: u64\nL4:\tloc3: u64\nB0:\n\t0: LdU64(0)\n\t1: LdConst[3](vector<vector<u8>>: 00)\n\t2: CopyLoc[0](Arg0: &vector<u256>)\n\t3: VecLen(1)\n\t4: StLoc[4](loc3: u64)\n\t5: StLoc[2](loc1: vector<vector<u8>>)\n\t6: StLoc[3](loc2: u64)\n\t7: CopyLoc[4](loc3: u64)\n\t8: LdU64(0)\n\t9: Gt\n\t10: BrFalse(12)\nB1:\n\t11: Branch(16)\nB2:\n\t12: MoveLoc[0](Arg0: &vector<u256>)\n\t13: Pop\n\t14: LdConst[1](u64: 1)\n\t15: Abort\nB3:\n\t16: CopyLoc[3](loc2: u64)\n\t17: CopyLoc[4](loc3: u64)\n\t18: Lt\n\t19: BrFalse(43)\nB4:\n\t20: CopyLoc[0](Arg0: &vector<u256>)\n\t21: CopyLoc[3](loc2: u64)\n\t22: VecImmBorrow(1)\n\t23: ReadRef\n\t24: LdConst[2](u256: 2188..)\n\t25: Lt\n\t26: BrFalse(28)\nB5:\n\t27: Branch(32)\nB6:\n\t28: MoveLoc[0](Arg0: &vector<u256>)\n\t29: Pop\n\t30: LdConst[0](u64: 0)\n\t31: Abort\nB7:\n\t32: MutBorrowLoc[2](loc1: vector<vector<u8>>)\n\t33: CopyLoc[0](Arg0: &vector<u256>)\n\t34: CopyLoc[3](loc2: u64)\n\t35: VecImmBorrow(1)\n\t36: Call bcs::to_bytes<u256>(&u256): vector<u8>\n\t37: VecPushBack(3)\n\t38: MoveLoc[3](loc2: u64)\n\t39: LdU64(1)\n\t40: Add\n\t41: StLoc[3](loc2: u64)\n\t42: Branch(16)\nB8:\n\t43: MoveLoc[0](Arg0: &vector<u256>)\n\t44: Pop\n\t45: ImmBorrowLoc[2](loc1: vector<vector<u8>>)\n\t46: Call poseidon_bn254_internal(&vector<vector<u8>>): vector<u8>\n\t47: Call bcs::new(vector<u8>): BCS\n\t48: StLoc[1](loc0: BCS)\n\t49: MutBorrowLoc[1](loc0: BCS)\n\t50: Call bcs::peel_u256(&mut BCS): u256\n\t51: Ret\n}\n\nnative poseidon_bn254_internal(Arg0: &vector<vector<u8>>): vector<u8>;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u256: 21888242871839275222246405745257275088548364400416034343698204186575808495617\n\t3 => vector<vector<u8>>: 00\n]\n}\n","priority_queue":"// Move bytecode v6\nmodule 2.priority_queue {\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\n\nstruct PriorityQueue<Ty0: drop> has drop, store {\n\tentries: vector<Entry<Ty0>>\n}\n\nstruct Entry<Ty0: drop> has drop, store {\n\tpriority: u64,\n\tvalue: Ty0\n}\n\npublic new<Ty0: drop>(Arg0: vector<Entry<Ty0>>): PriorityQueue<Ty0> {\nL1:\tloc0: u64\nL2:\tloc1: u64\nB0:\n\t0: ImmBorrowLoc[0](Arg0: vector<Entry<Ty0>>)\n\t1: VecLen(6)\n\t2: StLoc[2](loc1: u64)\n\t3: CopyLoc[2](loc1: u64)\n\t4: LdU64(2)\n\t5: Div\n\t6: StLoc[1](loc0: u64)\nB1:\n\t7: CopyLoc[1](loc0: u64)\n\t8: LdU64(0)\n\t9: Gt\n\t10: BrFalse(21)\nB2:\n\t11: Branch(12)\nB3:\n\t12: MoveLoc[1](loc0: u64)\n\t13: LdU64(1)\n\t14: Sub\n\t15: StLoc[1](loc0: u64)\n\t16: MutBorrowLoc[0](Arg0: vector<Entry<Ty0>>)\n\t17: CopyLoc[2](loc1: u64)\n\t18: CopyLoc[1](loc0: u64)\n\t19: Call max_heapify_recursive<Ty0>(&mut vector<Entry<Ty0>>, u64, u64)\n\t20: Branch(7)\nB4:\n\t21: MoveLoc[0](Arg0: vector<Entry<Ty0>>)\n\t22: PackGeneric[0](PriorityQueue<Ty0>)\n\t23: Ret\n}\n\npublic pop_max<Ty0: drop>(Arg0: &mut PriorityQueue<Ty0>): u64 * Ty0 {\nL1:\tloc0: u64\nL2:\tloc1: u64\nL3:\tloc2: Ty0\nB0:\n\t0: CopyLoc[0](Arg0: &mut PriorityQueue<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t2: VecLen(6)\n\t3: StLoc[1](loc0: u64)\n\t4: CopyLoc[1](loc0: u64)\n\t5: LdU64(0)\n\t6: Gt\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut PriorityQueue<Ty0>)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: CopyLoc[0](Arg0: &mut PriorityQueue<Ty0>)\n\t14: MutBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t15: LdU64(0)\n\t16: Call vector::swap_remove<Entry<Ty0>>(&mut vector<Entry<Ty0>>, u64): Entry<Ty0>\n\t17: UnpackGeneric[1](Entry<Ty0>)\n\t18: StLoc[3](loc2: Ty0)\n\t19: StLoc[2](loc1: u64)\n\t20: MoveLoc[0](Arg0: &mut PriorityQueue<Ty0>)\n\t21: MutBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t22: MoveLoc[1](loc0: u64)\n\t23: LdU64(1)\n\t24: Sub\n\t25: LdU64(0)\n\t26: Call max_heapify_recursive<Ty0>(&mut vector<Entry<Ty0>>, u64, u64)\n\t27: MoveLoc[2](loc1: u64)\n\t28: MoveLoc[3](loc2: Ty0)\n\t29: Ret\n}\n\npublic insert<Ty0: drop>(Arg0: &mut PriorityQueue<Ty0>, Arg1: u64, Arg2: Ty0) {\nL3:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut PriorityQueue<Ty0>)\n\t1: MutBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: MoveLoc[2](Arg2: Ty0)\n\t4: PackGeneric[1](Entry<Ty0>)\n\t5: VecPushBack(6)\n\t6: CopyLoc[0](Arg0: &mut PriorityQueue<Ty0>)\n\t7: ImmBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t8: VecLen(6)\n\t9: LdU64(1)\n\t10: Sub\n\t11: StLoc[3](loc0: u64)\n\t12: MoveLoc[0](Arg0: &mut PriorityQueue<Ty0>)\n\t13: MutBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t14: MoveLoc[3](loc0: u64)\n\t15: Call restore_heap_recursive<Ty0>(&mut vector<Entry<Ty0>>, u64)\n\t16: Ret\n}\n\npublic new_entry<Ty0: drop>(Arg0: u64, Arg1: Ty0): Entry<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: Ty0)\n\t2: PackGeneric[1](Entry<Ty0>)\n\t3: Ret\n}\n\npublic create_entries<Ty0: drop>(Arg0: vector<u64>, Arg1: vector<Ty0>): vector<Entry<Ty0>> {\nL2:\tloc0: u64\nL3:\tloc1: u64\nL4:\tloc2: u64\nL5:\tloc3: vector<Entry<Ty0>>\nL6:\tloc4: Ty0\nB0:\n\t0: ImmBorrowLoc[0](Arg0: vector<u64>)\n\t1: VecLen(16)\n\t2: StLoc[3](loc1: u64)\n\t3: ImmBorrowLoc[1](Arg1: vector<Ty0>)\n\t4: VecLen(13)\n\t5: CopyLoc[3](loc1: u64)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(11)\nB2:\n\t9: LdU64(0)\n\t10: Abort\nB3:\n\t11: VecPack(6, 0)\n\t12: StLoc[5](loc3: vector<Entry<Ty0>>)\n\t13: LdU64(0)\n\t14: StLoc[2](loc0: u64)\nB4:\n\t15: CopyLoc[2](loc0: u64)\n\t16: CopyLoc[3](loc1: u64)\n\t17: Lt\n\t18: BrFalse(37)\nB5:\n\t19: MutBorrowLoc[0](Arg0: vector<u64>)\n\t20: LdU64(0)\n\t21: Call vector::remove<u64>(&mut vector<u64>, u64): u64\n\t22: StLoc[4](loc2: u64)\n\t23: MutBorrowLoc[1](Arg1: vector<Ty0>)\n\t24: LdU64(0)\n\t25: Call vector::remove<Ty0>(&mut vector<Ty0>, u64): Ty0\n\t26: StLoc[6](loc4: Ty0)\n\t27: MutBorrowLoc[5](loc3: vector<Entry<Ty0>>)\n\t28: MoveLoc[4](loc2: u64)\n\t29: MoveLoc[6](loc4: Ty0)\n\t30: PackGeneric[1](Entry<Ty0>)\n\t31: VecPushBack(6)\n\t32: MoveLoc[2](loc0: u64)\n\t33: LdU64(1)\n\t34: Add\n\t35: StLoc[2](loc0: u64)\n\t36: Branch(15)\nB6:\n\t37: MoveLoc[5](loc3: vector<Entry<Ty0>>)\n\t38: Ret\n}\n\nrestore_heap_recursive<Ty0: drop>(Arg0: &mut vector<Entry<Ty0>>, Arg1: u64) {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: LdU64(0)\n\t2: Eq\n\t3: BrFalse(7)\nB1:\n\t4: MoveLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t5: Pop\n\t6: Ret\nB2:\n\t7: CopyLoc[1](Arg1: u64)\n\t8: LdU64(1)\n\t9: Sub\n\t10: LdU64(2)\n\t11: Div\n\t12: StLoc[2](loc0: u64)\n\t13: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t14: FreezeRef\n\t15: CopyLoc[1](Arg1: u64)\n\t16: VecImmBorrow(6)\n\t17: ImmBorrowFieldGeneric[1](Entry.priority: u64)\n\t18: ReadRef\n\t19: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t20: FreezeRef\n\t21: CopyLoc[2](loc0: u64)\n\t22: VecImmBorrow(6)\n\t23: ImmBorrowFieldGeneric[1](Entry.priority: u64)\n\t24: ReadRef\n\t25: Gt\n\t26: BrFalse(35)\nB3:\n\t27: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t28: MoveLoc[1](Arg1: u64)\n\t29: CopyLoc[2](loc0: u64)\n\t30: VecSwap(6)\n\t31: MoveLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t32: MoveLoc[2](loc0: u64)\n\t33: Call restore_heap_recursive<Ty0>(&mut vector<Entry<Ty0>>, u64)\n\t34: Branch(37)\nB4:\n\t35: MoveLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t36: Pop\nB5:\n\t37: Ret\n}\n\nmax_heapify_recursive<Ty0: drop>(Arg0: &mut vector<Entry<Ty0>>, Arg1: u64, Arg2: u64) {\nL3:\tloc0: bool\nL4:\tloc1: bool\nL5:\tloc2: u64\nL6:\tloc3: u64\nL7:\tloc4: u64\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: LdU64(0)\n\t2: Eq\n\t3: BrFalse(7)\nB1:\n\t4: MoveLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t5: Pop\n\t6: Ret\nB2:\n\t7: CopyLoc[2](Arg2: u64)\n\t8: CopyLoc[1](Arg1: u64)\n\t9: Lt\n\t10: BrFalse(12)\nB3:\n\t11: Branch(16)\nB4:\n\t12: MoveLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t13: Pop\n\t14: LdU64(1)\n\t15: Abort\nB5:\n\t16: CopyLoc[2](Arg2: u64)\n\t17: LdU64(2)\n\t18: Mul\n\t19: LdU64(1)\n\t20: Add\n\t21: StLoc[5](loc2: u64)\n\t22: CopyLoc[5](loc2: u64)\n\t23: LdU64(1)\n\t24: Add\n\t25: StLoc[7](loc4: u64)\n\t26: CopyLoc[2](Arg2: u64)\n\t27: StLoc[6](loc3: u64)\n\t28: CopyLoc[5](loc2: u64)\n\t29: CopyLoc[1](Arg1: u64)\n\t30: Lt\n\t31: BrFalse(47)\nB6:\n\t32: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t33: FreezeRef\n\t34: CopyLoc[5](loc2: u64)\n\t35: VecImmBorrow(6)\n\t36: ImmBorrowFieldGeneric[1](Entry.priority: u64)\n\t37: ReadRef\n\t38: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t39: FreezeRef\n\t40: CopyLoc[6](loc3: u64)\n\t41: VecImmBorrow(6)\n\t42: ImmBorrowFieldGeneric[1](Entry.priority: u64)\n\t43: ReadRef\n\t44: Gt\n\t45: StLoc[3](loc0: bool)\n\t46: Branch(49)\nB7:\n\t47: LdFalse\n\t48: StLoc[3](loc0: bool)\nB8:\n\t49: MoveLoc[3](loc0: bool)\n\t50: BrFalse(53)\nB9:\n\t51: MoveLoc[5](loc2: u64)\n\t52: StLoc[6](loc3: u64)\nB10:\n\t53: CopyLoc[7](loc4: u64)\n\t54: CopyLoc[1](Arg1: u64)\n\t55: Lt\n\t56: BrFalse(72)\nB11:\n\t57: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t58: FreezeRef\n\t59: CopyLoc[7](loc4: u64)\n\t60: VecImmBorrow(6)\n\t61: ImmBorrowFieldGeneric[1](Entry.priority: u64)\n\t62: ReadRef\n\t63: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t64: FreezeRef\n\t65: CopyLoc[6](loc3: u64)\n\t66: VecImmBorrow(6)\n\t67: ImmBorrowFieldGeneric[1](Entry.priority: u64)\n\t68: ReadRef\n\t69: Gt\n\t70: StLoc[4](loc1: bool)\n\t71: Branch(74)\nB12:\n\t72: LdFalse\n\t73: StLoc[4](loc1: bool)\nB13:\n\t74: MoveLoc[4](loc1: bool)\n\t75: BrFalse(78)\nB14:\n\t76: MoveLoc[7](loc4: u64)\n\t77: StLoc[6](loc3: u64)\nB15:\n\t78: CopyLoc[6](loc3: u64)\n\t79: CopyLoc[2](Arg2: u64)\n\t80: Neq\n\t81: BrFalse(91)\nB16:\n\t82: CopyLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t83: CopyLoc[6](loc3: u64)\n\t84: MoveLoc[2](Arg2: u64)\n\t85: VecSwap(6)\n\t86: MoveLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t87: MoveLoc[1](Arg1: u64)\n\t88: MoveLoc[6](loc3: u64)\n\t89: Call max_heapify_recursive<Ty0>(&mut vector<Entry<Ty0>>, u64, u64)\n\t90: Branch(93)\nB17:\n\t91: MoveLoc[0](Arg0: &mut vector<Entry<Ty0>>)\n\t92: Pop\nB18:\n\t93: Ret\n}\n\npublic priorities<Ty0: drop>(Arg0: &PriorityQueue<Ty0>): vector<u64> {\nL1:\tloc0: u64\nL2:\tloc1: vector<u64>\nB0:\n\t0: LdConst[1](vector<u64>: 00)\n\t1: StLoc[2](loc1: vector<u64>)\n\t2: LdU64(0)\n\t3: StLoc[1](loc0: u64)\nB1:\n\t4: CopyLoc[1](loc0: u64)\n\t5: CopyLoc[0](Arg0: &PriorityQueue<Ty0>)\n\t6: ImmBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t7: VecLen(6)\n\t8: Lt\n\t9: BrFalse(24)\nB2:\n\t10: Branch(11)\nB3:\n\t11: MutBorrowLoc[2](loc1: vector<u64>)\n\t12: CopyLoc[0](Arg0: &PriorityQueue<Ty0>)\n\t13: ImmBorrowFieldGeneric[0](PriorityQueue.entries: vector<Entry<Ty0>>)\n\t14: CopyLoc[1](loc0: u64)\n\t15: VecImmBorrow(6)\n\t16: ImmBorrowFieldGeneric[1](Entry.priority: u64)\n\t17: ReadRef\n\t18: VecPushBack(16)\n\t19: MoveLoc[1](loc0: u64)\n\t20: LdU64(1)\n\t21: Add\n\t22: StLoc[1](loc0: u64)\n\t23: Branch(4)\nB4:\n\t24: MoveLoc[0](Arg0: &PriorityQueue<Ty0>)\n\t25: Pop\n\t26: MoveLoc[2](loc1: vector<u64>)\n\t27: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => vector<u64>: 00\n]\n}\n","prover":"// Move bytecode v6\nmodule 2.prover {\n\n}\n","random":"// Move bytecode v6\nmodule 2.random {\nuse 0000000000000000000000000000000000000000000000000000000000000001::bcs;\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\nuse 0000000000000000000000000000000000000000000000000000000000000002::address;\nuse 0000000000000000000000000000000000000000000000000000000000000002::hmac;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::versioned;\n\nstruct Random has key {\n\tid: UID,\n\tinner: Versioned\n}\n\nstruct RandomInner has store {\n\tversion: u64,\n\tepoch: u64,\n\trandomness_round: u64,\n\trandom_bytes: vector<u8>\n}\n\nstruct RandomGenerator has drop {\n\tseed: vector<u8>,\n\tcounter: u16,\n\tbuffer: vector<u8>\n}\n\ncreate(Arg0: &mut TxContext) {\nL1:\tloc0: RandomInner\nL2:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::sender(&TxContext): address\n\t3: LdConst[7](address: 0x00..)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut TxContext)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: LdConst[1](u64: 1)\n\t12: StLoc[2](loc1: u64)\n\t13: CopyLoc[2](loc1: u64)\n\t14: CopyLoc[0](Arg0: &mut TxContext)\n\t15: FreezeRef\n\t16: Call tx_context::epoch(&TxContext): u64\n\t17: LdU64(0)\n\t18: LdConst[8](vector<u8>: \"\" /..)\n\t19: Pack[1](RandomInner)\n\t20: StLoc[1](loc0: RandomInner)\n\t21: Call object::randomness_state(): UID\n\t22: MoveLoc[2](loc1: u64)\n\t23: MoveLoc[1](loc0: RandomInner)\n\t24: MoveLoc[0](Arg0: &mut TxContext)\n\t25: Call versioned::create<RandomInner>(u64, RandomInner, &mut TxContext): Versioned\n\t26: Pack[0](Random)\n\t27: Call transfer::share_object<Random>(Random)\n\t28: Ret\n}\n\nload_inner_mut(Arg0: &mut Random): &mut RandomInner {\nL1:\tloc0: &mut RandomInner\nL2:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut Random)\n\t1: ImmBorrowField[0](Random.inner: Versioned)\n\t2: Call versioned::version(&Versioned): u64\n\t3: StLoc[2](loc1: u64)\n\t4: CopyLoc[2](loc1: u64)\n\t5: LdConst[1](u64: 1)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut Random)\n\t10: Pop\n\t11: LdConst[1](u64: 1)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &mut Random)\n\t14: MutBorrowField[0](Random.inner: Versioned)\n\t15: Call versioned::load_value_mut<RandomInner>(&mut Versioned): &mut RandomInner\n\t16: StLoc[1](loc0: &mut RandomInner)\n\t17: CopyLoc[1](loc0: &mut RandomInner)\n\t18: ImmBorrowField[1](RandomInner.version: u64)\n\t19: ReadRef\n\t20: MoveLoc[2](loc1: u64)\n\t21: Eq\n\t22: BrFalse(24)\nB4:\n\t23: Branch(28)\nB5:\n\t24: MoveLoc[1](loc0: &mut RandomInner)\n\t25: Pop\n\t26: LdConst[1](u64: 1)\n\t27: Abort\nB6:\n\t28: MoveLoc[1](loc0: &mut RandomInner)\n\t29: Ret\n}\n\nload_inner(Arg0: &Random): &RandomInner {\nL1:\tloc0: &RandomInner\nL2:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &Random)\n\t1: ImmBorrowField[0](Random.inner: Versioned)\n\t2: Call versioned::version(&Versioned): u64\n\t3: StLoc[2](loc1: u64)\n\t4: CopyLoc[2](loc1: u64)\n\t5: LdConst[1](u64: 1)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &Random)\n\t10: Pop\n\t11: LdConst[1](u64: 1)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &Random)\n\t14: ImmBorrowField[0](Random.inner: Versioned)\n\t15: Call versioned::load_value<RandomInner>(&Versioned): &RandomInner\n\t16: StLoc[1](loc0: &RandomInner)\n\t17: CopyLoc[1](loc0: &RandomInner)\n\t18: ImmBorrowField[1](RandomInner.version: u64)\n\t19: ReadRef\n\t20: MoveLoc[2](loc1: u64)\n\t21: Eq\n\t22: BrFalse(24)\nB4:\n\t23: Branch(28)\nB5:\n\t24: MoveLoc[1](loc0: &RandomInner)\n\t25: Pop\n\t26: LdConst[1](u64: 1)\n\t27: Abort\nB6:\n\t28: MoveLoc[1](loc0: &RandomInner)\n\t29: Ret\n}\n\nupdate_randomness_state(Arg0: &mut Random, Arg1: u64, Arg2: vector<u8>, Arg3: &TxContext) {\nL4:\tloc0: bool\nL5:\tloc1: bool\nL6:\tloc2: bool\nL7:\tloc3: u64\nL8:\tloc4: &mut RandomInner\nB0:\n\t0: CopyLoc[3](Arg3: &TxContext)\n\t1: Call tx_context::sender(&TxContext): address\n\t2: LdConst[7](address: 0x00..)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(12)\nB2:\n\t6: MoveLoc[0](Arg0: &mut Random)\n\t7: Pop\n\t8: MoveLoc[3](Arg3: &TxContext)\n\t9: Pop\n\t10: LdConst[0](u64: 0)\n\t11: Abort\nB3:\n\t12: CopyLoc[3](Arg3: &TxContext)\n\t13: Call tx_context::epoch(&TxContext): u64\n\t14: StLoc[7](loc3: u64)\n\t15: MoveLoc[0](Arg0: &mut Random)\n\t16: Call load_inner_mut(&mut Random): &mut RandomInner\n\t17: StLoc[8](loc4: &mut RandomInner)\n\t18: CopyLoc[8](loc4: &mut RandomInner)\n\t19: ImmBorrowField[2](RandomInner.randomness_round: u64)\n\t20: ReadRef\n\t21: LdU64(0)\n\t22: Eq\n\t23: BrFalse(38)\nB4:\n\t24: CopyLoc[8](loc4: &mut RandomInner)\n\t25: ImmBorrowField[3](RandomInner.epoch: u64)\n\t26: ReadRef\n\t27: LdU64(0)\n\t28: Eq\n\t29: BrFalse(35)\nB5:\n\t30: CopyLoc[8](loc4: &mut RandomInner)\n\t31: ImmBorrowField[4](RandomInner.random_bytes: vector<u8>)\n\t32: Call vector::is_empty<u8>(&vector<u8>): bool\n\t33: StLoc[4](loc0: bool)\n\t34: Branch(40)\nB6:\n\t35: LdFalse\n\t36: StLoc[4](loc0: bool)\n\t37: Branch(40)\nB7:\n\t38: LdFalse\n\t39: StLoc[4](loc0: bool)\nB8:\n\t40: MoveLoc[4](loc0: bool)\n\t41: BrFalse(53)\nB9:\n\t42: CopyLoc[1](Arg1: u64)\n\t43: LdU64(0)\n\t44: Eq\n\t45: BrFalse(47)\nB10:\n\t46: Branch(88)\nB11:\n\t47: MoveLoc[8](loc4: &mut RandomInner)\n\t48: Pop\n\t49: MoveLoc[3](Arg3: &TxContext)\n\t50: Pop\n\t51: LdConst[2](u64: 2)\n\t52: Abort\nB12:\n\t53: MoveLoc[7](loc3: u64)\n\t54: CopyLoc[8](loc4: &mut RandomInner)\n\t55: ImmBorrowField[3](RandomInner.epoch: u64)\n\t56: ReadRef\n\t57: Gt\n\t58: BrFalse(64)\nB13:\n\t59: CopyLoc[1](Arg1: u64)\n\t60: LdU64(0)\n\t61: Eq\n\t62: StLoc[6](loc2: bool)\n\t63: Branch(66)\nB14:\n\t64: LdFalse\n\t65: StLoc[6](loc2: bool)\nB15:\n\t66: MoveLoc[6](loc2: bool)\n\t67: BrFalse(71)\nB16:\n\t68: LdTrue\n\t69: StLoc[5](loc1: bool)\n\t70: Branch(79)\nB17:\n\t71: CopyLoc[1](Arg1: u64)\n\t72: CopyLoc[8](loc4: &mut RandomInner)\n\t73: ImmBorrowField[2](RandomInner.randomness_round: u64)\n\t74: ReadRef\n\t75: LdU64(1)\n\t76: Add\n\t77: Eq\n\t78: StLoc[5](loc1: bool)\nB18:\n\t79: MoveLoc[5](loc1: bool)\n\t80: BrFalse(82)\nB19:\n\t81: Branch(88)\nB20:\n\t82: MoveLoc[8](loc4: &mut RandomInner)\n\t83: Pop\n\t84: MoveLoc[3](Arg3: &TxContext)\n\t85: Pop\n\t86: LdConst[2](u64: 2)\n\t87: Abort\nB21:\n\t88: MoveLoc[3](Arg3: &TxContext)\n\t89: Call tx_context::epoch(&TxContext): u64\n\t90: CopyLoc[8](loc4: &mut RandomInner)\n\t91: MutBorrowField[3](RandomInner.epoch: u64)\n\t92: WriteRef\n\t93: MoveLoc[1](Arg1: u64)\n\t94: CopyLoc[8](loc4: &mut RandomInner)\n\t95: MutBorrowField[2](RandomInner.randomness_round: u64)\n\t96: WriteRef\n\t97: MoveLoc[2](Arg2: vector<u8>)\n\t98: MoveLoc[8](loc4: &mut RandomInner)\n\t99: MutBorrowField[4](RandomInner.random_bytes: vector<u8>)\n\t100: WriteRef\n\t101: Ret\n}\n\npublic new_generator(Arg0: &Random, Arg1: &mut TxContext): RandomGenerator {\nL2:\tloc0: vector<u8>\nL3:\tloc1: &vector<u8>\nB0:\n\t0: MoveLoc[0](Arg0: &Random)\n\t1: Call load_inner(&Random): &RandomInner\n\t2: ImmBorrowField[4](RandomInner.random_bytes: vector<u8>)\n\t3: StLoc[3](loc1: &vector<u8>)\n\t4: MoveLoc[1](Arg1: &mut TxContext)\n\t5: Call tx_context::fresh_object_address(&mut TxContext): address\n\t6: Call address::to_bytes(address): vector<u8>\n\t7: StLoc[2](loc0: vector<u8>)\n\t8: MoveLoc[3](loc1: &vector<u8>)\n\t9: ImmBorrowLoc[2](loc0: vector<u8>)\n\t10: Call hmac::hmac_sha3_256(&vector<u8>, &vector<u8>): vector<u8>\n\t11: LdU16(0)\n\t12: LdConst[8](vector<u8>: \"\" /..)\n\t13: Pack[2](RandomGenerator)\n\t14: Ret\n}\n\nderive_next_block(Arg0: &mut RandomGenerator): vector<u8> {\nL1:\tloc0: vector<u8>\nL2:\tloc1: &vector<u8>\nB0:\n\t0: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t1: ImmBorrowField[5](RandomGenerator.counter: u16)\n\t2: ReadRef\n\t3: LdU16(1)\n\t4: Add\n\t5: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t6: MutBorrowField[5](RandomGenerator.counter: u16)\n\t7: WriteRef\n\t8: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t9: ImmBorrowField[6](RandomGenerator.seed: vector<u8>)\n\t10: StLoc[2](loc1: &vector<u8>)\n\t11: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t12: ImmBorrowField[5](RandomGenerator.counter: u16)\n\t13: Call bcs::to_bytes<u16>(&u16): vector<u8>\n\t14: StLoc[1](loc0: vector<u8>)\n\t15: MoveLoc[2](loc1: &vector<u8>)\n\t16: ImmBorrowLoc[1](loc0: vector<u8>)\n\t17: Call hmac::hmac_sha3_256(&vector<u8>, &vector<u8>): vector<u8>\n\t18: Ret\n}\n\npublic generate_bytes(Arg0: &mut RandomGenerator, Arg1: u16): vector<u8> {\nL2:\tloc0: u16\nL3:\tloc1: u64\nL4:\tloc2: u64\nL5:\tloc3: u16\nL6:\tloc4: vector<u8>\nL7:\tloc5: u64\nL8:\tloc6: vector<u8>\nL9:\tloc7: u64\nL10:\tloc8: u16\nB0:\n\t0: LdConst[8](vector<u8>: \"\" /..)\n\t1: StLoc[8](loc6: vector<u8>)\n\t2: CopyLoc[1](Arg1: u16)\n\t3: LdConst[5](u16: 32)\n\t4: Div\n\t5: StLoc[2](loc0: u16)\n\t6: LdU16(0)\n\t7: StLoc[5](loc3: u16)\n\t8: MoveLoc[2](loc0: u16)\n\t9: StLoc[10](loc8: u16)\nB1:\n\t10: CopyLoc[5](loc3: u16)\n\t11: CopyLoc[10](loc8: u16)\n\t12: Lt\n\t13: BrFalse(25)\nB2:\n\t14: CopyLoc[5](loc3: u16)\n\t15: Pop\n\t16: MutBorrowLoc[8](loc6: vector<u8>)\n\t17: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t18: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t19: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\n\t20: MoveLoc[5](loc3: u16)\n\t21: LdU16(1)\n\t22: Add\n\t23: StLoc[5](loc3: u16)\n\t24: Branch(10)\nB3:\n\t25: MoveLoc[1](Arg1: u16)\n\t26: CastU64\n\t27: ImmBorrowLoc[8](loc6: vector<u8>)\n\t28: VecLen(17)\n\t29: Sub\n\t30: StLoc[7](loc5: u64)\n\t31: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t32: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t33: VecLen(17)\n\t34: CopyLoc[7](loc5: u64)\n\t35: Lt\n\t36: BrFalse(45)\nB4:\n\t37: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t38: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t39: StLoc[6](loc4: vector<u8>)\n\t40: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t41: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t42: MoveLoc[6](loc4: vector<u8>)\n\t43: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\n\t44: Branch(45)\nB5:\n\t45: MoveLoc[7](loc5: u64)\n\t46: StLoc[3](loc1: u64)\n\t47: LdU64(0)\n\t48: StLoc[4](loc2: u64)\n\t49: MoveLoc[3](loc1: u64)\n\t50: StLoc[9](loc7: u64)\nB6:\n\t51: CopyLoc[4](loc2: u64)\n\t52: CopyLoc[9](loc7: u64)\n\t53: Lt\n\t54: BrFalse(67)\nB7:\n\t55: CopyLoc[4](loc2: u64)\n\t56: Pop\n\t57: MutBorrowLoc[8](loc6: vector<u8>)\n\t58: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t59: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t60: VecPopBack(17)\n\t61: VecPushBack(17)\n\t62: MoveLoc[4](loc2: u64)\n\t63: LdU64(1)\n\t64: Add\n\t65: StLoc[4](loc2: u64)\n\t66: Branch(51)\nB8:\n\t67: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t68: Pop\n\t69: MoveLoc[8](loc6: vector<u8>)\n\t70: Ret\n}\n\npublic generate_u256(Arg0: &mut RandomGenerator): u256 {\nL1:\tloc0: u8\nL2:\tloc1: u256\nL3:\tloc2: &mut RandomGenerator\nL4:\tloc3: u8\nL5:\tloc4: vector<u8>\nL6:\tloc5: u8\nL7:\tloc6: u256\nL8:\tloc7: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t1: StLoc[3](loc2: &mut RandomGenerator)\n\t2: LdU8(32)\n\t3: StLoc[6](loc5: u8)\n\t4: CopyLoc[3](loc2: &mut RandomGenerator)\n\t5: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t6: VecLen(17)\n\t7: CopyLoc[6](loc5: u8)\n\t8: CastU64\n\t9: Lt\n\t10: BrFalse(18)\nB1:\n\t11: CopyLoc[3](loc2: &mut RandomGenerator)\n\t12: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t13: StLoc[5](loc4: vector<u8>)\n\t14: CopyLoc[3](loc2: &mut RandomGenerator)\n\t15: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t16: MoveLoc[5](loc4: vector<u8>)\n\t17: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB2:\n\t18: LdU256(0)\n\t19: StLoc[7](loc6: u256)\n\t20: MoveLoc[6](loc5: u8)\n\t21: StLoc[1](loc0: u8)\n\t22: LdU8(0)\n\t23: StLoc[4](loc3: u8)\n\t24: MoveLoc[1](loc0: u8)\n\t25: StLoc[8](loc7: u8)\nB3:\n\t26: CopyLoc[4](loc3: u8)\n\t27: CopyLoc[8](loc7: u8)\n\t28: Lt\n\t29: BrFalse(48)\nB4:\n\t30: CopyLoc[4](loc3: u8)\n\t31: Pop\n\t32: CopyLoc[3](loc2: &mut RandomGenerator)\n\t33: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t34: VecPopBack(17)\n\t35: CastU256\n\t36: StLoc[2](loc1: u256)\n\t37: MoveLoc[7](loc6: u256)\n\t38: LdU8(8)\n\t39: Shl\n\t40: MoveLoc[2](loc1: u256)\n\t41: Add\n\t42: StLoc[7](loc6: u256)\n\t43: MoveLoc[4](loc3: u8)\n\t44: LdU8(1)\n\t45: Add\n\t46: StLoc[4](loc3: u8)\n\t47: Branch(26)\nB5:\n\t48: MoveLoc[3](loc2: &mut RandomGenerator)\n\t49: Pop\n\t50: MoveLoc[7](loc6: u256)\n\t51: CastU256\n\t52: Ret\n}\n\npublic generate_u128(Arg0: &mut RandomGenerator): u128 {\nL1:\tloc0: u8\nL2:\tloc1: u256\nL3:\tloc2: &mut RandomGenerator\nL4:\tloc3: u8\nL5:\tloc4: vector<u8>\nL6:\tloc5: u8\nL7:\tloc6: u256\nL8:\tloc7: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t1: StLoc[3](loc2: &mut RandomGenerator)\n\t2: LdU8(16)\n\t3: StLoc[6](loc5: u8)\n\t4: CopyLoc[3](loc2: &mut RandomGenerator)\n\t5: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t6: VecLen(17)\n\t7: CopyLoc[6](loc5: u8)\n\t8: CastU64\n\t9: Lt\n\t10: BrFalse(18)\nB1:\n\t11: CopyLoc[3](loc2: &mut RandomGenerator)\n\t12: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t13: StLoc[5](loc4: vector<u8>)\n\t14: CopyLoc[3](loc2: &mut RandomGenerator)\n\t15: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t16: MoveLoc[5](loc4: vector<u8>)\n\t17: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB2:\n\t18: LdU256(0)\n\t19: StLoc[7](loc6: u256)\n\t20: MoveLoc[6](loc5: u8)\n\t21: StLoc[1](loc0: u8)\n\t22: LdU8(0)\n\t23: StLoc[4](loc3: u8)\n\t24: MoveLoc[1](loc0: u8)\n\t25: StLoc[8](loc7: u8)\nB3:\n\t26: CopyLoc[4](loc3: u8)\n\t27: CopyLoc[8](loc7: u8)\n\t28: Lt\n\t29: BrFalse(48)\nB4:\n\t30: CopyLoc[4](loc3: u8)\n\t31: Pop\n\t32: CopyLoc[3](loc2: &mut RandomGenerator)\n\t33: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t34: VecPopBack(17)\n\t35: CastU256\n\t36: StLoc[2](loc1: u256)\n\t37: MoveLoc[7](loc6: u256)\n\t38: LdU8(8)\n\t39: Shl\n\t40: MoveLoc[2](loc1: u256)\n\t41: Add\n\t42: StLoc[7](loc6: u256)\n\t43: MoveLoc[4](loc3: u8)\n\t44: LdU8(1)\n\t45: Add\n\t46: StLoc[4](loc3: u8)\n\t47: Branch(26)\nB5:\n\t48: MoveLoc[3](loc2: &mut RandomGenerator)\n\t49: Pop\n\t50: MoveLoc[7](loc6: u256)\n\t51: CastU128\n\t52: Ret\n}\n\npublic generate_u64(Arg0: &mut RandomGenerator): u64 {\nL1:\tloc0: u8\nL2:\tloc1: u256\nL3:\tloc2: &mut RandomGenerator\nL4:\tloc3: u8\nL5:\tloc4: vector<u8>\nL6:\tloc5: u8\nL7:\tloc6: u256\nL8:\tloc7: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t1: StLoc[3](loc2: &mut RandomGenerator)\n\t2: LdU8(8)\n\t3: StLoc[6](loc5: u8)\n\t4: CopyLoc[3](loc2: &mut RandomGenerator)\n\t5: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t6: VecLen(17)\n\t7: CopyLoc[6](loc5: u8)\n\t8: CastU64\n\t9: Lt\n\t10: BrFalse(18)\nB1:\n\t11: CopyLoc[3](loc2: &mut RandomGenerator)\n\t12: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t13: StLoc[5](loc4: vector<u8>)\n\t14: CopyLoc[3](loc2: &mut RandomGenerator)\n\t15: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t16: MoveLoc[5](loc4: vector<u8>)\n\t17: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB2:\n\t18: LdU256(0)\n\t19: StLoc[7](loc6: u256)\n\t20: MoveLoc[6](loc5: u8)\n\t21: StLoc[1](loc0: u8)\n\t22: LdU8(0)\n\t23: StLoc[4](loc3: u8)\n\t24: MoveLoc[1](loc0: u8)\n\t25: StLoc[8](loc7: u8)\nB3:\n\t26: CopyLoc[4](loc3: u8)\n\t27: CopyLoc[8](loc7: u8)\n\t28: Lt\n\t29: BrFalse(48)\nB4:\n\t30: CopyLoc[4](loc3: u8)\n\t31: Pop\n\t32: CopyLoc[3](loc2: &mut RandomGenerator)\n\t33: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t34: VecPopBack(17)\n\t35: CastU256\n\t36: StLoc[2](loc1: u256)\n\t37: MoveLoc[7](loc6: u256)\n\t38: LdU8(8)\n\t39: Shl\n\t40: MoveLoc[2](loc1: u256)\n\t41: Add\n\t42: StLoc[7](loc6: u256)\n\t43: MoveLoc[4](loc3: u8)\n\t44: LdU8(1)\n\t45: Add\n\t46: StLoc[4](loc3: u8)\n\t47: Branch(26)\nB5:\n\t48: MoveLoc[3](loc2: &mut RandomGenerator)\n\t49: Pop\n\t50: MoveLoc[7](loc6: u256)\n\t51: CastU64\n\t52: Ret\n}\n\npublic generate_u32(Arg0: &mut RandomGenerator): u32 {\nL1:\tloc0: u8\nL2:\tloc1: u256\nL3:\tloc2: &mut RandomGenerator\nL4:\tloc3: u8\nL5:\tloc4: vector<u8>\nL6:\tloc5: u8\nL7:\tloc6: u256\nL8:\tloc7: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t1: StLoc[3](loc2: &mut RandomGenerator)\n\t2: LdU8(4)\n\t3: StLoc[6](loc5: u8)\n\t4: CopyLoc[3](loc2: &mut RandomGenerator)\n\t5: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t6: VecLen(17)\n\t7: CopyLoc[6](loc5: u8)\n\t8: CastU64\n\t9: Lt\n\t10: BrFalse(18)\nB1:\n\t11: CopyLoc[3](loc2: &mut RandomGenerator)\n\t12: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t13: StLoc[5](loc4: vector<u8>)\n\t14: CopyLoc[3](loc2: &mut RandomGenerator)\n\t15: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t16: MoveLoc[5](loc4: vector<u8>)\n\t17: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB2:\n\t18: LdU256(0)\n\t19: StLoc[7](loc6: u256)\n\t20: MoveLoc[6](loc5: u8)\n\t21: StLoc[1](loc0: u8)\n\t22: LdU8(0)\n\t23: StLoc[4](loc3: u8)\n\t24: MoveLoc[1](loc0: u8)\n\t25: StLoc[8](loc7: u8)\nB3:\n\t26: CopyLoc[4](loc3: u8)\n\t27: CopyLoc[8](loc7: u8)\n\t28: Lt\n\t29: BrFalse(48)\nB4:\n\t30: CopyLoc[4](loc3: u8)\n\t31: Pop\n\t32: CopyLoc[3](loc2: &mut RandomGenerator)\n\t33: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t34: VecPopBack(17)\n\t35: CastU256\n\t36: StLoc[2](loc1: u256)\n\t37: MoveLoc[7](loc6: u256)\n\t38: LdU8(8)\n\t39: Shl\n\t40: MoveLoc[2](loc1: u256)\n\t41: Add\n\t42: StLoc[7](loc6: u256)\n\t43: MoveLoc[4](loc3: u8)\n\t44: LdU8(1)\n\t45: Add\n\t46: StLoc[4](loc3: u8)\n\t47: Branch(26)\nB5:\n\t48: MoveLoc[3](loc2: &mut RandomGenerator)\n\t49: Pop\n\t50: MoveLoc[7](loc6: u256)\n\t51: CastU32\n\t52: Ret\n}\n\npublic generate_u16(Arg0: &mut RandomGenerator): u16 {\nL1:\tloc0: u8\nL2:\tloc1: u256\nL3:\tloc2: &mut RandomGenerator\nL4:\tloc3: u8\nL5:\tloc4: vector<u8>\nL6:\tloc5: u8\nL7:\tloc6: u256\nL8:\tloc7: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t1: StLoc[3](loc2: &mut RandomGenerator)\n\t2: LdU8(2)\n\t3: StLoc[6](loc5: u8)\n\t4: CopyLoc[3](loc2: &mut RandomGenerator)\n\t5: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t6: VecLen(17)\n\t7: CopyLoc[6](loc5: u8)\n\t8: CastU64\n\t9: Lt\n\t10: BrFalse(18)\nB1:\n\t11: CopyLoc[3](loc2: &mut RandomGenerator)\n\t12: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t13: StLoc[5](loc4: vector<u8>)\n\t14: CopyLoc[3](loc2: &mut RandomGenerator)\n\t15: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t16: MoveLoc[5](loc4: vector<u8>)\n\t17: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB2:\n\t18: LdU256(0)\n\t19: StLoc[7](loc6: u256)\n\t20: MoveLoc[6](loc5: u8)\n\t21: StLoc[1](loc0: u8)\n\t22: LdU8(0)\n\t23: StLoc[4](loc3: u8)\n\t24: MoveLoc[1](loc0: u8)\n\t25: StLoc[8](loc7: u8)\nB3:\n\t26: CopyLoc[4](loc3: u8)\n\t27: CopyLoc[8](loc7: u8)\n\t28: Lt\n\t29: BrFalse(48)\nB4:\n\t30: CopyLoc[4](loc3: u8)\n\t31: Pop\n\t32: CopyLoc[3](loc2: &mut RandomGenerator)\n\t33: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t34: VecPopBack(17)\n\t35: CastU256\n\t36: StLoc[2](loc1: u256)\n\t37: MoveLoc[7](loc6: u256)\n\t38: LdU8(8)\n\t39: Shl\n\t40: MoveLoc[2](loc1: u256)\n\t41: Add\n\t42: StLoc[7](loc6: u256)\n\t43: MoveLoc[4](loc3: u8)\n\t44: LdU8(1)\n\t45: Add\n\t46: StLoc[4](loc3: u8)\n\t47: Branch(26)\nB5:\n\t48: MoveLoc[3](loc2: &mut RandomGenerator)\n\t49: Pop\n\t50: MoveLoc[7](loc6: u256)\n\t51: CastU16\n\t52: Ret\n}\n\npublic generate_u8(Arg0: &mut RandomGenerator): u8 {\nL1:\tloc0: u8\nL2:\tloc1: u256\nL3:\tloc2: &mut RandomGenerator\nL4:\tloc3: u8\nL5:\tloc4: vector<u8>\nL6:\tloc5: u8\nL7:\tloc6: u256\nL8:\tloc7: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t1: StLoc[3](loc2: &mut RandomGenerator)\n\t2: LdU8(1)\n\t3: StLoc[6](loc5: u8)\n\t4: CopyLoc[3](loc2: &mut RandomGenerator)\n\t5: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t6: VecLen(17)\n\t7: CopyLoc[6](loc5: u8)\n\t8: CastU64\n\t9: Lt\n\t10: BrFalse(18)\nB1:\n\t11: CopyLoc[3](loc2: &mut RandomGenerator)\n\t12: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t13: StLoc[5](loc4: vector<u8>)\n\t14: CopyLoc[3](loc2: &mut RandomGenerator)\n\t15: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t16: MoveLoc[5](loc4: vector<u8>)\n\t17: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB2:\n\t18: LdU256(0)\n\t19: StLoc[7](loc6: u256)\n\t20: MoveLoc[6](loc5: u8)\n\t21: StLoc[1](loc0: u8)\n\t22: LdU8(0)\n\t23: StLoc[4](loc3: u8)\n\t24: MoveLoc[1](loc0: u8)\n\t25: StLoc[8](loc7: u8)\nB3:\n\t26: CopyLoc[4](loc3: u8)\n\t27: CopyLoc[8](loc7: u8)\n\t28: Lt\n\t29: BrFalse(48)\nB4:\n\t30: CopyLoc[4](loc3: u8)\n\t31: Pop\n\t32: CopyLoc[3](loc2: &mut RandomGenerator)\n\t33: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t34: VecPopBack(17)\n\t35: CastU256\n\t36: StLoc[2](loc1: u256)\n\t37: MoveLoc[7](loc6: u256)\n\t38: LdU8(8)\n\t39: Shl\n\t40: MoveLoc[2](loc1: u256)\n\t41: Add\n\t42: StLoc[7](loc6: u256)\n\t43: MoveLoc[4](loc3: u8)\n\t44: LdU8(1)\n\t45: Add\n\t46: StLoc[4](loc3: u8)\n\t47: Branch(26)\nB5:\n\t48: MoveLoc[3](loc2: &mut RandomGenerator)\n\t49: Pop\n\t50: MoveLoc[7](loc6: u256)\n\t51: CastU8\n\t52: Ret\n}\n\npublic generate_bool(Arg0: &mut RandomGenerator): bool {\nL1:\tloc0: u8\nL2:\tloc1: u256\nL3:\tloc2: &mut RandomGenerator\nL4:\tloc3: u8\nL5:\tloc4: vector<u8>\nL6:\tloc5: u8\nL7:\tloc6: u256\nL8:\tloc7: u8\nB0:\n\t0: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t1: StLoc[3](loc2: &mut RandomGenerator)\n\t2: LdU8(1)\n\t3: StLoc[6](loc5: u8)\n\t4: CopyLoc[3](loc2: &mut RandomGenerator)\n\t5: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t6: VecLen(17)\n\t7: CopyLoc[6](loc5: u8)\n\t8: CastU64\n\t9: Lt\n\t10: BrFalse(18)\nB1:\n\t11: CopyLoc[3](loc2: &mut RandomGenerator)\n\t12: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t13: StLoc[5](loc4: vector<u8>)\n\t14: CopyLoc[3](loc2: &mut RandomGenerator)\n\t15: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t16: MoveLoc[5](loc4: vector<u8>)\n\t17: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB2:\n\t18: LdU256(0)\n\t19: StLoc[7](loc6: u256)\n\t20: MoveLoc[6](loc5: u8)\n\t21: StLoc[1](loc0: u8)\n\t22: LdU8(0)\n\t23: StLoc[4](loc3: u8)\n\t24: MoveLoc[1](loc0: u8)\n\t25: StLoc[8](loc7: u8)\nB3:\n\t26: CopyLoc[4](loc3: u8)\n\t27: CopyLoc[8](loc7: u8)\n\t28: Lt\n\t29: BrFalse(48)\nB4:\n\t30: CopyLoc[4](loc3: u8)\n\t31: Pop\n\t32: CopyLoc[3](loc2: &mut RandomGenerator)\n\t33: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t34: VecPopBack(17)\n\t35: CastU256\n\t36: StLoc[2](loc1: u256)\n\t37: MoveLoc[7](loc6: u256)\n\t38: LdU8(8)\n\t39: Shl\n\t40: MoveLoc[2](loc1: u256)\n\t41: Add\n\t42: StLoc[7](loc6: u256)\n\t43: MoveLoc[4](loc3: u8)\n\t44: LdU8(1)\n\t45: Add\n\t46: StLoc[4](loc3: u8)\n\t47: Branch(26)\nB5:\n\t48: MoveLoc[3](loc2: &mut RandomGenerator)\n\t49: Pop\n\t50: MoveLoc[7](loc6: u256)\n\t51: CastU64\n\t52: LdU64(1)\n\t53: BitAnd\n\t54: LdU64(1)\n\t55: Eq\n\t56: Ret\n}\n\npublic generate_u128_in_range(Arg0: &mut RandomGenerator, Arg1: u128, Arg2: u128): u128 {\nL3:\tloc0: u8\nL4:\tloc1: u128\nL5:\tloc2: u256\nL6:\tloc3: &mut RandomGenerator\nL7:\tloc4: u8\nL8:\tloc5: u128\nL9:\tloc6: u128\nL10:\tloc7: vector<u8>\nL11:\tloc8: u8\nL12:\tloc9: u256\nL13:\tloc10: u256\nL14:\tloc11: u256\nL15:\tloc12: u8\nB0:\n\t0: MoveLoc[1](Arg1: u128)\n\t1: StLoc[9](loc6: u128)\n\t2: MoveLoc[2](Arg2: u128)\n\t3: StLoc[8](loc5: u128)\n\t4: CopyLoc[9](loc6: u128)\n\t5: CopyLoc[8](loc5: u128)\n\t6: Le\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t10: Pop\n\t11: LdConst[3](u64: 3)\n\t12: Abort\nB3:\n\t13: CopyLoc[9](loc6: u128)\n\t14: CopyLoc[8](loc5: u128)\n\t15: Eq\n\t16: BrFalse(22)\nB4:\n\t17: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t18: Pop\n\t19: MoveLoc[9](loc6: u128)\n\t20: StLoc[4](loc1: u128)\n\t21: Branch(89)\nB5:\n\t22: MoveLoc[8](loc5: u128)\n\t23: CopyLoc[9](loc6: u128)\n\t24: Sub\n\t25: CastU256\n\t26: LdU256(1)\n\t27: Add\n\t28: StLoc[13](loc10: u256)\n\t29: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t30: StLoc[6](loc3: &mut RandomGenerator)\n\t31: LdU8(24)\n\t32: StLoc[11](loc8: u8)\n\t33: CopyLoc[6](loc3: &mut RandomGenerator)\n\t34: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t35: VecLen(17)\n\t36: CopyLoc[11](loc8: u8)\n\t37: CastU64\n\t38: Lt\n\t39: BrFalse(47)\nB6:\n\t40: CopyLoc[6](loc3: &mut RandomGenerator)\n\t41: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t42: StLoc[10](loc7: vector<u8>)\n\t43: CopyLoc[6](loc3: &mut RandomGenerator)\n\t44: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t45: MoveLoc[10](loc7: vector<u8>)\n\t46: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB7:\n\t47: LdU256(0)\n\t48: StLoc[14](loc11: u256)\n\t49: MoveLoc[11](loc8: u8)\n\t50: StLoc[3](loc0: u8)\n\t51: LdU8(0)\n\t52: StLoc[7](loc4: u8)\n\t53: MoveLoc[3](loc0: u8)\n\t54: StLoc[15](loc12: u8)\nB8:\n\t55: CopyLoc[7](loc4: u8)\n\t56: CopyLoc[15](loc12: u8)\n\t57: Lt\n\t58: BrFalse(77)\nB9:\n\t59: CopyLoc[7](loc4: u8)\n\t60: Pop\n\t61: CopyLoc[6](loc3: &mut RandomGenerator)\n\t62: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t63: VecPopBack(17)\n\t64: CastU256\n\t65: StLoc[5](loc2: u256)\n\t66: MoveLoc[14](loc11: u256)\n\t67: LdU8(8)\n\t68: Shl\n\t69: MoveLoc[5](loc2: u256)\n\t70: Add\n\t71: StLoc[14](loc11: u256)\n\t72: MoveLoc[7](loc4: u8)\n\t73: LdU8(1)\n\t74: Add\n\t75: StLoc[7](loc4: u8)\n\t76: Branch(55)\nB10:\n\t77: MoveLoc[6](loc3: &mut RandomGenerator)\n\t78: Pop\n\t79: MoveLoc[14](loc11: u256)\n\t80: CastU256\n\t81: StLoc[12](loc9: u256)\n\t82: MoveLoc[9](loc6: u128)\n\t83: MoveLoc[12](loc9: u256)\n\t84: MoveLoc[13](loc10: u256)\n\t85: Mod\n\t86: CastU128\n\t87: Add\n\t88: StLoc[4](loc1: u128)\nB11:\n\t89: MoveLoc[4](loc1: u128)\n\t90: Ret\n}\n\npublic generate_u64_in_range(Arg0: &mut RandomGenerator, Arg1: u64, Arg2: u64): u64 {\nL3:\tloc0: u8\nL4:\tloc1: u64\nL5:\tloc2: u256\nL6:\tloc3: &mut RandomGenerator\nL7:\tloc4: u8\nL8:\tloc5: u64\nL9:\tloc6: u64\nL10:\tloc7: vector<u8>\nL11:\tloc8: u8\nL12:\tloc9: u256\nL13:\tloc10: u256\nL14:\tloc11: u256\nL15:\tloc12: u8\nB0:\n\t0: MoveLoc[1](Arg1: u64)\n\t1: StLoc[9](loc6: u64)\n\t2: MoveLoc[2](Arg2: u64)\n\t3: StLoc[8](loc5: u64)\n\t4: CopyLoc[9](loc6: u64)\n\t5: CopyLoc[8](loc5: u64)\n\t6: Le\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t10: Pop\n\t11: LdConst[3](u64: 3)\n\t12: Abort\nB3:\n\t13: CopyLoc[9](loc6: u64)\n\t14: CopyLoc[8](loc5: u64)\n\t15: Eq\n\t16: BrFalse(22)\nB4:\n\t17: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t18: Pop\n\t19: MoveLoc[9](loc6: u64)\n\t20: StLoc[4](loc1: u64)\n\t21: Branch(89)\nB5:\n\t22: MoveLoc[8](loc5: u64)\n\t23: CopyLoc[9](loc6: u64)\n\t24: Sub\n\t25: CastU256\n\t26: LdU256(1)\n\t27: Add\n\t28: StLoc[13](loc10: u256)\n\t29: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t30: StLoc[6](loc3: &mut RandomGenerator)\n\t31: LdU8(16)\n\t32: StLoc[11](loc8: u8)\n\t33: CopyLoc[6](loc3: &mut RandomGenerator)\n\t34: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t35: VecLen(17)\n\t36: CopyLoc[11](loc8: u8)\n\t37: CastU64\n\t38: Lt\n\t39: BrFalse(47)\nB6:\n\t40: CopyLoc[6](loc3: &mut RandomGenerator)\n\t41: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t42: StLoc[10](loc7: vector<u8>)\n\t43: CopyLoc[6](loc3: &mut RandomGenerator)\n\t44: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t45: MoveLoc[10](loc7: vector<u8>)\n\t46: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB7:\n\t47: LdU256(0)\n\t48: StLoc[14](loc11: u256)\n\t49: MoveLoc[11](loc8: u8)\n\t50: StLoc[3](loc0: u8)\n\t51: LdU8(0)\n\t52: StLoc[7](loc4: u8)\n\t53: MoveLoc[3](loc0: u8)\n\t54: StLoc[15](loc12: u8)\nB8:\n\t55: CopyLoc[7](loc4: u8)\n\t56: CopyLoc[15](loc12: u8)\n\t57: Lt\n\t58: BrFalse(77)\nB9:\n\t59: CopyLoc[7](loc4: u8)\n\t60: Pop\n\t61: CopyLoc[6](loc3: &mut RandomGenerator)\n\t62: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t63: VecPopBack(17)\n\t64: CastU256\n\t65: StLoc[5](loc2: u256)\n\t66: MoveLoc[14](loc11: u256)\n\t67: LdU8(8)\n\t68: Shl\n\t69: MoveLoc[5](loc2: u256)\n\t70: Add\n\t71: StLoc[14](loc11: u256)\n\t72: MoveLoc[7](loc4: u8)\n\t73: LdU8(1)\n\t74: Add\n\t75: StLoc[7](loc4: u8)\n\t76: Branch(55)\nB10:\n\t77: MoveLoc[6](loc3: &mut RandomGenerator)\n\t78: Pop\n\t79: MoveLoc[14](loc11: u256)\n\t80: CastU256\n\t81: StLoc[12](loc9: u256)\n\t82: MoveLoc[9](loc6: u64)\n\t83: MoveLoc[12](loc9: u256)\n\t84: MoveLoc[13](loc10: u256)\n\t85: Mod\n\t86: CastU64\n\t87: Add\n\t88: StLoc[4](loc1: u64)\nB11:\n\t89: MoveLoc[4](loc1: u64)\n\t90: Ret\n}\n\npublic generate_u32_in_range(Arg0: &mut RandomGenerator, Arg1: u32, Arg2: u32): u32 {\nL3:\tloc0: u8\nL4:\tloc1: u32\nL5:\tloc2: u256\nL6:\tloc3: &mut RandomGenerator\nL7:\tloc4: u8\nL8:\tloc5: u32\nL9:\tloc6: u32\nL10:\tloc7: vector<u8>\nL11:\tloc8: u8\nL12:\tloc9: u256\nL13:\tloc10: u256\nL14:\tloc11: u256\nL15:\tloc12: u8\nB0:\n\t0: MoveLoc[1](Arg1: u32)\n\t1: StLoc[9](loc6: u32)\n\t2: MoveLoc[2](Arg2: u32)\n\t3: StLoc[8](loc5: u32)\n\t4: CopyLoc[9](loc6: u32)\n\t5: CopyLoc[8](loc5: u32)\n\t6: Le\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t10: Pop\n\t11: LdConst[3](u64: 3)\n\t12: Abort\nB3:\n\t13: CopyLoc[9](loc6: u32)\n\t14: CopyLoc[8](loc5: u32)\n\t15: Eq\n\t16: BrFalse(22)\nB4:\n\t17: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t18: Pop\n\t19: MoveLoc[9](loc6: u32)\n\t20: StLoc[4](loc1: u32)\n\t21: Branch(89)\nB5:\n\t22: MoveLoc[8](loc5: u32)\n\t23: CopyLoc[9](loc6: u32)\n\t24: Sub\n\t25: CastU256\n\t26: LdU256(1)\n\t27: Add\n\t28: StLoc[13](loc10: u256)\n\t29: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t30: StLoc[6](loc3: &mut RandomGenerator)\n\t31: LdU8(12)\n\t32: StLoc[11](loc8: u8)\n\t33: CopyLoc[6](loc3: &mut RandomGenerator)\n\t34: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t35: VecLen(17)\n\t36: CopyLoc[11](loc8: u8)\n\t37: CastU64\n\t38: Lt\n\t39: BrFalse(47)\nB6:\n\t40: CopyLoc[6](loc3: &mut RandomGenerator)\n\t41: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t42: StLoc[10](loc7: vector<u8>)\n\t43: CopyLoc[6](loc3: &mut RandomGenerator)\n\t44: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t45: MoveLoc[10](loc7: vector<u8>)\n\t46: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB7:\n\t47: LdU256(0)\n\t48: StLoc[14](loc11: u256)\n\t49: MoveLoc[11](loc8: u8)\n\t50: StLoc[3](loc0: u8)\n\t51: LdU8(0)\n\t52: StLoc[7](loc4: u8)\n\t53: MoveLoc[3](loc0: u8)\n\t54: StLoc[15](loc12: u8)\nB8:\n\t55: CopyLoc[7](loc4: u8)\n\t56: CopyLoc[15](loc12: u8)\n\t57: Lt\n\t58: BrFalse(77)\nB9:\n\t59: CopyLoc[7](loc4: u8)\n\t60: Pop\n\t61: CopyLoc[6](loc3: &mut RandomGenerator)\n\t62: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t63: VecPopBack(17)\n\t64: CastU256\n\t65: StLoc[5](loc2: u256)\n\t66: MoveLoc[14](loc11: u256)\n\t67: LdU8(8)\n\t68: Shl\n\t69: MoveLoc[5](loc2: u256)\n\t70: Add\n\t71: StLoc[14](loc11: u256)\n\t72: MoveLoc[7](loc4: u8)\n\t73: LdU8(1)\n\t74: Add\n\t75: StLoc[7](loc4: u8)\n\t76: Branch(55)\nB10:\n\t77: MoveLoc[6](loc3: &mut RandomGenerator)\n\t78: Pop\n\t79: MoveLoc[14](loc11: u256)\n\t80: CastU256\n\t81: StLoc[12](loc9: u256)\n\t82: MoveLoc[9](loc6: u32)\n\t83: MoveLoc[12](loc9: u256)\n\t84: MoveLoc[13](loc10: u256)\n\t85: Mod\n\t86: CastU32\n\t87: Add\n\t88: StLoc[4](loc1: u32)\nB11:\n\t89: MoveLoc[4](loc1: u32)\n\t90: Ret\n}\n\npublic generate_u16_in_range(Arg0: &mut RandomGenerator, Arg1: u16, Arg2: u16): u16 {\nL3:\tloc0: u8\nL4:\tloc1: u16\nL5:\tloc2: u256\nL6:\tloc3: &mut RandomGenerator\nL7:\tloc4: u8\nL8:\tloc5: u16\nL9:\tloc6: u16\nL10:\tloc7: vector<u8>\nL11:\tloc8: u8\nL12:\tloc9: u256\nL13:\tloc10: u256\nL14:\tloc11: u256\nL15:\tloc12: u8\nB0:\n\t0: MoveLoc[1](Arg1: u16)\n\t1: StLoc[9](loc6: u16)\n\t2: MoveLoc[2](Arg2: u16)\n\t3: StLoc[8](loc5: u16)\n\t4: CopyLoc[9](loc6: u16)\n\t5: CopyLoc[8](loc5: u16)\n\t6: Le\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t10: Pop\n\t11: LdConst[3](u64: 3)\n\t12: Abort\nB3:\n\t13: CopyLoc[9](loc6: u16)\n\t14: CopyLoc[8](loc5: u16)\n\t15: Eq\n\t16: BrFalse(22)\nB4:\n\t17: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t18: Pop\n\t19: MoveLoc[9](loc6: u16)\n\t20: StLoc[4](loc1: u16)\n\t21: Branch(89)\nB5:\n\t22: MoveLoc[8](loc5: u16)\n\t23: CopyLoc[9](loc6: u16)\n\t24: Sub\n\t25: CastU256\n\t26: LdU256(1)\n\t27: Add\n\t28: StLoc[13](loc10: u256)\n\t29: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t30: StLoc[6](loc3: &mut RandomGenerator)\n\t31: LdU8(10)\n\t32: StLoc[11](loc8: u8)\n\t33: CopyLoc[6](loc3: &mut RandomGenerator)\n\t34: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t35: VecLen(17)\n\t36: CopyLoc[11](loc8: u8)\n\t37: CastU64\n\t38: Lt\n\t39: BrFalse(47)\nB6:\n\t40: CopyLoc[6](loc3: &mut RandomGenerator)\n\t41: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t42: StLoc[10](loc7: vector<u8>)\n\t43: CopyLoc[6](loc3: &mut RandomGenerator)\n\t44: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t45: MoveLoc[10](loc7: vector<u8>)\n\t46: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB7:\n\t47: LdU256(0)\n\t48: StLoc[14](loc11: u256)\n\t49: MoveLoc[11](loc8: u8)\n\t50: StLoc[3](loc0: u8)\n\t51: LdU8(0)\n\t52: StLoc[7](loc4: u8)\n\t53: MoveLoc[3](loc0: u8)\n\t54: StLoc[15](loc12: u8)\nB8:\n\t55: CopyLoc[7](loc4: u8)\n\t56: CopyLoc[15](loc12: u8)\n\t57: Lt\n\t58: BrFalse(77)\nB9:\n\t59: CopyLoc[7](loc4: u8)\n\t60: Pop\n\t61: CopyLoc[6](loc3: &mut RandomGenerator)\n\t62: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t63: VecPopBack(17)\n\t64: CastU256\n\t65: StLoc[5](loc2: u256)\n\t66: MoveLoc[14](loc11: u256)\n\t67: LdU8(8)\n\t68: Shl\n\t69: MoveLoc[5](loc2: u256)\n\t70: Add\n\t71: StLoc[14](loc11: u256)\n\t72: MoveLoc[7](loc4: u8)\n\t73: LdU8(1)\n\t74: Add\n\t75: StLoc[7](loc4: u8)\n\t76: Branch(55)\nB10:\n\t77: MoveLoc[6](loc3: &mut RandomGenerator)\n\t78: Pop\n\t79: MoveLoc[14](loc11: u256)\n\t80: CastU256\n\t81: StLoc[12](loc9: u256)\n\t82: MoveLoc[9](loc6: u16)\n\t83: MoveLoc[12](loc9: u256)\n\t84: MoveLoc[13](loc10: u256)\n\t85: Mod\n\t86: CastU16\n\t87: Add\n\t88: StLoc[4](loc1: u16)\nB11:\n\t89: MoveLoc[4](loc1: u16)\n\t90: Ret\n}\n\npublic generate_u8_in_range(Arg0: &mut RandomGenerator, Arg1: u8, Arg2: u8): u8 {\nL3:\tloc0: u8\nL4:\tloc1: u8\nL5:\tloc2: u256\nL6:\tloc3: &mut RandomGenerator\nL7:\tloc4: u8\nL8:\tloc5: u8\nL9:\tloc6: u8\nL10:\tloc7: vector<u8>\nL11:\tloc8: u8\nL12:\tloc9: u256\nL13:\tloc10: u256\nL14:\tloc11: u256\nL15:\tloc12: u8\nB0:\n\t0: MoveLoc[1](Arg1: u8)\n\t1: StLoc[9](loc6: u8)\n\t2: MoveLoc[2](Arg2: u8)\n\t3: StLoc[8](loc5: u8)\n\t4: CopyLoc[9](loc6: u8)\n\t5: CopyLoc[8](loc5: u8)\n\t6: Le\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t10: Pop\n\t11: LdConst[3](u64: 3)\n\t12: Abort\nB3:\n\t13: CopyLoc[9](loc6: u8)\n\t14: CopyLoc[8](loc5: u8)\n\t15: Eq\n\t16: BrFalse(22)\nB4:\n\t17: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t18: Pop\n\t19: MoveLoc[9](loc6: u8)\n\t20: StLoc[4](loc1: u8)\n\t21: Branch(89)\nB5:\n\t22: MoveLoc[8](loc5: u8)\n\t23: CopyLoc[9](loc6: u8)\n\t24: Sub\n\t25: CastU256\n\t26: LdU256(1)\n\t27: Add\n\t28: StLoc[13](loc10: u256)\n\t29: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t30: StLoc[6](loc3: &mut RandomGenerator)\n\t31: LdU8(9)\n\t32: StLoc[11](loc8: u8)\n\t33: CopyLoc[6](loc3: &mut RandomGenerator)\n\t34: ImmBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t35: VecLen(17)\n\t36: CopyLoc[11](loc8: u8)\n\t37: CastU64\n\t38: Lt\n\t39: BrFalse(47)\nB6:\n\t40: CopyLoc[6](loc3: &mut RandomGenerator)\n\t41: Call derive_next_block(&mut RandomGenerator): vector<u8>\n\t42: StLoc[10](loc7: vector<u8>)\n\t43: CopyLoc[6](loc3: &mut RandomGenerator)\n\t44: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t45: MoveLoc[10](loc7: vector<u8>)\n\t46: Call vector::append<u8>(&mut vector<u8>, vector<u8>)\nB7:\n\t47: LdU256(0)\n\t48: StLoc[14](loc11: u256)\n\t49: MoveLoc[11](loc8: u8)\n\t50: StLoc[3](loc0: u8)\n\t51: LdU8(0)\n\t52: StLoc[7](loc4: u8)\n\t53: MoveLoc[3](loc0: u8)\n\t54: StLoc[15](loc12: u8)\nB8:\n\t55: CopyLoc[7](loc4: u8)\n\t56: CopyLoc[15](loc12: u8)\n\t57: Lt\n\t58: BrFalse(77)\nB9:\n\t59: CopyLoc[7](loc4: u8)\n\t60: Pop\n\t61: CopyLoc[6](loc3: &mut RandomGenerator)\n\t62: MutBorrowField[7](RandomGenerator.buffer: vector<u8>)\n\t63: VecPopBack(17)\n\t64: CastU256\n\t65: StLoc[5](loc2: u256)\n\t66: MoveLoc[14](loc11: u256)\n\t67: LdU8(8)\n\t68: Shl\n\t69: MoveLoc[5](loc2: u256)\n\t70: Add\n\t71: StLoc[14](loc11: u256)\n\t72: MoveLoc[7](loc4: u8)\n\t73: LdU8(1)\n\t74: Add\n\t75: StLoc[7](loc4: u8)\n\t76: Branch(55)\nB10:\n\t77: MoveLoc[6](loc3: &mut RandomGenerator)\n\t78: Pop\n\t79: MoveLoc[14](loc11: u256)\n\t80: CastU256\n\t81: StLoc[12](loc9: u256)\n\t82: MoveLoc[9](loc6: u8)\n\t83: MoveLoc[12](loc9: u256)\n\t84: MoveLoc[13](loc10: u256)\n\t85: Mod\n\t86: CastU8\n\t87: Add\n\t88: StLoc[4](loc1: u8)\nB11:\n\t89: MoveLoc[4](loc1: u8)\n\t90: Ret\n}\n\npublic shuffle<Ty0>(Arg0: &mut RandomGenerator, Arg1: &mut vector<Ty0>) {\nL2:\tloc0: u16\nL3:\tloc1: u16\nL4:\tloc2: u16\nL5:\tloc3: u16\nL6:\tloc4: u16\nL7:\tloc5: u64\nL8:\tloc6: u16\nB0:\n\t0: CopyLoc[1](Arg1: &mut vector<Ty0>)\n\t1: FreezeRef\n\t2: VecLen(33)\n\t3: StLoc[7](loc5: u64)\n\t4: CopyLoc[7](loc5: u64)\n\t5: LdU64(0)\n\t6: Eq\n\t7: BrFalse(13)\nB1:\n\t8: MoveLoc[1](Arg1: &mut vector<Ty0>)\n\t9: Pop\n\t10: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t11: Pop\n\t12: Ret\nB2:\n\t13: CopyLoc[7](loc5: u64)\n\t14: LdConst[6](u64: 65535)\n\t15: Le\n\t16: BrFalse(18)\nB3:\n\t17: Branch(24)\nB4:\n\t18: MoveLoc[1](Arg1: &mut vector<Ty0>)\n\t19: Pop\n\t20: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t21: Pop\n\t22: LdConst[4](u64: 4)\n\t23: Abort\nB5:\n\t24: MoveLoc[7](loc5: u64)\n\t25: CastU16\n\t26: LdU16(1)\n\t27: Sub\n\t28: StLoc[3](loc1: u16)\n\t29: CopyLoc[3](loc1: u16)\n\t30: StLoc[2](loc0: u16)\n\t31: LdU16(0)\n\t32: StLoc[4](loc2: u16)\n\t33: MoveLoc[2](loc0: u16)\n\t34: StLoc[8](loc6: u16)\nB6:\n\t35: CopyLoc[4](loc2: u16)\n\t36: CopyLoc[8](loc6: u16)\n\t37: Lt\n\t38: BrFalse(57)\nB7:\n\t39: CopyLoc[4](loc2: u16)\n\t40: StLoc[5](loc3: u16)\n\t41: CopyLoc[0](Arg0: &mut RandomGenerator)\n\t42: CopyLoc[5](loc3: u16)\n\t43: CopyLoc[3](loc1: u16)\n\t44: Call generate_u16_in_range(&mut RandomGenerator, u16, u16): u16\n\t45: StLoc[6](loc4: u16)\n\t46: CopyLoc[1](Arg1: &mut vector<Ty0>)\n\t47: MoveLoc[5](loc3: u16)\n\t48: CastU64\n\t49: MoveLoc[6](loc4: u16)\n\t50: CastU64\n\t51: VecSwap(33)\n\t52: MoveLoc[4](loc2: u16)\n\t53: LdU16(1)\n\t54: Add\n\t55: StLoc[4](loc2: u16)\n\t56: Branch(35)\nB8:\n\t57: MoveLoc[1](Arg1: &mut vector<Ty0>)\n\t58: Pop\n\t59: MoveLoc[0](Arg0: &mut RandomGenerator)\n\t60: Pop\n\t61: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u16: 32\n\t6 => u64: 65535\n\t7 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n\t8 => vector<u8>: \"\" // interpreted as UTF8 string\n]\n}\n","sui":"// Move bytecode v6\nmodule 2.sui {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::url;\n\nstruct SUI has drop {\n\tdummy_field: bool\n}\n\nnew(Arg0: &mut TxContext): Balance<SUI> {\nL1:\tloc0: CoinMetadata<SUI>\nL2:\tloc1: Supply<SUI>\nL3:\tloc2: Balance<SUI>\nL4:\tloc3: TreasuryCap<SUI>\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::sender(&TxContext): address\n\t3: LdConst[5](address: 0x00..)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut TxContext)\n\t8: Pop\n\t9: LdConst[1](u64: 1)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut TxContext)\n\t12: FreezeRef\n\t13: Call tx_context::epoch(&TxContext): u64\n\t14: LdU64(0)\n\t15: Eq\n\t16: BrFalse(18)\nB4:\n\t17: Branch(22)\nB5:\n\t18: MoveLoc[0](Arg0: &mut TxContext)\n\t19: Pop\n\t20: LdConst[0](u64: 0)\n\t21: Abort\nB6:\n\t22: LdFalse\n\t23: Pack[0](SUI)\n\t24: LdU8(9)\n\t25: LdConst[6](vector<u8>: \"SUI..)\n\t26: LdConst[7](vector<u8>: \"Sui..)\n\t27: LdConst[8](vector<u8>: \"\" /..)\n\t28: Call option::none<Url>(): Option<Url>\n\t29: MoveLoc[0](Arg0: &mut TxContext)\n\t30: Call coin::create_currency<SUI>(SUI, u8, vector<u8>, vector<u8>, vector<u8>, Option<Url>, &mut TxContext): TreasuryCap<SUI> * CoinMetadata<SUI>\n\t31: StLoc[1](loc0: CoinMetadata<SUI>)\n\t32: StLoc[4](loc3: TreasuryCap<SUI>)\n\t33: MoveLoc[1](loc0: CoinMetadata<SUI>)\n\t34: Call transfer::public_freeze_object<CoinMetadata<SUI>>(CoinMetadata<SUI>)\n\t35: MoveLoc[4](loc3: TreasuryCap<SUI>)\n\t36: Call coin::treasury_into_supply<SUI>(TreasuryCap<SUI>): Supply<SUI>\n\t37: StLoc[2](loc1: Supply<SUI>)\n\t38: MutBorrowLoc[2](loc1: Supply<SUI>)\n\t39: LdConst[4](u64: 1000..)\n\t40: Call balance::increase_supply<SUI>(&mut Supply<SUI>, u64): Balance<SUI>\n\t41: StLoc[3](loc2: Balance<SUI>)\n\t42: MoveLoc[2](loc1: Supply<SUI>)\n\t43: Call balance::destroy_supply<SUI>(Supply<SUI>): u64\n\t44: Pop\n\t45: MoveLoc[3](loc2: Balance<SUI>)\n\t46: Ret\n}\n\nentry public transfer(Arg0: Coin<SUI>, Arg1: address) {\nB0:\n\t0: MoveLoc[0](Arg0: Coin<SUI>)\n\t1: MoveLoc[1](Arg1: address)\n\t2: Call transfer::public_transfer<Coin<SUI>>(Coin<SUI>, address)\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 1000000000\n\t3 => u64: 10000000000\n\t4 => u64: 10000000000000000000\n\t5 => address: 0x0000000000000000000000000000000000000000000000000000000000000000\n\t6 => vector<u8>: \"SUI\" // interpreted as UTF8 string\n\t7 => vector<u8>: \"Sui\" // interpreted as UTF8 string\n\t8 => vector<u8>: \"\" // interpreted as UTF8 string\n]\n}\n","table":"// Move bytecode v6\nmodule 2.table {\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Table<phantom Ty0: copy + drop + store, phantom Ty1: store> has store, key {\n\tid: UID,\n\tsize: u64\n}\n\npublic new<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut TxContext): Table<Ty0, Ty1> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: LdU64(0)\n\t3: PackGeneric[0](Table<Ty0, Ty1>)\n\t4: Ret\n}\n\npublic add<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut Table<Ty0, Ty1>, Arg1: Ty0, Arg2: Ty1) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Table<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[0](Table.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: MoveLoc[2](Arg2: Ty1)\n\t4: Call dynamic_field::add<Ty0, Ty1>(&mut UID, Ty0, Ty1)\n\t5: CopyLoc[0](Arg0: &mut Table<Ty0, Ty1>)\n\t6: ImmBorrowFieldGeneric[1](Table.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Add\n\t10: MoveLoc[0](Arg0: &mut Table<Ty0, Ty1>)\n\t11: MutBorrowFieldGeneric[1](Table.size: u64)\n\t12: WriteRef\n\t13: Ret\n}\n\npublic borrow<Ty0: copy + drop + store, Ty1: store>(Arg0: &Table<Ty0, Ty1>, Arg1: Ty0): &Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &Table<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](Table.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow<Ty0, Ty1>(&UID, Ty0): &Ty1\n\t4: Ret\n}\n\npublic borrow_mut<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut Table<Ty0, Ty1>, Arg1: Ty0): &mut Ty1 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Table<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[0](Table.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::borrow_mut<Ty0, Ty1>(&mut UID, Ty0): &mut Ty1\n\t4: Ret\n}\n\npublic remove<Ty0: copy + drop + store, Ty1: store>(Arg0: &mut Table<Ty0, Ty1>, Arg1: Ty0): Ty1 {\nL2:\tloc0: Ty1\nB0:\n\t0: CopyLoc[0](Arg0: &mut Table<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[0](Table.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::remove<Ty0, Ty1>(&mut UID, Ty0): Ty1\n\t4: StLoc[2](loc0: Ty1)\n\t5: CopyLoc[0](Arg0: &mut Table<Ty0, Ty1>)\n\t6: ImmBorrowFieldGeneric[1](Table.size: u64)\n\t7: ReadRef\n\t8: LdU64(1)\n\t9: Sub\n\t10: MoveLoc[0](Arg0: &mut Table<Ty0, Ty1>)\n\t11: MutBorrowFieldGeneric[1](Table.size: u64)\n\t12: WriteRef\n\t13: MoveLoc[2](loc0: Ty1)\n\t14: Ret\n}\n\npublic contains<Ty0: copy + drop + store, Ty1: store>(Arg0: &Table<Ty0, Ty1>, Arg1: Ty0): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Table<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](Table.id: UID)\n\t2: MoveLoc[1](Arg1: Ty0)\n\t3: Call dynamic_field::exists_with_type<Ty0, Ty1>(&UID, Ty0): bool\n\t4: Ret\n}\n\npublic length<Ty0: copy + drop + store, Ty1: store>(Arg0: &Table<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Table<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[1](Table.size: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic is_empty<Ty0: copy + drop + store, Ty1: store>(Arg0: &Table<Ty0, Ty1>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Table<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[1](Table.size: u64)\n\t2: ReadRef\n\t3: LdU64(0)\n\t4: Eq\n\t5: Ret\n}\n\npublic destroy_empty<Ty0: copy + drop + store, Ty1: store>(Arg0: Table<Ty0, Ty1>) {\nL1:\tloc0: UID\nL2:\tloc1: u64\nB0:\n\t0: MoveLoc[0](Arg0: Table<Ty0, Ty1>)\n\t1: UnpackGeneric[0](Table<Ty0, Ty1>)\n\t2: StLoc[2](loc1: u64)\n\t3: StLoc[1](loc0: UID)\n\t4: MoveLoc[2](loc1: u64)\n\t5: LdU64(0)\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(11)\nB2:\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[1](loc0: UID)\n\t12: Call object::delete(UID)\n\t13: Ret\n}\n\npublic drop<Ty0: copy + drop + store, Ty1: drop + store>(Arg0: Table<Ty0, Ty1>) {\nB0:\n\t0: MoveLoc[0](Arg0: Table<Ty0, Ty1>)\n\t1: UnpackGeneric[0](Table<Ty0, Ty1>)\n\t2: Pop\n\t3: Call object::delete(UID)\n\t4: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n","table_vec":"// Move bytecode v6\nmodule 2.table_vec {\nuse 0000000000000000000000000000000000000000000000000000000000000002::table;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct TableVec<phantom Ty0: store> has store {\n\tcontents: Table<u64, Ty0>\n}\n\npublic empty<Ty0: store>(Arg0: &mut TxContext): TableVec<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call table::new<u64, Ty0>(&mut TxContext): Table<u64, Ty0>\n\t2: PackGeneric[0](TableVec<Ty0>)\n\t3: Ret\n}\n\npublic singleton<Ty0: store>(Arg0: Ty0, Arg1: &mut TxContext): TableVec<Ty0> {\nL2:\tloc0: TableVec<Ty0>\nB0:\n\t0: MoveLoc[1](Arg1: &mut TxContext)\n\t1: Call empty<Ty0>(&mut TxContext): TableVec<Ty0>\n\t2: StLoc[2](loc0: TableVec<Ty0>)\n\t3: MutBorrowLoc[2](loc0: TableVec<Ty0>)\n\t4: MoveLoc[0](Arg0: Ty0)\n\t5: Call push_back<Ty0>(&mut TableVec<Ty0>, Ty0)\n\t6: MoveLoc[2](loc0: TableVec<Ty0>)\n\t7: Ret\n}\n\npublic length<Ty0: store>(Arg0: &TableVec<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &TableVec<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t2: Call table::length<u64, Ty0>(&Table<u64, Ty0>): u64\n\t3: Ret\n}\n\npublic is_empty<Ty0: store>(Arg0: &TableVec<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &TableVec<Ty0>)\n\t1: Call length<Ty0>(&TableVec<Ty0>): u64\n\t2: LdU64(0)\n\t3: Eq\n\t4: Ret\n}\n\npublic borrow<Ty0: store>(Arg0: &TableVec<Ty0>, Arg1: u64): &Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: &TableVec<Ty0>)\n\t1: Call length<Ty0>(&TableVec<Ty0>): u64\n\t2: CopyLoc[1](Arg1: u64)\n\t3: Gt\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &TableVec<Ty0>)\n\t7: Pop\n\t8: LdConst[0](u64: 0)\n\t9: Abort\nB3:\n\t10: MoveLoc[0](Arg0: &TableVec<Ty0>)\n\t11: ImmBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t12: MoveLoc[1](Arg1: u64)\n\t13: Call table::borrow<u64, Ty0>(&Table<u64, Ty0>, u64): &Ty0\n\t14: Ret\n}\n\npublic push_back<Ty0: store>(Arg0: &mut TableVec<Ty0>, Arg1: Ty0) {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t1: FreezeRef\n\t2: Call length<Ty0>(&TableVec<Ty0>): u64\n\t3: StLoc[2](loc0: u64)\n\t4: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t5: MutBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t6: MoveLoc[2](loc0: u64)\n\t7: MoveLoc[1](Arg1: Ty0)\n\t8: Call table::add<u64, Ty0>(&mut Table<u64, Ty0>, u64, Ty0)\n\t9: Ret\n}\n\npublic borrow_mut<Ty0: store>(Arg0: &mut TableVec<Ty0>, Arg1: u64): &mut Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t1: FreezeRef\n\t2: Call length<Ty0>(&TableVec<Ty0>): u64\n\t3: CopyLoc[1](Arg1: u64)\n\t4: Gt\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t12: MutBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t13: MoveLoc[1](Arg1: u64)\n\t14: Call table::borrow_mut<u64, Ty0>(&mut Table<u64, Ty0>, u64): &mut Ty0\n\t15: Ret\n}\n\npublic pop_back<Ty0: store>(Arg0: &mut TableVec<Ty0>): Ty0 {\nL1:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t1: FreezeRef\n\t2: Call length<Ty0>(&TableVec<Ty0>): u64\n\t3: StLoc[1](loc0: u64)\n\t4: CopyLoc[1](loc0: u64)\n\t5: LdU64(0)\n\t6: Gt\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t14: MutBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t15: MoveLoc[1](loc0: u64)\n\t16: LdU64(1)\n\t17: Sub\n\t18: Call table::remove<u64, Ty0>(&mut Table<u64, Ty0>, u64): Ty0\n\t19: Ret\n}\n\npublic destroy_empty<Ty0: store>(Arg0: TableVec<Ty0>) {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: TableVec<Ty0>)\n\t1: Call length<Ty0>(&TableVec<Ty0>): u64\n\t2: LdU64(0)\n\t3: Eq\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[1](u64: 1)\n\t7: Abort\nB3:\n\t8: MoveLoc[0](Arg0: TableVec<Ty0>)\n\t9: UnpackGeneric[0](TableVec<Ty0>)\n\t10: Call table::destroy_empty<u64, Ty0>(Table<u64, Ty0>)\n\t11: Ret\n}\n\npublic drop<Ty0: drop + store>(Arg0: TableVec<Ty0>) {\nB0:\n\t0: MoveLoc[0](Arg0: TableVec<Ty0>)\n\t1: UnpackGeneric[0](TableVec<Ty0>)\n\t2: Call table::drop<u64, Ty0>(Table<u64, Ty0>)\n\t3: Ret\n}\n\npublic swap<Ty0: store>(Arg0: &mut TableVec<Ty0>, Arg1: u64, Arg2: u64) {\nL3:\tloc0: Ty0\nL4:\tloc1: Ty0\nB0:\n\t0: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t1: FreezeRef\n\t2: Call length<Ty0>(&TableVec<Ty0>): u64\n\t3: CopyLoc[1](Arg1: u64)\n\t4: Gt\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t12: FreezeRef\n\t13: Call length<Ty0>(&TableVec<Ty0>): u64\n\t14: CopyLoc[2](Arg2: u64)\n\t15: Gt\n\t16: BrFalse(18)\nB4:\n\t17: Branch(22)\nB5:\n\t18: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t19: Pop\n\t20: LdConst[0](u64: 0)\n\t21: Abort\nB6:\n\t22: CopyLoc[1](Arg1: u64)\n\t23: CopyLoc[2](Arg2: u64)\n\t24: Eq\n\t25: BrFalse(29)\nB7:\n\t26: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t27: Pop\n\t28: Ret\nB8:\n\t29: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t30: MutBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t31: CopyLoc[1](Arg1: u64)\n\t32: Call table::remove<u64, Ty0>(&mut Table<u64, Ty0>, u64): Ty0\n\t33: StLoc[3](loc0: Ty0)\n\t34: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t35: MutBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t36: CopyLoc[2](Arg2: u64)\n\t37: Call table::remove<u64, Ty0>(&mut Table<u64, Ty0>, u64): Ty0\n\t38: StLoc[4](loc1: Ty0)\n\t39: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t40: MutBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t41: MoveLoc[2](Arg2: u64)\n\t42: MoveLoc[3](loc0: Ty0)\n\t43: Call table::add<u64, Ty0>(&mut Table<u64, Ty0>, u64, Ty0)\n\t44: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t45: MutBorrowFieldGeneric[0](TableVec.contents: Table<u64, Ty0>)\n\t46: MoveLoc[1](Arg1: u64)\n\t47: MoveLoc[4](loc1: Ty0)\n\t48: Call table::add<u64, Ty0>(&mut Table<u64, Ty0>, u64, Ty0)\n\t49: Ret\n}\n\npublic swap_remove<Ty0: store>(Arg0: &mut TableVec<Ty0>, Arg1: u64): Ty0 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t1: FreezeRef\n\t2: Call length<Ty0>(&TableVec<Ty0>): u64\n\t3: CopyLoc[1](Arg1: u64)\n\t4: Gt\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t12: FreezeRef\n\t13: Call length<Ty0>(&TableVec<Ty0>): u64\n\t14: LdU64(1)\n\t15: Sub\n\t16: StLoc[2](loc0: u64)\n\t17: CopyLoc[0](Arg0: &mut TableVec<Ty0>)\n\t18: MoveLoc[1](Arg1: u64)\n\t19: MoveLoc[2](loc0: u64)\n\t20: Call swap<Ty0>(&mut TableVec<Ty0>, u64, u64)\n\t21: MoveLoc[0](Arg0: &mut TableVec<Ty0>)\n\t22: Call pop_back<Ty0>(&mut TableVec<Ty0>): Ty0\n\t23: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n]\n}\n","token":"// Move bytecode v6\nmodule 2.token {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::vec_map;\nuse 0000000000000000000000000000000000000000000000000000000000000002::vec_set;\n\nstruct Token<phantom Ty0> has key {\n\tid: UID,\n\tbalance: Balance<Ty0>\n}\n\nstruct TokenPolicyCap<phantom Ty0> has store, key {\n\tid: UID,\n\tfor: ID\n}\n\nstruct TokenPolicy<phantom Ty0> has key {\n\tid: UID,\n\tspent_balance: Balance<Ty0>,\n\trules: VecMap<String, VecSet<TypeName>>\n}\n\nstruct ActionRequest<phantom Ty0> {\n\tname: String,\n\tamount: u64,\n\tsender: address,\n\trecipient: Option<address>,\n\tspent_balance: Option<Balance<Ty0>>,\n\tapprovals: VecSet<TypeName>\n}\n\nstruct RuleKey<phantom Ty0> has copy, drop, store {\n\tis_protected: bool\n}\n\nstruct TokenPolicyCreated<phantom Ty0> has copy, drop {\n\tid: ID,\n\tis_mutable: bool\n}\n\npublic new_policy<Ty0>(Arg0: &TreasuryCap<Ty0>, Arg1: &mut TxContext): TokenPolicy<Ty0> * TokenPolicyCap<Ty0> {\nL2:\tloc0: TokenPolicyCap<Ty0>\nL3:\tloc1: TokenPolicy<Ty0>\nB0:\n\t0: CopyLoc[1](Arg1: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: Call balance::zero<Ty0>(): Balance<Ty0>\n\t3: Call vec_map::empty<String, VecSet<TypeName>>(): VecMap<String, VecSet<TypeName>>\n\t4: PackGeneric[0](TokenPolicy<Ty0>)\n\t5: StLoc[3](loc1: TokenPolicy<Ty0>)\n\t6: MoveLoc[1](Arg1: &mut TxContext)\n\t7: Call object::new(&mut TxContext): UID\n\t8: ImmBorrowLoc[3](loc1: TokenPolicy<Ty0>)\n\t9: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t10: PackGeneric[1](TokenPolicyCap<Ty0>)\n\t11: StLoc[2](loc0: TokenPolicyCap<Ty0>)\n\t12: MoveLoc[3](loc1: TokenPolicy<Ty0>)\n\t13: MoveLoc[2](loc0: TokenPolicyCap<Ty0>)\n\t14: Ret\n}\n\npublic share_policy<Ty0>(Arg0: TokenPolicy<Ty0>) {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: TokenPolicy<Ty0>)\n\t1: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t2: LdTrue\n\t3: PackGeneric[2](TokenPolicyCreated<Ty0>)\n\t4: Call event::emit<TokenPolicyCreated<Ty0>>(TokenPolicyCreated<Ty0>)\n\t5: MoveLoc[0](Arg0: TokenPolicy<Ty0>)\n\t6: Call transfer::share_object<TokenPolicy<Ty0>>(TokenPolicy<Ty0>)\n\t7: Ret\n}\n\npublic transfer<Ty0>(Arg0: Token<Ty0>, Arg1: address, Arg2: &mut TxContext): ActionRequest<Ty0> {\nL3:\tloc0: u64\nB0:\n\t0: ImmBorrowLoc[0](Arg0: Token<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Token.balance: Balance<Ty0>)\n\t2: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t3: StLoc[3](loc0: u64)\n\t4: MoveLoc[0](Arg0: Token<Ty0>)\n\t5: CopyLoc[1](Arg1: address)\n\t6: Call transfer::transfer<Token<Ty0>>(Token<Ty0>, address)\n\t7: Call transfer_action(): String\n\t8: MoveLoc[3](loc0: u64)\n\t9: MoveLoc[1](Arg1: address)\n\t10: Call option::some<address>(address): Option<address>\n\t11: Call option::none<Balance<Ty0>>(): Option<Balance<Ty0>>\n\t12: MoveLoc[2](Arg2: &mut TxContext)\n\t13: FreezeRef\n\t14: Call new_request<Ty0>(String, u64, Option<address>, Option<Balance<Ty0>>, &TxContext): ActionRequest<Ty0>\n\t15: Ret\n}\n\npublic spend<Ty0>(Arg0: Token<Ty0>, Arg1: &mut TxContext): ActionRequest<Ty0> {\nL2:\tloc0: Balance<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: Token<Ty0>)\n\t1: UnpackGeneric[3](Token<Ty0>)\n\t2: StLoc[2](loc0: Balance<Ty0>)\n\t3: Call object::delete(UID)\n\t4: Call spend_action(): String\n\t5: ImmBorrowLoc[2](loc0: Balance<Ty0>)\n\t6: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t7: Call option::none<address>(): Option<address>\n\t8: MoveLoc[2](loc0: Balance<Ty0>)\n\t9: Call option::some<Balance<Ty0>>(Balance<Ty0>): Option<Balance<Ty0>>\n\t10: MoveLoc[1](Arg1: &mut TxContext)\n\t11: FreezeRef\n\t12: Call new_request<Ty0>(String, u64, Option<address>, Option<Balance<Ty0>>, &TxContext): ActionRequest<Ty0>\n\t13: Ret\n}\n\npublic to_coin<Ty0>(Arg0: Token<Ty0>, Arg1: &mut TxContext): Coin<Ty0> * ActionRequest<Ty0> {\nL2:\tloc0: u64\nL3:\tloc1: Balance<Ty0>\nL4:\tloc2: UID\nB0:\n\t0: MoveLoc[0](Arg0: Token<Ty0>)\n\t1: UnpackGeneric[3](Token<Ty0>)\n\t2: StLoc[3](loc1: Balance<Ty0>)\n\t3: StLoc[4](loc2: UID)\n\t4: ImmBorrowLoc[3](loc1: Balance<Ty0>)\n\t5: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t6: StLoc[2](loc0: u64)\n\t7: MoveLoc[4](loc2: UID)\n\t8: Call object::delete(UID)\n\t9: MoveLoc[3](loc1: Balance<Ty0>)\n\t10: CopyLoc[1](Arg1: &mut TxContext)\n\t11: Call coin::from_balance<Ty0>(Balance<Ty0>, &mut TxContext): Coin<Ty0>\n\t12: Call to_coin_action(): String\n\t13: MoveLoc[2](loc0: u64)\n\t14: Call option::none<address>(): Option<address>\n\t15: Call option::none<Balance<Ty0>>(): Option<Balance<Ty0>>\n\t16: MoveLoc[1](Arg1: &mut TxContext)\n\t17: FreezeRef\n\t18: Call new_request<Ty0>(String, u64, Option<address>, Option<Balance<Ty0>>, &TxContext): ActionRequest<Ty0>\n\t19: Ret\n}\n\npublic from_coin<Ty0>(Arg0: Coin<Ty0>, Arg1: &mut TxContext): Token<Ty0> * ActionRequest<Ty0> {\nL2:\tloc0: u64\nB0:\n\t0: ImmBorrowLoc[0](Arg0: Coin<Ty0>)\n\t1: Call coin::value<Ty0>(&Coin<Ty0>): u64\n\t2: StLoc[2](loc0: u64)\n\t3: CopyLoc[1](Arg1: &mut TxContext)\n\t4: Call object::new(&mut TxContext): UID\n\t5: MoveLoc[0](Arg0: Coin<Ty0>)\n\t6: Call coin::into_balance<Ty0>(Coin<Ty0>): Balance<Ty0>\n\t7: PackGeneric[3](Token<Ty0>)\n\t8: Call from_coin_action(): String\n\t9: MoveLoc[2](loc0: u64)\n\t10: Call option::none<address>(): Option<address>\n\t11: Call option::none<Balance<Ty0>>(): Option<Balance<Ty0>>\n\t12: MoveLoc[1](Arg1: &mut TxContext)\n\t13: FreezeRef\n\t14: Call new_request<Ty0>(String, u64, Option<address>, Option<Balance<Ty0>>, &TxContext): ActionRequest<Ty0>\n\t15: Ret\n}\n\npublic join<Ty0>(Arg0: &mut Token<Ty0>, Arg1: Token<Ty0>) {\nL2:\tloc0: Balance<Ty0>\nL3:\tloc1: UID\nB0:\n\t0: MoveLoc[1](Arg1: Token<Ty0>)\n\t1: UnpackGeneric[3](Token<Ty0>)\n\t2: StLoc[2](loc0: Balance<Ty0>)\n\t3: StLoc[3](loc1: UID)\n\t4: MoveLoc[0](Arg0: &mut Token<Ty0>)\n\t5: MutBorrowFieldGeneric[0](Token.balance: Balance<Ty0>)\n\t6: MoveLoc[2](loc0: Balance<Ty0>)\n\t7: Call balance::join<Ty0>(&mut Balance<Ty0>, Balance<Ty0>): u64\n\t8: Pop\n\t9: MoveLoc[3](loc1: UID)\n\t10: Call object::delete(UID)\n\t11: Ret\n}\n\npublic split<Ty0>(Arg0: &mut Token<Ty0>, Arg1: u64, Arg2: &mut TxContext): Token<Ty0> {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Token<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Token.balance: Balance<Ty0>)\n\t2: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t3: CopyLoc[1](Arg1: u64)\n\t4: Ge\n\t5: BrFalse(7)\nB1:\n\t6: Branch(13)\nB2:\n\t7: MoveLoc[0](Arg0: &mut Token<Ty0>)\n\t8: Pop\n\t9: MoveLoc[2](Arg2: &mut TxContext)\n\t10: Pop\n\t11: LdConst[3](u64: 3)\n\t12: Abort\nB3:\n\t13: MoveLoc[2](Arg2: &mut TxContext)\n\t14: Call object::new(&mut TxContext): UID\n\t15: MoveLoc[0](Arg0: &mut Token<Ty0>)\n\t16: MutBorrowFieldGeneric[0](Token.balance: Balance<Ty0>)\n\t17: MoveLoc[1](Arg1: u64)\n\t18: Call balance::split<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t19: PackGeneric[3](Token<Ty0>)\n\t20: Ret\n}\n\npublic zero<Ty0>(Arg0: &mut TxContext): Token<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: Call balance::zero<Ty0>(): Balance<Ty0>\n\t3: PackGeneric[3](Token<Ty0>)\n\t4: Ret\n}\n\npublic destroy_zero<Ty0>(Arg0: Token<Ty0>) {\nL1:\tloc0: Balance<Ty0>\nL2:\tloc1: UID\nB0:\n\t0: MoveLoc[0](Arg0: Token<Ty0>)\n\t1: UnpackGeneric[3](Token<Ty0>)\n\t2: StLoc[1](loc0: Balance<Ty0>)\n\t3: StLoc[2](loc1: UID)\n\t4: ImmBorrowLoc[1](loc0: Balance<Ty0>)\n\t5: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t6: LdU64(0)\n\t7: Eq\n\t8: BrFalse(10)\nB1:\n\t9: Branch(12)\nB2:\n\t10: LdConst[4](u64: 4)\n\t11: Abort\nB3:\n\t12: MoveLoc[1](loc0: Balance<Ty0>)\n\t13: Call balance::destroy_zero<Ty0>(Balance<Ty0>)\n\t14: MoveLoc[2](loc1: UID)\n\t15: Call object::delete(UID)\n\t16: Ret\n}\n\npublic keep<Ty0>(Arg0: Token<Ty0>, Arg1: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: Token<Ty0>)\n\t1: MoveLoc[1](Arg1: &mut TxContext)\n\t2: FreezeRef\n\t3: Call tx_context::sender(&TxContext): address\n\t4: Call transfer::transfer<Token<Ty0>>(Token<Ty0>, address)\n\t5: Ret\n}\n\npublic new_request<Ty0>(Arg0: String, Arg1: u64, Arg2: Option<address>, Arg3: Option<Balance<Ty0>>, Arg4: &TxContext): ActionRequest<Ty0> {\nL5:\tloc0: String\nL6:\tloc1: u64\nL7:\tloc2: Option<address>\nL8:\tloc3: Option<Balance<Ty0>>\nL9:\tloc4: address\nL10:\tloc5: VecSet<TypeName>\nB0:\n\t0: MoveLoc[0](Arg0: String)\n\t1: StLoc[5](loc0: String)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: StLoc[6](loc1: u64)\n\t4: MoveLoc[2](Arg2: Option<address>)\n\t5: StLoc[7](loc2: Option<address>)\n\t6: MoveLoc[3](Arg3: Option<Balance<Ty0>>)\n\t7: StLoc[8](loc3: Option<Balance<Ty0>>)\n\t8: MoveLoc[4](Arg4: &TxContext)\n\t9: Call tx_context::sender(&TxContext): address\n\t10: StLoc[9](loc4: address)\n\t11: Call vec_set::empty<TypeName>(): VecSet<TypeName>\n\t12: StLoc[10](loc5: VecSet<TypeName>)\n\t13: MoveLoc[5](loc0: String)\n\t14: MoveLoc[6](loc1: u64)\n\t15: MoveLoc[9](loc4: address)\n\t16: MoveLoc[7](loc2: Option<address>)\n\t17: MoveLoc[8](loc3: Option<Balance<Ty0>>)\n\t18: MoveLoc[10](loc5: VecSet<TypeName>)\n\t19: PackGeneric[4](ActionRequest<Ty0>)\n\t20: Ret\n}\n\npublic confirm_request<Ty0>(Arg0: &TokenPolicy<Ty0>, Arg1: ActionRequest<Ty0>, Arg2: &mut TxContext): String * u64 * address * Option<address> {\nL3:\tloc0: vector<TypeName>\nL4:\tloc1: u64\nL5:\tloc2: VecSet<TypeName>\nL6:\tloc3: u64\nL7:\tloc4: String\nL8:\tloc5: Option<address>\nL9:\tloc6: &TypeName\nL10:\tloc7: &vector<TypeName>\nL11:\tloc8: u64\nL12:\tloc9: address\nL13:\tloc10: Option<Balance<Ty0>>\nB0:\n\t0: ImmBorrowLoc[1](Arg1: ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](ActionRequest.spent_balance: Option<Balance<Ty0>>)\n\t2: Call option::is_none<Balance<Ty0>>(&Option<Balance<Ty0>>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t6: Pop\n\t7: LdConst[5](u64: 5)\n\t8: Abort\nB3:\n\t9: CopyLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t10: ImmBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t11: ImmBorrowLoc[1](Arg1: ActionRequest<Ty0>)\n\t12: ImmBorrowFieldGeneric[3](ActionRequest.name: String)\n\t13: Call vec_map::contains<String, VecSet<TypeName>>(&VecMap<String, VecSet<TypeName>>, &String): bool\n\t14: BrFalse(16)\nB4:\n\t15: Branch(20)\nB5:\n\t16: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t17: Pop\n\t18: LdConst[0](u64: 0)\n\t19: Abort\nB6:\n\t20: MoveLoc[1](Arg1: ActionRequest<Ty0>)\n\t21: UnpackGeneric[4](ActionRequest<Ty0>)\n\t22: StLoc[5](loc2: VecSet<TypeName>)\n\t23: StLoc[13](loc10: Option<Balance<Ty0>>)\n\t24: StLoc[8](loc5: Option<address>)\n\t25: StLoc[12](loc9: address)\n\t26: StLoc[4](loc1: u64)\n\t27: StLoc[7](loc4: String)\n\t28: MoveLoc[13](loc10: Option<Balance<Ty0>>)\n\t29: Call option::destroy_none<Balance<Ty0>>(Option<Balance<Ty0>>)\n\t30: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t31: ImmBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t32: ImmBorrowLoc[7](loc4: String)\n\t33: Call vec_map::get<String, VecSet<TypeName>>(&VecMap<String, VecSet<TypeName>>, &String): &VecSet<TypeName>\n\t34: ReadRef\n\t35: Call vec_set::into_keys<TypeName>(VecSet<TypeName>): vector<TypeName>\n\t36: StLoc[3](loc0: vector<TypeName>)\n\t37: ImmBorrowLoc[3](loc0: vector<TypeName>)\n\t38: StLoc[10](loc7: &vector<TypeName>)\n\t39: CopyLoc[10](loc7: &vector<TypeName>)\n\t40: VecLen(65)\n\t41: StLoc[11](loc8: u64)\n\t42: LdU64(0)\n\t43: StLoc[6](loc3: u64)\nB7:\n\t44: CopyLoc[6](loc3: u64)\n\t45: CopyLoc[11](loc8: u64)\n\t46: Lt\n\t47: BrFalse(66)\nB8:\n\t48: CopyLoc[10](loc7: &vector<TypeName>)\n\t49: CopyLoc[6](loc3: u64)\n\t50: VecImmBorrow(65)\n\t51: StLoc[9](loc6: &TypeName)\n\t52: ImmBorrowLoc[5](loc2: VecSet<TypeName>)\n\t53: MoveLoc[9](loc6: &TypeName)\n\t54: Call vec_set::contains<TypeName>(&VecSet<TypeName>, &TypeName): bool\n\t55: BrFalse(57)\nB9:\n\t56: Branch(61)\nB10:\n\t57: MoveLoc[10](loc7: &vector<TypeName>)\n\t58: Pop\n\t59: LdConst[1](u64: 1)\n\t60: Abort\nB11:\n\t61: MoveLoc[6](loc3: u64)\n\t62: LdU64(1)\n\t63: Add\n\t64: StLoc[6](loc3: u64)\n\t65: Branch(44)\nB12:\n\t66: MoveLoc[10](loc7: &vector<TypeName>)\n\t67: Pop\n\t68: MoveLoc[7](loc4: String)\n\t69: MoveLoc[4](loc1: u64)\n\t70: MoveLoc[12](loc9: address)\n\t71: MoveLoc[8](loc5: Option<address>)\n\t72: Ret\n}\n\npublic confirm_request_mut<Ty0>(Arg0: &mut TokenPolicy<Ty0>, Arg1: ActionRequest<Ty0>, Arg2: &mut TxContext): String * u64 * address * Option<address> {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t2: ImmBorrowLoc[1](Arg1: ActionRequest<Ty0>)\n\t3: ImmBorrowFieldGeneric[3](ActionRequest.name: String)\n\t4: Call vec_map::contains<String, VecSet<TypeName>>(&VecMap<String, VecSet<TypeName>>, &String): bool\n\t5: BrFalse(7)\nB1:\n\t6: Branch(13)\nB2:\n\t7: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t8: Pop\n\t9: MoveLoc[2](Arg2: &mut TxContext)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: ImmBorrowLoc[1](Arg1: ActionRequest<Ty0>)\n\t14: ImmBorrowFieldGeneric[1](ActionRequest.spent_balance: Option<Balance<Ty0>>)\n\t15: Call option::is_some<Balance<Ty0>>(&Option<Balance<Ty0>>): bool\n\t16: BrFalse(18)\nB4:\n\t17: Branch(24)\nB5:\n\t18: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t19: Pop\n\t20: MoveLoc[2](Arg2: &mut TxContext)\n\t21: Pop\n\t22: LdConst[7](u64: 7)\n\t23: Abort\nB6:\n\t24: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t25: MutBorrowFieldGeneric[4](TokenPolicy.spent_balance: Balance<Ty0>)\n\t26: MutBorrowLoc[1](Arg1: ActionRequest<Ty0>)\n\t27: MutBorrowFieldGeneric[1](ActionRequest.spent_balance: Option<Balance<Ty0>>)\n\t28: Call option::extract<Balance<Ty0>>(&mut Option<Balance<Ty0>>): Balance<Ty0>\n\t29: Call balance::join<Ty0>(&mut Balance<Ty0>, Balance<Ty0>): u64\n\t30: Pop\n\t31: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t32: FreezeRef\n\t33: MoveLoc[1](Arg1: ActionRequest<Ty0>)\n\t34: MoveLoc[2](Arg2: &mut TxContext)\n\t35: Call confirm_request<Ty0>(&TokenPolicy<Ty0>, ActionRequest<Ty0>, &mut TxContext): String * u64 * address * Option<address>\n\t36: Ret\n}\n\npublic confirm_with_policy_cap<Ty0>(Arg0: &TokenPolicyCap<Ty0>, Arg1: ActionRequest<Ty0>, Arg2: &mut TxContext): String * u64 * address * Option<address> {\nL3:\tloc0: u64\nL4:\tloc1: String\nL5:\tloc2: Option<address>\nL6:\tloc3: address\nL7:\tloc4: Option<Balance<Ty0>>\nB0:\n\t0: ImmBorrowLoc[1](Arg1: ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](ActionRequest.spent_balance: Option<Balance<Ty0>>)\n\t2: Call option::is_none<Balance<Ty0>>(&Option<Balance<Ty0>>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[5](u64: 5)\n\t6: Abort\nB3:\n\t7: MoveLoc[1](Arg1: ActionRequest<Ty0>)\n\t8: UnpackGeneric[4](ActionRequest<Ty0>)\n\t9: Pop\n\t10: StLoc[7](loc4: Option<Balance<Ty0>>)\n\t11: StLoc[5](loc2: Option<address>)\n\t12: StLoc[6](loc3: address)\n\t13: StLoc[3](loc0: u64)\n\t14: StLoc[4](loc1: String)\n\t15: MoveLoc[7](loc4: Option<Balance<Ty0>>)\n\t16: Call option::destroy_none<Balance<Ty0>>(Option<Balance<Ty0>>)\n\t17: MoveLoc[4](loc1: String)\n\t18: MoveLoc[3](loc0: u64)\n\t19: MoveLoc[6](loc3: address)\n\t20: MoveLoc[5](loc2: Option<address>)\n\t21: Ret\n}\n\npublic confirm_with_treasury_cap<Ty0>(Arg0: &mut TreasuryCap<Ty0>, Arg1: ActionRequest<Ty0>, Arg2: &mut TxContext): String * u64 * address * Option<address> {\nL3:\tloc0: u64\nL4:\tloc1: String\nL5:\tloc2: Option<address>\nL6:\tloc3: address\nL7:\tloc4: Option<Balance<Ty0>>\nB0:\n\t0: MoveLoc[1](Arg1: ActionRequest<Ty0>)\n\t1: UnpackGeneric[4](ActionRequest<Ty0>)\n\t2: Pop\n\t3: StLoc[7](loc4: Option<Balance<Ty0>>)\n\t4: StLoc[5](loc2: Option<address>)\n\t5: StLoc[6](loc3: address)\n\t6: StLoc[3](loc0: u64)\n\t7: StLoc[4](loc1: String)\n\t8: ImmBorrowLoc[7](loc4: Option<Balance<Ty0>>)\n\t9: Call option::is_some<Balance<Ty0>>(&Option<Balance<Ty0>>): bool\n\t10: BrFalse(18)\nB1:\n\t11: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t12: Call coin::supply_mut<Ty0>(&mut TreasuryCap<Ty0>): &mut Supply<Ty0>\n\t13: MoveLoc[7](loc4: Option<Balance<Ty0>>)\n\t14: Call option::destroy_some<Balance<Ty0>>(Option<Balance<Ty0>>): Balance<Ty0>\n\t15: Call balance::decrease_supply<Ty0>(&mut Supply<Ty0>, Balance<Ty0>): u64\n\t16: Pop\n\t17: Branch(22)\nB2:\n\t18: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t19: Pop\n\t20: MoveLoc[7](loc4: Option<Balance<Ty0>>)\n\t21: Call option::destroy_none<Balance<Ty0>>(Option<Balance<Ty0>>)\nB3:\n\t22: MoveLoc[4](loc1: String)\n\t23: MoveLoc[3](loc0: u64)\n\t24: MoveLoc[6](loc3: address)\n\t25: MoveLoc[5](loc2: Option<address>)\n\t26: Ret\n}\n\npublic add_approval<Ty0, Ty1: drop>(Arg0: Ty1, Arg1: &mut ActionRequest<Ty0>, Arg2: &mut TxContext) {\nB0:\n\t0: MoveLoc[1](Arg1: &mut ActionRequest<Ty0>)\n\t1: MutBorrowFieldGeneric[5](ActionRequest.approvals: VecSet<TypeName>)\n\t2: Call type_name::with_defining_ids<Ty1>(): TypeName\n\t3: Call vec_set::insert<TypeName>(&mut VecSet<TypeName>, TypeName)\n\t4: Ret\n}\n\npublic add_rule_config<Ty0, Ty1: drop, Ty2: store>(Arg0: Ty1, Arg1: &mut TokenPolicy<Ty0>, Arg2: &TokenPolicyCap<Ty0>, Arg3: Ty2, Arg4: &mut TxContext) {\nB0:\n\t0: CopyLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t3: MoveLoc[2](Arg2: &TokenPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[6](TokenPolicyCap.for: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t10: Pop\n\t11: LdConst[2](u64: 2)\n\t12: Abort\nB3:\n\t13: MoveLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t14: MutBorrowFieldGeneric[7](TokenPolicy.id: UID)\n\t15: Call key<Ty1>(): RuleKey<Ty1>\n\t16: MoveLoc[3](Arg3: Ty2)\n\t17: Call dynamic_field::add<RuleKey<Ty1>, Ty2>(&mut UID, RuleKey<Ty1>, Ty2)\n\t18: Ret\n}\n\npublic rule_config<Ty0, Ty1: drop, Ty2: store>(Arg0: Ty1, Arg1: &TokenPolicy<Ty0>): &Ty2 {\nB0:\n\t0: CopyLoc[1](Arg1: &TokenPolicy<Ty0>)\n\t1: Call has_rule_config_with_type<Ty0, Ty1, Ty2>(&TokenPolicy<Ty0>): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(8)\nB2:\n\t4: MoveLoc[1](Arg1: &TokenPolicy<Ty0>)\n\t5: Pop\n\t6: LdConst[6](u64: 6)\n\t7: Abort\nB3:\n\t8: MoveLoc[1](Arg1: &TokenPolicy<Ty0>)\n\t9: ImmBorrowFieldGeneric[7](TokenPolicy.id: UID)\n\t10: Call key<Ty1>(): RuleKey<Ty1>\n\t11: Call dynamic_field::borrow<RuleKey<Ty1>, Ty2>(&UID, RuleKey<Ty1>): &Ty2\n\t12: Ret\n}\n\npublic rule_config_mut<Ty0, Ty1: drop, Ty2: store>(Arg0: Ty1, Arg1: &mut TokenPolicy<Ty0>, Arg2: &TokenPolicyCap<Ty0>): &mut Ty2 {\nB0:\n\t0: CopyLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call has_rule_config_with_type<Ty0, Ty1, Ty2>(&TokenPolicy<Ty0>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t6: Pop\n\t7: MoveLoc[2](Arg2: &TokenPolicyCap<Ty0>)\n\t8: Pop\n\t9: LdConst[6](u64: 6)\n\t10: Abort\nB3:\n\t11: CopyLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t12: FreezeRef\n\t13: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t14: MoveLoc[2](Arg2: &TokenPolicyCap<Ty0>)\n\t15: ImmBorrowFieldGeneric[6](TokenPolicyCap.for: ID)\n\t16: ReadRef\n\t17: Eq\n\t18: BrFalse(20)\nB4:\n\t19: Branch(24)\nB5:\n\t20: MoveLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t21: Pop\n\t22: LdConst[2](u64: 2)\n\t23: Abort\nB6:\n\t24: MoveLoc[1](Arg1: &mut TokenPolicy<Ty0>)\n\t25: MutBorrowFieldGeneric[7](TokenPolicy.id: UID)\n\t26: Call key<Ty1>(): RuleKey<Ty1>\n\t27: Call dynamic_field::borrow_mut<RuleKey<Ty1>, Ty2>(&mut UID, RuleKey<Ty1>): &mut Ty2\n\t28: Ret\n}\n\npublic remove_rule_config<Ty0, Ty1, Ty2: store>(Arg0: &mut TokenPolicy<Ty0>, Arg1: &TokenPolicyCap<Ty0>, Arg2: &mut TxContext): Ty2 {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call has_rule_config_with_type<Ty0, Ty1, Ty2>(&TokenPolicy<Ty0>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(11)\nB2:\n\t5: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t6: Pop\n\t7: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t8: Pop\n\t9: LdConst[6](u64: 6)\n\t10: Abort\nB3:\n\t11: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t12: FreezeRef\n\t13: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t14: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t15: ImmBorrowFieldGeneric[6](TokenPolicyCap.for: ID)\n\t16: ReadRef\n\t17: Eq\n\t18: BrFalse(20)\nB4:\n\t19: Branch(24)\nB5:\n\t20: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t21: Pop\n\t22: LdConst[2](u64: 2)\n\t23: Abort\nB6:\n\t24: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t25: MutBorrowFieldGeneric[7](TokenPolicy.id: UID)\n\t26: Call key<Ty1>(): RuleKey<Ty1>\n\t27: Call dynamic_field::remove<RuleKey<Ty1>, Ty2>(&mut UID, RuleKey<Ty1>): Ty2\n\t28: Ret\n}\n\npublic has_rule_config<Ty0, Ty1>(Arg0: &TokenPolicy<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[7](TokenPolicy.id: UID)\n\t2: Call key<Ty1>(): RuleKey<Ty1>\n\t3: Call dynamic_field::exists_<RuleKey<Ty1>>(&UID, RuleKey<Ty1>): bool\n\t4: Ret\n}\n\npublic has_rule_config_with_type<Ty0, Ty1, Ty2: store>(Arg0: &TokenPolicy<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[7](TokenPolicy.id: UID)\n\t2: Call key<Ty1>(): RuleKey<Ty1>\n\t3: Call dynamic_field::exists_with_type<RuleKey<Ty1>, Ty2>(&UID, RuleKey<Ty1>): bool\n\t4: Ret\n}\n\npublic allow<Ty0>(Arg0: &mut TokenPolicy<Ty0>, Arg1: &TokenPolicyCap<Ty0>, Arg2: String, Arg3: &mut TxContext) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t3: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[6](TokenPolicyCap.for: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t10: Pop\n\t11: LdConst[2](u64: 2)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t14: MutBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t15: MoveLoc[2](Arg2: String)\n\t16: Call vec_set::empty<TypeName>(): VecSet<TypeName>\n\t17: Call vec_map::insert<String, VecSet<TypeName>>(&mut VecMap<String, VecSet<TypeName>>, String, VecSet<TypeName>)\n\t18: Ret\n}\n\npublic disallow<Ty0>(Arg0: &mut TokenPolicy<Ty0>, Arg1: &TokenPolicyCap<Ty0>, Arg2: String, Arg3: &mut TxContext) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t3: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[6](TokenPolicyCap.for: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t10: Pop\n\t11: LdConst[2](u64: 2)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t14: MutBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t15: ImmBorrowLoc[2](Arg2: String)\n\t16: Call vec_map::remove<String, VecSet<TypeName>>(&mut VecMap<String, VecSet<TypeName>>, &String): String * VecSet<TypeName>\n\t17: Pop\n\t18: Pop\n\t19: Ret\n}\n\npublic add_rule_for_action<Ty0, Ty1: drop>(Arg0: &mut TokenPolicy<Ty0>, Arg1: &TokenPolicyCap<Ty0>, Arg2: String, Arg3: &mut TxContext) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t3: CopyLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[6](TokenPolicyCap.for: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(17)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t10: Pop\n\t11: MoveLoc[3](Arg3: &mut TxContext)\n\t12: Pop\n\t13: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t14: Pop\n\t15: LdConst[2](u64: 2)\n\t16: Abort\nB3:\n\t17: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t18: ImmBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t19: ImmBorrowLoc[2](Arg2: String)\n\t20: Call vec_map::contains<String, VecSet<TypeName>>(&VecMap<String, VecSet<TypeName>>, &String): bool\n\t21: Not\n\t22: BrFalse(29)\nB4:\n\t23: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t24: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t25: CopyLoc[2](Arg2: String)\n\t26: MoveLoc[3](Arg3: &mut TxContext)\n\t27: Call allow<Ty0>(&mut TokenPolicy<Ty0>, &TokenPolicyCap<Ty0>, String, &mut TxContext)\n\t28: Branch(33)\nB5:\n\t29: MoveLoc[3](Arg3: &mut TxContext)\n\t30: Pop\n\t31: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t32: Pop\nB6:\n\t33: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t34: MutBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t35: ImmBorrowLoc[2](Arg2: String)\n\t36: Call vec_map::get_mut<String, VecSet<TypeName>>(&mut VecMap<String, VecSet<TypeName>>, &String): &mut VecSet<TypeName>\n\t37: Call type_name::with_defining_ids<Ty1>(): TypeName\n\t38: Call vec_set::insert<TypeName>(&mut VecSet<TypeName>, TypeName)\n\t39: Ret\n}\n\npublic remove_rule_for_action<Ty0, Ty1: drop>(Arg0: &mut TokenPolicy<Ty0>, Arg1: &TokenPolicyCap<Ty0>, Arg2: String, Arg3: &mut TxContext) {\nL4:\tloc0: TypeName\nL5:\tloc1: &mut VecSet<TypeName>\nB0:\n\t0: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TokenPolicy<Ty0>>(&TokenPolicy<Ty0>): ID\n\t3: MoveLoc[1](Arg1: &TokenPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[6](TokenPolicyCap.for: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t10: Pop\n\t11: LdConst[2](u64: 2)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t14: MutBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t15: ImmBorrowLoc[2](Arg2: String)\n\t16: Call vec_map::get_mut<String, VecSet<TypeName>>(&mut VecMap<String, VecSet<TypeName>>, &String): &mut VecSet<TypeName>\n\t17: StLoc[5](loc1: &mut VecSet<TypeName>)\n\t18: Call type_name::with_defining_ids<Ty1>(): TypeName\n\t19: StLoc[4](loc0: TypeName)\n\t20: MoveLoc[5](loc1: &mut VecSet<TypeName>)\n\t21: ImmBorrowLoc[4](loc0: TypeName)\n\t22: Call vec_set::remove<TypeName>(&mut VecSet<TypeName>, &TypeName)\n\t23: Ret\n}\n\npublic mint<Ty0>(Arg0: &mut TreasuryCap<Ty0>, Arg1: u64, Arg2: &mut TxContext): Token<Ty0> {\nL3:\tloc0: Balance<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t1: Call coin::supply_mut<Ty0>(&mut TreasuryCap<Ty0>): &mut Supply<Ty0>\n\t2: MoveLoc[1](Arg1: u64)\n\t3: Call balance::increase_supply<Ty0>(&mut Supply<Ty0>, u64): Balance<Ty0>\n\t4: StLoc[3](loc0: Balance<Ty0>)\n\t5: MoveLoc[2](Arg2: &mut TxContext)\n\t6: Call object::new(&mut TxContext): UID\n\t7: MoveLoc[3](loc0: Balance<Ty0>)\n\t8: PackGeneric[3](Token<Ty0>)\n\t9: Ret\n}\n\npublic burn<Ty0>(Arg0: &mut TreasuryCap<Ty0>, Arg1: Token<Ty0>) {\nL2:\tloc0: Balance<Ty0>\nL3:\tloc1: UID\nB0:\n\t0: MoveLoc[1](Arg1: Token<Ty0>)\n\t1: UnpackGeneric[3](Token<Ty0>)\n\t2: StLoc[2](loc0: Balance<Ty0>)\n\t3: StLoc[3](loc1: UID)\n\t4: MoveLoc[0](Arg0: &mut TreasuryCap<Ty0>)\n\t5: Call coin::supply_mut<Ty0>(&mut TreasuryCap<Ty0>): &mut Supply<Ty0>\n\t6: MoveLoc[2](loc0: Balance<Ty0>)\n\t7: Call balance::decrease_supply<Ty0>(&mut Supply<Ty0>, Balance<Ty0>): u64\n\t8: Pop\n\t9: MoveLoc[3](loc1: UID)\n\t10: Call object::delete(UID)\n\t11: Ret\n}\n\npublic flush<Ty0>(Arg0: &mut TokenPolicy<Ty0>, Arg1: &mut TreasuryCap<Ty0>, Arg2: &mut TxContext): u64 {\nL3:\tloc0: u64\nL4:\tloc1: Balance<Ty0>\nB0:\n\t0: CopyLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[4](TokenPolicy.spent_balance: Balance<Ty0>)\n\t2: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t3: StLoc[3](loc0: u64)\n\t4: MoveLoc[0](Arg0: &mut TokenPolicy<Ty0>)\n\t5: MutBorrowFieldGeneric[4](TokenPolicy.spent_balance: Balance<Ty0>)\n\t6: MoveLoc[3](loc0: u64)\n\t7: Call balance::split<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t8: StLoc[4](loc1: Balance<Ty0>)\n\t9: MoveLoc[1](Arg1: &mut TreasuryCap<Ty0>)\n\t10: Call coin::supply_mut<Ty0>(&mut TreasuryCap<Ty0>): &mut Supply<Ty0>\n\t11: MoveLoc[4](loc1: Balance<Ty0>)\n\t12: Call balance::decrease_supply<Ty0>(&mut Supply<Ty0>, Balance<Ty0>): u64\n\t13: Ret\n}\n\npublic is_allowed<Ty0>(Arg0: &TokenPolicy<Ty0>, Arg1: &String): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t2: MoveLoc[1](Arg1: &String)\n\t3: Call vec_map::contains<String, VecSet<TypeName>>(&VecMap<String, VecSet<TypeName>>, &String): bool\n\t4: Ret\n}\n\npublic rules<Ty0>(Arg0: &TokenPolicy<Ty0>, Arg1: &String): VecSet<TypeName> {\nB0:\n\t0: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](TokenPolicy.rules: VecMap<String, VecSet<TypeName>>)\n\t2: MoveLoc[1](Arg1: &String)\n\t3: Call vec_map::get<String, VecSet<TypeName>>(&VecMap<String, VecSet<TypeName>>, &String): &VecSet<TypeName>\n\t4: ReadRef\n\t5: Ret\n}\n\npublic spent_balance<Ty0>(Arg0: &TokenPolicy<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &TokenPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[4](TokenPolicy.spent_balance: Balance<Ty0>)\n\t2: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t3: Ret\n}\n\npublic value<Ty0>(Arg0: &Token<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Token<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Token.balance: Balance<Ty0>)\n\t2: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t3: Ret\n}\n\npublic transfer_action(): String {\nB0:\n\t0: LdConst[9](vector<u8>: \"tra..)\n\t1: Call string::utf8(vector<u8>): String\n\t2: Ret\n}\n\npublic spend_action(): String {\nB0:\n\t0: LdConst[8](vector<u8>: \"spe..)\n\t1: Call string::utf8(vector<u8>): String\n\t2: Ret\n}\n\npublic to_coin_action(): String {\nB0:\n\t0: LdConst[10](vector<u8>: \"to_..)\n\t1: Call string::utf8(vector<u8>): String\n\t2: Ret\n}\n\npublic from_coin_action(): String {\nB0:\n\t0: LdConst[11](vector<u8>: \"fro..)\n\t1: Call string::utf8(vector<u8>): String\n\t2: Ret\n}\n\npublic action<Ty0>(Arg0: &ActionRequest<Ty0>): String {\nB0:\n\t0: MoveLoc[0](Arg0: &ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](ActionRequest.name: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic amount<Ty0>(Arg0: &ActionRequest<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[8](ActionRequest.amount: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic sender<Ty0>(Arg0: &ActionRequest<Ty0>): address {\nB0:\n\t0: MoveLoc[0](Arg0: &ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[9](ActionRequest.sender: address)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic recipient<Ty0>(Arg0: &ActionRequest<Ty0>): Option<address> {\nB0:\n\t0: MoveLoc[0](Arg0: &ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[10](ActionRequest.recipient: Option<address>)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic approvals<Ty0>(Arg0: &ActionRequest<Ty0>): VecSet<TypeName> {\nB0:\n\t0: MoveLoc[0](Arg0: &ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[5](ActionRequest.approvals: VecSet<TypeName>)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic spent<Ty0>(Arg0: &ActionRequest<Ty0>): Option<u64> {\nL1:\tloc0: Option<u64>\nB0:\n\t0: CopyLoc[0](Arg0: &ActionRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[1](ActionRequest.spent_balance: Option<Balance<Ty0>>)\n\t2: Call option::is_some<Balance<Ty0>>(&Option<Balance<Ty0>>): bool\n\t3: BrFalse(11)\nB1:\n\t4: MoveLoc[0](Arg0: &ActionRequest<Ty0>)\n\t5: ImmBorrowFieldGeneric[1](ActionRequest.spent_balance: Option<Balance<Ty0>>)\n\t6: Call option::borrow<Balance<Ty0>>(&Option<Balance<Ty0>>): &Balance<Ty0>\n\t7: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t8: Call option::some<u64>(u64): Option<u64>\n\t9: StLoc[1](loc0: Option<u64>)\n\t10: Branch(15)\nB2:\n\t11: MoveLoc[0](Arg0: &ActionRequest<Ty0>)\n\t12: Pop\n\t13: Call option::none<u64>(): Option<u64>\n\t14: StLoc[1](loc0: Option<u64>)\nB3:\n\t15: MoveLoc[1](loc0: Option<u64>)\n\t16: Ret\n}\n\nkey<Ty0>(): RuleKey<Ty0> {\nB0:\n\t0: LdTrue\n\t1: PackGeneric[5](RuleKey<Ty0>)\n\t2: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u64: 5\n\t6 => u64: 6\n\t7 => u64: 7\n\t8 => vector<u8>: \"spend\" // interpreted as UTF8 string\n\t9 => vector<u8>: \"transfer\" // interpreted as UTF8 string\n\t10 => vector<u8>: \"to_coin\" // interpreted as UTF8 string\n\t11 => vector<u8>: \"from_coin\" // interpreted as UTF8 string\n]\n}\n","transfer":"// Move bytecode v6\nmodule 2.transfer {\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::party;\n\nstruct Receiving<phantom Ty0: key> has drop {\n\tid: ID,\n\tversion: u64\n}\n\npublic transfer<Ty0: key>(Arg0: Ty0, Arg1: address) {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: MoveLoc[1](Arg1: address)\n\t2: Call transfer_impl<Ty0>(Ty0, address)\n\t3: Ret\n}\n\npublic public_transfer<Ty0: store + key>(Arg0: Ty0, Arg1: address) {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: MoveLoc[1](Arg1: address)\n\t2: Call transfer_impl<Ty0>(Ty0, address)\n\t3: Ret\n}\n\npublic party_transfer<Ty0: key>(Arg0: Ty0, Arg1: Party) {\nL2:\tloc0: vector<address>\nL3:\tloc1: u64\nL4:\tloc2: vector<u64>\nB0:\n\t0: ImmBorrowLoc[1](Arg1: Party)\n\t1: Call party::is_single_owner(&Party): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(6)\nB2:\n\t4: LdU64(13836747248740204551)\n\t5: Abort\nB3:\n\t6: MoveLoc[1](Arg1: Party)\n\t7: Call party::into_native(Party): u64 * vector<address> * vector<u64>\n\t8: StLoc[4](loc2: vector<u64>)\n\t9: StLoc[2](loc0: vector<address>)\n\t10: StLoc[3](loc1: u64)\n\t11: MoveLoc[0](Arg0: Ty0)\n\t12: MoveLoc[3](loc1: u64)\n\t13: MoveLoc[2](loc0: vector<address>)\n\t14: MoveLoc[4](loc2: vector<u64>)\n\t15: Call party_transfer_impl<Ty0>(Ty0, u64, vector<address>, vector<u64>)\n\t16: Ret\n}\n\npublic public_party_transfer<Ty0: store + key>(Arg0: Ty0, Arg1: Party) {\nL2:\tloc0: vector<address>\nL3:\tloc1: u64\nL4:\tloc2: vector<u64>\nB0:\n\t0: ImmBorrowLoc[1](Arg1: Party)\n\t1: Call party::is_single_owner(&Party): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(6)\nB2:\n\t4: LdU64(13836747317459681287)\n\t5: Abort\nB3:\n\t6: MoveLoc[1](Arg1: Party)\n\t7: Call party::into_native(Party): u64 * vector<address> * vector<u64>\n\t8: StLoc[4](loc2: vector<u64>)\n\t9: StLoc[2](loc0: vector<address>)\n\t10: StLoc[3](loc1: u64)\n\t11: MoveLoc[0](Arg0: Ty0)\n\t12: MoveLoc[3](loc1: u64)\n\t13: MoveLoc[2](loc0: vector<address>)\n\t14: MoveLoc[4](loc2: vector<u64>)\n\t15: Call party_transfer_impl<Ty0>(Ty0, u64, vector<address>, vector<u64>)\n\t16: Ret\n}\n\npublic freeze_object<Ty0: key>(Arg0: Ty0) {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: Call freeze_object_impl<Ty0>(Ty0)\n\t2: Ret\n}\n\npublic public_freeze_object<Ty0: store + key>(Arg0: Ty0) {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: Call freeze_object_impl<Ty0>(Ty0)\n\t2: Ret\n}\n\npublic share_object<Ty0: key>(Arg0: Ty0) {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: Call share_object_impl<Ty0>(Ty0)\n\t2: Ret\n}\n\npublic public_share_object<Ty0: store + key>(Arg0: Ty0) {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: Call share_object_impl<Ty0>(Ty0)\n\t2: Ret\n}\n\npublic receive<Ty0: key>(Arg0: &mut UID, Arg1: Receiving<Ty0>): Ty0 {\nL2:\tloc0: ID\nL3:\tloc1: u64\nB0:\n\t0: MoveLoc[1](Arg1: Receiving<Ty0>)\n\t1: UnpackGeneric[0](Receiving<Ty0>)\n\t2: StLoc[3](loc1: u64)\n\t3: StLoc[2](loc0: ID)\n\t4: MoveLoc[0](Arg0: &mut UID)\n\t5: FreezeRef\n\t6: Call object::uid_to_address(&UID): address\n\t7: MoveLoc[2](loc0: ID)\n\t8: MoveLoc[3](loc1: u64)\n\t9: Call receive_impl<Ty0>(address, ID, u64): Ty0\n\t10: Ret\n}\n\npublic public_receive<Ty0: store + key>(Arg0: &mut UID, Arg1: Receiving<Ty0>): Ty0 {\nL2:\tloc0: ID\nL3:\tloc1: u64\nB0:\n\t0: MoveLoc[1](Arg1: Receiving<Ty0>)\n\t1: UnpackGeneric[0](Receiving<Ty0>)\n\t2: StLoc[3](loc1: u64)\n\t3: StLoc[2](loc0: ID)\n\t4: MoveLoc[0](Arg0: &mut UID)\n\t5: FreezeRef\n\t6: Call object::uid_to_address(&UID): address\n\t7: MoveLoc[2](loc0: ID)\n\t8: MoveLoc[3](loc1: u64)\n\t9: Call receive_impl<Ty0>(address, ID, u64): Ty0\n\t10: Ret\n}\n\npublic receiving_object_id<Ty0: key>(Arg0: &Receiving<Ty0>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &Receiving<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](Receiving.id: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\nnative public(friend) freeze_object_impl<Ty0: key>(Arg0: Ty0);\n\nnative public(friend) share_object_impl<Ty0: key>(Arg0: Ty0);\n\nnative public(friend) party_transfer_impl<Ty0: key>(Arg0: Ty0, Arg1: u64, Arg2: vector<address>, Arg3: vector<u64>);\n\nnative public(friend) transfer_impl<Ty0: key>(Arg0: Ty0, Arg1: address);\n\nnative receive_impl<Ty0: key>(Arg0: address, Arg1: ID, Arg2: u64): Ty0;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u64: 5\n\t6 => vector<u8>: \"EInvalidPartyPermissions\" // interpreted as UTF8 string\n\t7 => vector<u8>: \"Party transfer is currently limited to one party.\" // interpreted as UTF8 string\n]\n}\n","transfer_policy":"// Move bytecode v6\nmodule 2.transfer_policy {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::package;\nuse 0000000000000000000000000000000000000000000000000000000000000002::sui;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\nuse 0000000000000000000000000000000000000000000000000000000000000002::vec_set;\n\nstruct TransferRequest<phantom Ty0> {\n\titem: ID,\n\tpaid: u64,\n\tfrom: ID,\n\treceipts: VecSet<TypeName>\n}\n\nstruct TransferPolicy<phantom Ty0> has store, key {\n\tid: UID,\n\tbalance: Balance<SUI>,\n\trules: VecSet<TypeName>\n}\n\nstruct TransferPolicyCap<phantom Ty0> has store, key {\n\tid: UID,\n\tpolicy_id: ID\n}\n\nstruct TransferPolicyCreated<phantom Ty0> has copy, drop {\n\tid: ID\n}\n\nstruct TransferPolicyDestroyed<phantom Ty0> has copy, drop {\n\tid: ID\n}\n\nstruct RuleKey<phantom Ty0: drop> has copy, drop, store {\n\tdummy_field: bool\n}\n\npublic new_request<Ty0>(Arg0: ID, Arg1: u64, Arg2: ID): TransferRequest<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: ID)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: MoveLoc[2](Arg2: ID)\n\t3: Call vec_set::empty<TypeName>(): VecSet<TypeName>\n\t4: PackGeneric[0](TransferRequest<Ty0>)\n\t5: Ret\n}\n\npublic new<Ty0>(Arg0: &Publisher, Arg1: &mut TxContext): TransferPolicy<Ty0> * TransferPolicyCap<Ty0> {\nL2:\tloc0: UID\nL3:\tloc1: VecSet<TypeName>\nL4:\tloc2: Balance<SUI>\nL5:\tloc3: UID\nL6:\tloc4: ID\nB0:\n\t0: MoveLoc[0](Arg0: &Publisher)\n\t1: Call package::from_package<Ty0>(&Publisher): bool\n\t2: BrFalse(4)\nB1:\n\t3: Branch(8)\nB2:\n\t4: MoveLoc[1](Arg1: &mut TxContext)\n\t5: Pop\n\t6: LdU64(0)\n\t7: Abort\nB3:\n\t8: CopyLoc[1](Arg1: &mut TxContext)\n\t9: Call object::new(&mut TxContext): UID\n\t10: StLoc[5](loc3: UID)\n\t11: ImmBorrowLoc[5](loc3: UID)\n\t12: Call object::uid_to_inner(&UID): ID\n\t13: StLoc[6](loc4: ID)\n\t14: CopyLoc[6](loc4: ID)\n\t15: PackGeneric[1](TransferPolicyCreated<Ty0>)\n\t16: Call event::emit<TransferPolicyCreated<Ty0>>(TransferPolicyCreated<Ty0>)\n\t17: MoveLoc[5](loc3: UID)\n\t18: StLoc[2](loc0: UID)\n\t19: Call vec_set::empty<TypeName>(): VecSet<TypeName>\n\t20: StLoc[3](loc1: VecSet<TypeName>)\n\t21: Call balance::zero<SUI>(): Balance<SUI>\n\t22: StLoc[4](loc2: Balance<SUI>)\n\t23: MoveLoc[2](loc0: UID)\n\t24: MoveLoc[4](loc2: Balance<SUI>)\n\t25: MoveLoc[3](loc1: VecSet<TypeName>)\n\t26: PackGeneric[2](TransferPolicy<Ty0>)\n\t27: MoveLoc[1](Arg1: &mut TxContext)\n\t28: Call object::new(&mut TxContext): UID\n\t29: MoveLoc[6](loc4: ID)\n\t30: PackGeneric[3](TransferPolicyCap<Ty0>)\n\t31: Ret\n}\n\nentry default<Ty0>(Arg0: &Publisher, Arg1: &mut TxContext) {\nL2:\tloc0: TransferPolicyCap<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &Publisher)\n\t1: CopyLoc[1](Arg1: &mut TxContext)\n\t2: Call new<Ty0>(&Publisher, &mut TxContext): TransferPolicy<Ty0> * TransferPolicyCap<Ty0>\n\t3: StLoc[2](loc0: TransferPolicyCap<Ty0>)\n\t4: Call transfer::share_object<TransferPolicy<Ty0>>(TransferPolicy<Ty0>)\n\t5: MoveLoc[2](loc0: TransferPolicyCap<Ty0>)\n\t6: MoveLoc[1](Arg1: &mut TxContext)\n\t7: FreezeRef\n\t8: Call tx_context::sender(&TxContext): address\n\t9: Call transfer::transfer<TransferPolicyCap<Ty0>>(TransferPolicyCap<Ty0>, address)\n\t10: Ret\n}\n\npublic withdraw<Ty0>(Arg0: &mut TransferPolicy<Ty0>, Arg1: &TransferPolicyCap<Ty0>, Arg2: Option<u64>, Arg3: &mut TxContext): Coin<SUI> {\nL4:\tloc0: u64\nL5:\tloc1: u64\nL6:\tloc2: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TransferPolicy<Ty0>>(&TransferPolicy<Ty0>): ID\n\t3: MoveLoc[1](Arg1: &TransferPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](TransferPolicyCap.policy_id: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(15)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t10: Pop\n\t11: MoveLoc[3](Arg3: &mut TxContext)\n\t12: Pop\n\t13: LdConst[4](u64: 4)\n\t14: Abort\nB3:\n\t15: ImmBorrowLoc[2](Arg2: Option<u64>)\n\t16: Call option::is_some<u64>(&Option<u64>): bool\n\t17: BrFalse(37)\nB4:\n\t18: MoveLoc[2](Arg2: Option<u64>)\n\t19: Call option::destroy_some<u64>(Option<u64>): u64\n\t20: StLoc[6](loc2: u64)\n\t21: CopyLoc[6](loc2: u64)\n\t22: CopyLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t23: ImmBorrowFieldGeneric[1](TransferPolicy.balance: Balance<SUI>)\n\t24: Call balance::value<SUI>(&Balance<SUI>): u64\n\t25: Le\n\t26: BrFalse(28)\nB5:\n\t27: Branch(34)\nB6:\n\t28: MoveLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t29: Pop\n\t30: MoveLoc[3](Arg3: &mut TxContext)\n\t31: Pop\n\t32: LdConst[5](u64: 5)\n\t33: Abort\nB7:\n\t34: MoveLoc[6](loc2: u64)\n\t35: StLoc[4](loc0: u64)\n\t36: Branch(41)\nB8:\n\t37: CopyLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t38: ImmBorrowFieldGeneric[1](TransferPolicy.balance: Balance<SUI>)\n\t39: Call balance::value<SUI>(&Balance<SUI>): u64\n\t40: StLoc[4](loc0: u64)\nB9:\n\t41: MoveLoc[4](loc0: u64)\n\t42: StLoc[5](loc1: u64)\n\t43: MoveLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t44: MutBorrowFieldGeneric[1](TransferPolicy.balance: Balance<SUI>)\n\t45: MoveLoc[5](loc1: u64)\n\t46: MoveLoc[3](Arg3: &mut TxContext)\n\t47: Call coin::take<SUI>(&mut Balance<SUI>, u64, &mut TxContext): Coin<SUI>\n\t48: Ret\n}\n\npublic destroy_and_withdraw<Ty0>(Arg0: TransferPolicy<Ty0>, Arg1: TransferPolicyCap<Ty0>, Arg2: &mut TxContext): Coin<SUI> {\nL3:\tloc0: Balance<SUI>\nL4:\tloc1: UID\nL5:\tloc2: ID\nB0:\n\t0: ImmBorrowLoc[0](Arg0: TransferPolicy<Ty0>)\n\t1: Call object::id<TransferPolicy<Ty0>>(&TransferPolicy<Ty0>): ID\n\t2: ImmBorrowLoc[1](Arg1: TransferPolicyCap<Ty0>)\n\t3: ImmBorrowFieldGeneric[0](TransferPolicyCap.policy_id: ID)\n\t4: ReadRef\n\t5: Eq\n\t6: BrFalse(8)\nB1:\n\t7: Branch(12)\nB2:\n\t8: MoveLoc[2](Arg2: &mut TxContext)\n\t9: Pop\n\t10: LdConst[4](u64: 4)\n\t11: Abort\nB3:\n\t12: MoveLoc[1](Arg1: TransferPolicyCap<Ty0>)\n\t13: UnpackGeneric[3](TransferPolicyCap<Ty0>)\n\t14: StLoc[5](loc2: ID)\n\t15: StLoc[4](loc1: UID)\n\t16: MoveLoc[0](Arg0: TransferPolicy<Ty0>)\n\t17: UnpackGeneric[2](TransferPolicy<Ty0>)\n\t18: Pop\n\t19: StLoc[3](loc0: Balance<SUI>)\n\t20: Call object::delete(UID)\n\t21: MoveLoc[4](loc1: UID)\n\t22: Call object::delete(UID)\n\t23: MoveLoc[5](loc2: ID)\n\t24: PackGeneric[4](TransferPolicyDestroyed<Ty0>)\n\t25: Call event::emit<TransferPolicyDestroyed<Ty0>>(TransferPolicyDestroyed<Ty0>)\n\t26: MoveLoc[3](loc0: Balance<SUI>)\n\t27: MoveLoc[2](Arg2: &mut TxContext)\n\t28: Call coin::from_balance<SUI>(Balance<SUI>, &mut TxContext): Coin<SUI>\n\t29: Ret\n}\n\npublic confirm_request<Ty0>(Arg0: &TransferPolicy<Ty0>, Arg1: TransferRequest<Ty0>): ID * u64 * ID {\nL2:\tloc0: vector<TypeName>\nL3:\tloc1: ID\nL4:\tloc2: ID\nL5:\tloc3: u64\nL6:\tloc4: VecSet<TypeName>\nL7:\tloc5: TypeName\nL8:\tloc6: u64\nB0:\n\t0: MoveLoc[1](Arg1: TransferRequest<Ty0>)\n\t1: UnpackGeneric[0](TransferRequest<Ty0>)\n\t2: StLoc[6](loc4: VecSet<TypeName>)\n\t3: StLoc[3](loc1: ID)\n\t4: StLoc[5](loc3: u64)\n\t5: StLoc[4](loc2: ID)\n\t6: MoveLoc[6](loc4: VecSet<TypeName>)\n\t7: Call vec_set::into_keys<TypeName>(VecSet<TypeName>): vector<TypeName>\n\t8: StLoc[2](loc0: vector<TypeName>)\n\t9: ImmBorrowLoc[2](loc0: vector<TypeName>)\n\t10: VecLen(23)\n\t11: StLoc[8](loc6: u64)\n\t12: CopyLoc[8](loc6: u64)\n\t13: CopyLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t14: ImmBorrowFieldGeneric[2](TransferPolicy.rules: VecSet<TypeName>)\n\t15: Call vec_set::length<TypeName>(&VecSet<TypeName>): u64\n\t16: Eq\n\t17: BrFalse(19)\nB1:\n\t18: Branch(23)\nB2:\n\t19: MoveLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t20: Pop\n\t21: LdConst[0](u64: 0)\n\t22: Abort\nB3:\n\t23: CopyLoc[8](loc6: u64)\n\t24: LdU64(0)\n\t25: Gt\n\t26: BrFalse(45)\nB4:\n\t27: MutBorrowLoc[2](loc0: vector<TypeName>)\n\t28: VecPopBack(23)\n\t29: StLoc[7](loc5: TypeName)\n\t30: CopyLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t31: ImmBorrowFieldGeneric[2](TransferPolicy.rules: VecSet<TypeName>)\n\t32: ImmBorrowLoc[7](loc5: TypeName)\n\t33: Call vec_set::contains<TypeName>(&VecSet<TypeName>, &TypeName): bool\n\t34: BrFalse(36)\nB5:\n\t35: Branch(40)\nB6:\n\t36: MoveLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t37: Pop\n\t38: LdConst[1](u64: 1)\n\t39: Abort\nB7:\n\t40: MoveLoc[8](loc6: u64)\n\t41: LdU64(1)\n\t42: Sub\n\t43: StLoc[8](loc6: u64)\n\t44: Branch(23)\nB8:\n\t45: MoveLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t46: Pop\n\t47: MoveLoc[4](loc2: ID)\n\t48: MoveLoc[5](loc3: u64)\n\t49: MoveLoc[3](loc1: ID)\n\t50: Ret\n}\n\npublic add_rule<Ty0, Ty1: drop, Ty2: drop + store>(Arg0: Ty1, Arg1: &mut TransferPolicy<Ty0>, Arg2: &TransferPolicyCap<Ty0>, Arg3: Ty2) {\nB0:\n\t0: CopyLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TransferPolicy<Ty0>>(&TransferPolicy<Ty0>): ID\n\t3: MoveLoc[2](Arg2: &TransferPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](TransferPolicyCap.policy_id: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t10: Pop\n\t11: LdConst[4](u64: 4)\n\t12: Abort\nB3:\n\t13: CopyLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t14: FreezeRef\n\t15: Call has_rule<Ty0, Ty1>(&TransferPolicy<Ty0>): bool\n\t16: Not\n\t17: BrFalse(19)\nB4:\n\t18: Branch(23)\nB5:\n\t19: MoveLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t20: Pop\n\t21: LdConst[3](u64: 3)\n\t22: Abort\nB6:\n\t23: CopyLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t24: MutBorrowFieldGeneric[3](TransferPolicy.id: UID)\n\t25: LdFalse\n\t26: PackGeneric[5](RuleKey<Ty1>)\n\t27: MoveLoc[3](Arg3: Ty2)\n\t28: Call dynamic_field::add<RuleKey<Ty1>, Ty2>(&mut UID, RuleKey<Ty1>, Ty2)\n\t29: MoveLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t30: MutBorrowFieldGeneric[2](TransferPolicy.rules: VecSet<TypeName>)\n\t31: Call type_name::with_defining_ids<Ty1>(): TypeName\n\t32: Call vec_set::insert<TypeName>(&mut VecSet<TypeName>, TypeName)\n\t33: Ret\n}\n\npublic get_rule<Ty0, Ty1: drop, Ty2: drop + store>(Arg0: Ty1, Arg1: &TransferPolicy<Ty0>): &Ty2 {\nB0:\n\t0: MoveLoc[1](Arg1: &TransferPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](TransferPolicy.id: UID)\n\t2: LdFalse\n\t3: PackGeneric[5](RuleKey<Ty1>)\n\t4: Call dynamic_field::borrow<RuleKey<Ty1>, Ty2>(&UID, RuleKey<Ty1>): &Ty2\n\t5: Ret\n}\n\npublic add_to_balance<Ty0, Ty1: drop>(Arg0: Ty1, Arg1: &mut TransferPolicy<Ty0>, Arg2: Coin<SUI>) {\nB0:\n\t0: CopyLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call has_rule<Ty0, Ty1>(&TransferPolicy<Ty0>): bool\n\t3: BrFalse(5)\nB1:\n\t4: Branch(9)\nB2:\n\t5: MoveLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t6: Pop\n\t7: LdConst[2](u64: 2)\n\t8: Abort\nB3:\n\t9: MoveLoc[1](Arg1: &mut TransferPolicy<Ty0>)\n\t10: MutBorrowFieldGeneric[1](TransferPolicy.balance: Balance<SUI>)\n\t11: MoveLoc[2](Arg2: Coin<SUI>)\n\t12: Call coin::put<SUI>(&mut Balance<SUI>, Coin<SUI>)\n\t13: Ret\n}\n\npublic add_receipt<Ty0, Ty1: drop>(Arg0: Ty1, Arg1: &mut TransferRequest<Ty0>) {\nB0:\n\t0: MoveLoc[1](Arg1: &mut TransferRequest<Ty0>)\n\t1: MutBorrowFieldGeneric[4](TransferRequest.receipts: VecSet<TypeName>)\n\t2: Call type_name::with_defining_ids<Ty1>(): TypeName\n\t3: Call vec_set::insert<TypeName>(&mut VecSet<TypeName>, TypeName)\n\t4: Ret\n}\n\npublic has_rule<Ty0, Ty1: drop>(Arg0: &TransferPolicy<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](TransferPolicy.id: UID)\n\t2: LdFalse\n\t3: PackGeneric[5](RuleKey<Ty1>)\n\t4: Call dynamic_field::exists_<RuleKey<Ty1>>(&UID, RuleKey<Ty1>): bool\n\t5: Ret\n}\n\npublic remove_rule<Ty0, Ty1: drop, Ty2: drop + store>(Arg0: &mut TransferPolicy<Ty0>, Arg1: &TransferPolicyCap<Ty0>) {\nL2:\tloc0: TypeName\nL3:\tloc1: &mut VecSet<TypeName>\nB0:\n\t0: CopyLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TransferPolicy<Ty0>>(&TransferPolicy<Ty0>): ID\n\t3: MoveLoc[1](Arg1: &TransferPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](TransferPolicyCap.policy_id: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t10: Pop\n\t11: LdConst[4](u64: 4)\n\t12: Abort\nB3:\n\t13: CopyLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t14: MutBorrowFieldGeneric[3](TransferPolicy.id: UID)\n\t15: LdFalse\n\t16: PackGeneric[5](RuleKey<Ty1>)\n\t17: Call dynamic_field::remove<RuleKey<Ty1>, Ty2>(&mut UID, RuleKey<Ty1>): Ty2\n\t18: Pop\n\t19: MoveLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t20: MutBorrowFieldGeneric[2](TransferPolicy.rules: VecSet<TypeName>)\n\t21: StLoc[3](loc1: &mut VecSet<TypeName>)\n\t22: Call type_name::with_defining_ids<Ty1>(): TypeName\n\t23: StLoc[2](loc0: TypeName)\n\t24: MoveLoc[3](loc1: &mut VecSet<TypeName>)\n\t25: ImmBorrowLoc[2](loc0: TypeName)\n\t26: Call vec_set::remove<TypeName>(&mut VecSet<TypeName>, &TypeName)\n\t27: Ret\n}\n\npublic uid<Ty0>(Arg0: &TransferPolicy<Ty0>): &UID {\nB0:\n\t0: MoveLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[3](TransferPolicy.id: UID)\n\t2: Ret\n}\n\npublic uid_mut_as_owner<Ty0>(Arg0: &mut TransferPolicy<Ty0>, Arg1: &TransferPolicyCap<Ty0>): &mut UID {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t1: FreezeRef\n\t2: Call object::id<TransferPolicy<Ty0>>(&TransferPolicy<Ty0>): ID\n\t3: MoveLoc[1](Arg1: &TransferPolicyCap<Ty0>)\n\t4: ImmBorrowFieldGeneric[0](TransferPolicyCap.policy_id: ID)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t10: Pop\n\t11: LdConst[4](u64: 4)\n\t12: Abort\nB3:\n\t13: MoveLoc[0](Arg0: &mut TransferPolicy<Ty0>)\n\t14: MutBorrowFieldGeneric[3](TransferPolicy.id: UID)\n\t15: Ret\n}\n\npublic rules<Ty0>(Arg0: &TransferPolicy<Ty0>): &VecSet<TypeName> {\nB0:\n\t0: MoveLoc[0](Arg0: &TransferPolicy<Ty0>)\n\t1: ImmBorrowFieldGeneric[2](TransferPolicy.rules: VecSet<TypeName>)\n\t2: Ret\n}\n\npublic item<Ty0>(Arg0: &TransferRequest<Ty0>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &TransferRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[5](TransferRequest.item: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic paid<Ty0>(Arg0: &TransferRequest<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &TransferRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[6](TransferRequest.paid: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic from<Ty0>(Arg0: &TransferRequest<Ty0>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &TransferRequest<Ty0>)\n\t1: ImmBorrowFieldGeneric[7](TransferRequest.from: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u64: 5\n]\n}\n","tx_context":"// Move bytecode v6\nmodule 2.tx_context {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\n\nstruct TxContext has drop {\n\tsender: address,\n\ttx_hash: vector<u8>,\n\tepoch: u64,\n\tepoch_timestamp_ms: u64,\n\tids_created: u64\n}\n\npublic sender(Arg0: &TxContext): address {\nB0:\n\t0: Call native_sender(): address\n\t1: Ret\n}\n\nnative native_sender(): address;\n\npublic digest(Arg0: &TxContext): &vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &TxContext)\n\t1: ImmBorrowField[0](TxContext.tx_hash: vector<u8>)\n\t2: Ret\n}\n\npublic epoch(Arg0: &TxContext): u64 {\nB0:\n\t0: Call native_epoch(): u64\n\t1: Ret\n}\n\nnative native_epoch(): u64;\n\npublic epoch_timestamp_ms(Arg0: &TxContext): u64 {\nB0:\n\t0: Call native_epoch_timestamp_ms(): u64\n\t1: Ret\n}\n\nnative native_epoch_timestamp_ms(): u64;\n\npublic sponsor(Arg0: &TxContext): Option<address> {\nB0:\n\t0: Call option_sponsor(): Option<address>\n\t1: Ret\n}\n\npublic fresh_object_address(Arg0: &mut TxContext): address {\nB0:\n\t0: Call fresh_id(): address\n\t1: Ret\n}\n\nnative fresh_id(): address;\n\npublic reference_gas_price(Arg0: &TxContext): u64 {\nB0:\n\t0: Call native_rgp(): u64\n\t1: Ret\n}\n\nnative native_rgp(): u64;\n\npublic gas_price(Arg0: &TxContext): u64 {\nB0:\n\t0: Call native_gas_price(): u64\n\t1: Ret\n}\n\nnative native_gas_price(): u64;\n\nnative native_ids_created(): u64;\n\nnative native_gas_budget(): u64;\n\noption_sponsor(): Option<address> {\nL0:\tloc0: Option<address>\nL1:\tloc1: vector<address>\nB0:\n\t0: Call native_sponsor(): vector<address>\n\t1: StLoc[1](loc1: vector<address>)\n\t2: ImmBorrowLoc[1](loc1: vector<address>)\n\t3: VecLen(1)\n\t4: LdU64(0)\n\t5: Eq\n\t6: BrFalse(10)\nB1:\n\t7: Call option::none<address>(): Option<address>\n\t8: StLoc[0](loc0: Option<address>)\n\t9: Branch(16)\nB2:\n\t10: ImmBorrowLoc[1](loc1: vector<address>)\n\t11: LdU64(0)\n\t12: VecImmBorrow(1)\n\t13: ReadRef\n\t14: Call option::some<address>(address): Option<address>\n\t15: StLoc[0](loc0: Option<address>)\nB3:\n\t16: MoveLoc[0](loc0: Option<address>)\n\t17: Ret\n}\n\nnative native_sponsor(): vector<address>;\n\nnative derive_id(Arg0: vector<u8>, Arg1: u64): address;\n\n}\n","types":"// Move bytecode v6\nmodule 2.types {\n\nnative public is_one_time_witness<Ty0: drop>(Arg0: &Ty0): bool;\n\n}\n","url":"// Move bytecode v6\nmodule 2.url {\nuse 0000000000000000000000000000000000000000000000000000000000000001::ascii;\n\nstruct Url has copy, drop, store {\n\turl: String\n}\n\npublic new_unsafe(Arg0: String): Url {\nB0:\n\t0: MoveLoc[0](Arg0: String)\n\t1: Pack[0](Url)\n\t2: Ret\n}\n\npublic new_unsafe_from_bytes(Arg0: vector<u8>): Url {\nB0:\n\t0: MoveLoc[0](Arg0: vector<u8>)\n\t1: Call ascii::string(vector<u8>): String\n\t2: Pack[0](Url)\n\t3: Ret\n}\n\npublic inner_url(Arg0: &Url): String {\nB0:\n\t0: MoveLoc[0](Arg0: &Url)\n\t1: ImmBorrowField[0](Url.url: String)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic update(Arg0: &mut Url, Arg1: String) {\nB0:\n\t0: MoveLoc[1](Arg1: String)\n\t1: MoveLoc[0](Arg0: &mut Url)\n\t2: MutBorrowField[0](Url.url: String)\n\t3: WriteRef\n\t4: Ret\n}\n\n}\n","vdf":"// Move bytecode v6\nmodule 2.vdf {\n\npublic hash_to_input(Arg0: &vector<u8>): vector<u8> {\nB0:\n\t0: MoveLoc[0](Arg0: &vector<u8>)\n\t1: Call hash_to_input_internal(&vector<u8>): vector<u8>\n\t2: Ret\n}\n\nnative hash_to_input_internal(Arg0: &vector<u8>): vector<u8>;\n\npublic vdf_verify(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>, Arg3: u64): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &vector<u8>)\n\t1: MoveLoc[1](Arg1: &vector<u8>)\n\t2: MoveLoc[2](Arg2: &vector<u8>)\n\t3: MoveLoc[3](Arg3: u64)\n\t4: Call vdf_verify_internal(&vector<u8>, &vector<u8>, &vector<u8>, u64): bool\n\t5: Ret\n}\n\nnative vdf_verify_internal(Arg0: &vector<u8>, Arg1: &vector<u8>, Arg2: &vector<u8>, Arg3: u64): bool;\n\nConstants [\n\t0 => u64: 0\n]\n}\n","vec_map":"// Move bytecode v6\nmodule 2.vec_map {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\n\nstruct VecMap<Ty0: copy, Ty1> has copy, drop, store {\n\tcontents: vector<Entry<Ty0, Ty1>>\n}\n\nstruct Entry<Ty0: copy, Ty1> has copy, drop, store {\n\tkey: Ty0,\n\tvalue: Ty1\n}\n\npublic empty<Ty0: copy, Ty1>(): VecMap<Ty0, Ty1> {\nB0:\n\t0: VecPack(20, 0)\n\t1: PackGeneric[0](VecMap<Ty0, Ty1>)\n\t2: Ret\n}\n\npublic insert<Ty0: copy, Ty1>(Arg0: &mut VecMap<Ty0, Ty1>, Arg1: Ty0, Arg2: Ty1) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t1: FreezeRef\n\t2: ImmBorrowLoc[1](Arg1: Ty0)\n\t3: Call contains<Ty0, Ty1>(&VecMap<Ty0, Ty1>, &Ty0): bool\n\t4: Not\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t12: MutBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t13: MoveLoc[1](Arg1: Ty0)\n\t14: MoveLoc[2](Arg2: Ty1)\n\t15: PackGeneric[1](Entry<Ty0, Ty1>)\n\t16: VecPushBack(20)\n\t17: Ret\n}\n\npublic remove<Ty0: copy, Ty1>(Arg0: &mut VecMap<Ty0, Ty1>, Arg1: &Ty0): Ty0 * Ty1 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t1: FreezeRef\n\t2: MoveLoc[1](Arg1: &Ty0)\n\t3: Call get_idx<Ty0, Ty1>(&VecMap<Ty0, Ty1>, &Ty0): u64\n\t4: StLoc[2](loc0: u64)\n\t5: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t6: MutBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t7: MoveLoc[2](loc0: u64)\n\t8: Call vector::remove<Entry<Ty0, Ty1>>(&mut vector<Entry<Ty0, Ty1>>, u64): Entry<Ty0, Ty1>\n\t9: UnpackGeneric[1](Entry<Ty0, Ty1>)\n\t10: Ret\n}\n\npublic pop<Ty0: copy, Ty1>(Arg0: &mut VecMap<Ty0, Ty1>): Ty0 * Ty1 {\nB0:\n\t0: CopyLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t2: VecLen(20)\n\t3: LdU64(0)\n\t4: Neq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t8: Pop\n\t9: LdConst[4](u64: 4)\n\t10: Abort\nB3:\n\t11: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t12: MutBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t13: VecPopBack(20)\n\t14: UnpackGeneric[1](Entry<Ty0, Ty1>)\n\t15: Ret\n}\n\npublic get_mut<Ty0: copy, Ty1>(Arg0: &mut VecMap<Ty0, Ty1>, Arg1: &Ty0): &mut Ty1 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t1: FreezeRef\n\t2: MoveLoc[1](Arg1: &Ty0)\n\t3: Call get_idx<Ty0, Ty1>(&VecMap<Ty0, Ty1>, &Ty0): u64\n\t4: StLoc[2](loc0: u64)\n\t5: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t6: MutBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t7: MoveLoc[2](loc0: u64)\n\t8: VecMutBorrow(20)\n\t9: MutBorrowFieldGeneric[1](Entry.value: Ty1)\n\t10: Ret\n}\n\npublic get<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>, Arg1: &Ty0): &Ty1 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: &Ty0)\n\t2: Call get_idx<Ty0, Ty1>(&VecMap<Ty0, Ty1>, &Ty0): u64\n\t3: StLoc[2](loc0: u64)\n\t4: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t5: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t6: MoveLoc[2](loc0: u64)\n\t7: VecImmBorrow(20)\n\t8: ImmBorrowFieldGeneric[1](Entry.value: Ty1)\n\t9: Ret\n}\n\npublic try_get<Ty0: copy, Ty1: copy>(Arg0: &VecMap<Ty0, Ty1>, Arg1: &Ty0): Option<Ty1> {\nL2:\tloc0: Option<Ty1>\nB0:\n\t0: CopyLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: CopyLoc[1](Arg1: &Ty0)\n\t2: Call contains<Ty0, Ty1>(&VecMap<Ty0, Ty1>, &Ty0): bool\n\t3: BrFalse(11)\nB1:\n\t4: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t5: MoveLoc[1](Arg1: &Ty0)\n\t6: Call get<Ty0, Ty1>(&VecMap<Ty0, Ty1>, &Ty0): &Ty1\n\t7: ReadRef\n\t8: Call option::some<Ty1>(Ty1): Option<Ty1>\n\t9: StLoc[2](loc0: Option<Ty1>)\n\t10: Branch(17)\nB2:\n\t11: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t12: Pop\n\t13: MoveLoc[1](Arg1: &Ty0)\n\t14: Pop\n\t15: Call option::none<Ty1>(): Option<Ty1>\n\t16: StLoc[2](loc0: Option<Ty1>)\nB3:\n\t17: MoveLoc[2](loc0: Option<Ty1>)\n\t18: Ret\n}\n\npublic contains<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>, Arg1: &Ty0): bool {\nL2:\tloc0: Option<u64>\nB0:\n\t0: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: &Ty0)\n\t2: Call get_idx_opt<Ty0, Ty1>(&VecMap<Ty0, Ty1>, &Ty0): Option<u64>\n\t3: StLoc[2](loc0: Option<u64>)\n\t4: ImmBorrowLoc[2](loc0: Option<u64>)\n\t5: Call option::is_some<u64>(&Option<u64>): bool\n\t6: Ret\n}\n\npublic length<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t2: VecLen(20)\n\t3: Ret\n}\n\npublic is_empty<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: Call length<Ty0, Ty1>(&VecMap<Ty0, Ty1>): u64\n\t2: LdU64(0)\n\t3: Eq\n\t4: Ret\n}\n\npublic destroy_empty<Ty0: copy, Ty1>(Arg0: VecMap<Ty0, Ty1>) {\nL1:\tloc0: vector<Entry<Ty0, Ty1>>\nB0:\n\t0: MoveLoc[0](Arg0: VecMap<Ty0, Ty1>)\n\t1: UnpackGeneric[0](VecMap<Ty0, Ty1>)\n\t2: StLoc[1](loc0: vector<Entry<Ty0, Ty1>>)\n\t3: ImmBorrowLoc[1](loc0: vector<Entry<Ty0, Ty1>>)\n\t4: Call vector::is_empty<Entry<Ty0, Ty1>>(&vector<Entry<Ty0, Ty1>>): bool\n\t5: BrFalse(7)\nB1:\n\t6: Branch(9)\nB2:\n\t7: LdConst[2](u64: 2)\n\t8: Abort\nB3:\n\t9: MoveLoc[1](loc0: vector<Entry<Ty0, Ty1>>)\n\t10: VecUnpack(20, 0)\n\t11: Ret\n}\n\npublic into_keys_values<Ty0: copy, Ty1>(Arg0: VecMap<Ty0, Ty1>): vector<Ty0> * vector<Ty1> {\nL1:\tloc0: u64\nL2:\tloc1: vector<Entry<Ty0, Ty1>>\nL3:\tloc2: u64\nL4:\tloc3: Ty0\nL5:\tloc4: vector<Ty0>\nL6:\tloc5: u64\nL7:\tloc6: vector<Entry<Ty0, Ty1>>\nL8:\tloc7: Ty1\nL9:\tloc8: vector<Ty1>\nB0:\n\t0: MoveLoc[0](Arg0: VecMap<Ty0, Ty1>)\n\t1: UnpackGeneric[0](VecMap<Ty0, Ty1>)\n\t2: StLoc[2](loc1: vector<Entry<Ty0, Ty1>>)\n\t3: VecPack(22, 0)\n\t4: StLoc[5](loc4: vector<Ty0>)\n\t5: VecPack(23, 0)\n\t6: StLoc[9](loc8: vector<Ty1>)\n\t7: MoveLoc[2](loc1: vector<Entry<Ty0, Ty1>>)\n\t8: StLoc[7](loc6: vector<Entry<Ty0, Ty1>>)\n\t9: MutBorrowLoc[7](loc6: vector<Entry<Ty0, Ty1>>)\n\t10: Call vector::reverse<Entry<Ty0, Ty1>>(&mut vector<Entry<Ty0, Ty1>>)\n\t11: ImmBorrowLoc[7](loc6: vector<Entry<Ty0, Ty1>>)\n\t12: VecLen(20)\n\t13: StLoc[1](loc0: u64)\n\t14: LdU64(0)\n\t15: StLoc[3](loc2: u64)\n\t16: MoveLoc[1](loc0: u64)\n\t17: StLoc[6](loc5: u64)\nB1:\n\t18: CopyLoc[3](loc2: u64)\n\t19: CopyLoc[6](loc5: u64)\n\t20: Lt\n\t21: BrFalse(40)\nB2:\n\t22: CopyLoc[3](loc2: u64)\n\t23: Pop\n\t24: MutBorrowLoc[7](loc6: vector<Entry<Ty0, Ty1>>)\n\t25: VecPopBack(20)\n\t26: UnpackGeneric[1](Entry<Ty0, Ty1>)\n\t27: StLoc[8](loc7: Ty1)\n\t28: StLoc[4](loc3: Ty0)\n\t29: MutBorrowLoc[5](loc4: vector<Ty0>)\n\t30: MoveLoc[4](loc3: Ty0)\n\t31: VecPushBack(22)\n\t32: MutBorrowLoc[9](loc8: vector<Ty1>)\n\t33: MoveLoc[8](loc7: Ty1)\n\t34: VecPushBack(23)\n\t35: MoveLoc[3](loc2: u64)\n\t36: LdU64(1)\n\t37: Add\n\t38: StLoc[3](loc2: u64)\n\t39: Branch(18)\nB3:\n\t40: MoveLoc[7](loc6: vector<Entry<Ty0, Ty1>>)\n\t41: VecUnpack(20, 0)\n\t42: MoveLoc[5](loc4: vector<Ty0>)\n\t43: MoveLoc[9](loc8: vector<Ty1>)\n\t44: Ret\n}\n\npublic from_keys_values<Ty0: copy, Ty1>(Arg0: vector<Ty0>, Arg1: vector<Ty1>): VecMap<Ty0, Ty1> {\nL2:\tloc0: u64\nL3:\tloc1: VecMap<Ty0, Ty1>\nL4:\tloc2: u64\nL5:\tloc3: Ty0\nL6:\tloc4: u64\nL7:\tloc5: vector<Ty0>\nL8:\tloc6: vector<Ty0>\nL9:\tloc7: vector<Ty1>\nL10:\tloc8: Ty1\nB0:\n\t0: ImmBorrowLoc[0](Arg0: vector<Ty0>)\n\t1: VecLen(22)\n\t2: ImmBorrowLoc[1](Arg1: vector<Ty1>)\n\t3: VecLen(23)\n\t4: Eq\n\t5: BrFalse(7)\nB1:\n\t6: Branch(9)\nB2:\n\t7: LdConst[5](u64: 5)\n\t8: Abort\nB3:\n\t9: VecPack(20, 0)\n\t10: PackGeneric[0](VecMap<Ty0, Ty1>)\n\t11: StLoc[3](loc1: VecMap<Ty0, Ty1>)\n\t12: MoveLoc[0](Arg0: vector<Ty0>)\n\t13: StLoc[8](loc6: vector<Ty0>)\n\t14: MoveLoc[1](Arg1: vector<Ty1>)\n\t15: StLoc[9](loc7: vector<Ty1>)\n\t16: MutBorrowLoc[9](loc7: vector<Ty1>)\n\t17: Call vector::reverse<Ty1>(&mut vector<Ty1>)\n\t18: ImmBorrowLoc[8](loc6: vector<Ty0>)\n\t19: VecLen(22)\n\t20: ImmBorrowLoc[9](loc7: vector<Ty1>)\n\t21: VecLen(23)\n\t22: Eq\n\t23: BrFalse(25)\nB4:\n\t24: Branch(27)\nB5:\n\t25: LdU64(13906834771343835135)\n\t26: Abort\nB6:\n\t27: MoveLoc[8](loc6: vector<Ty0>)\n\t28: StLoc[7](loc5: vector<Ty0>)\n\t29: MutBorrowLoc[7](loc5: vector<Ty0>)\n\t30: Call vector::reverse<Ty0>(&mut vector<Ty0>)\n\t31: ImmBorrowLoc[7](loc5: vector<Ty0>)\n\t32: VecLen(22)\n\t33: StLoc[2](loc0: u64)\n\t34: LdU64(0)\n\t35: StLoc[4](loc2: u64)\n\t36: MoveLoc[2](loc0: u64)\n\t37: StLoc[6](loc4: u64)\nB7:\n\t38: CopyLoc[4](loc2: u64)\n\t39: CopyLoc[6](loc4: u64)\n\t40: Lt\n\t41: BrFalse(59)\nB8:\n\t42: CopyLoc[4](loc2: u64)\n\t43: Pop\n\t44: MutBorrowLoc[7](loc5: vector<Ty0>)\n\t45: VecPopBack(22)\n\t46: StLoc[5](loc3: Ty0)\n\t47: MutBorrowLoc[9](loc7: vector<Ty1>)\n\t48: VecPopBack(23)\n\t49: StLoc[10](loc8: Ty1)\n\t50: MutBorrowLoc[3](loc1: VecMap<Ty0, Ty1>)\n\t51: MoveLoc[5](loc3: Ty0)\n\t52: MoveLoc[10](loc8: Ty1)\n\t53: Call insert<Ty0, Ty1>(&mut VecMap<Ty0, Ty1>, Ty0, Ty1)\n\t54: MoveLoc[4](loc2: u64)\n\t55: LdU64(1)\n\t56: Add\n\t57: StLoc[4](loc2: u64)\n\t58: Branch(38)\nB9:\n\t59: MoveLoc[7](loc5: vector<Ty0>)\n\t60: VecUnpack(22, 0)\n\t61: MoveLoc[9](loc7: vector<Ty1>)\n\t62: VecUnpack(23, 0)\n\t63: MoveLoc[3](loc1: VecMap<Ty0, Ty1>)\n\t64: Ret\n}\n\npublic keys<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>): vector<Ty0> {\nL1:\tloc0: u64\nL2:\tloc1: &Entry<Ty0, Ty1>\nL3:\tloc2: Ty0\nL4:\tloc3: &mut vector<Ty0>\nL5:\tloc4: &Entry<Ty0, Ty1>\nL6:\tloc5: u64\nL7:\tloc6: u64\nL8:\tloc7: &Ty0\nL9:\tloc8: vector<Ty0>\nL10:\tloc9: u64\nL11:\tloc10: &vector<Entry<Ty0, Ty1>>\nL12:\tloc11: &vector<Entry<Ty0, Ty1>>\nB0:\n\t0: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t2: StLoc[11](loc10: &vector<Entry<Ty0, Ty1>>)\n\t3: VecPack(22, 0)\n\t4: StLoc[9](loc8: vector<Ty0>)\n\t5: MoveLoc[11](loc10: &vector<Entry<Ty0, Ty1>>)\n\t6: StLoc[12](loc11: &vector<Entry<Ty0, Ty1>>)\n\t7: CopyLoc[12](loc11: &vector<Entry<Ty0, Ty1>>)\n\t8: VecLen(20)\n\t9: StLoc[1](loc0: u64)\n\t10: LdU64(0)\n\t11: StLoc[7](loc6: u64)\n\t12: MoveLoc[1](loc0: u64)\n\t13: StLoc[10](loc9: u64)\nB1:\n\t14: CopyLoc[7](loc6: u64)\n\t15: CopyLoc[10](loc9: u64)\n\t16: Lt\n\t17: BrFalse(45)\nB2:\n\t18: CopyLoc[7](loc6: u64)\n\t19: StLoc[6](loc5: u64)\n\t20: CopyLoc[12](loc11: &vector<Entry<Ty0, Ty1>>)\n\t21: MoveLoc[6](loc5: u64)\n\t22: VecImmBorrow(20)\n\t23: StLoc[5](loc4: &Entry<Ty0, Ty1>)\n\t24: MutBorrowLoc[9](loc8: vector<Ty0>)\n\t25: StLoc[4](loc3: &mut vector<Ty0>)\n\t26: MoveLoc[5](loc4: &Entry<Ty0, Ty1>)\n\t27: StLoc[2](loc1: &Entry<Ty0, Ty1>)\n\t28: CopyLoc[2](loc1: &Entry<Ty0, Ty1>)\n\t29: ImmBorrowFieldGeneric[2](Entry.key: Ty0)\n\t30: StLoc[8](loc7: &Ty0)\n\t31: MoveLoc[2](loc1: &Entry<Ty0, Ty1>)\n\t32: ImmBorrowFieldGeneric[1](Entry.value: Ty1)\n\t33: Pop\n\t34: MoveLoc[8](loc7: &Ty0)\n\t35: ReadRef\n\t36: StLoc[3](loc2: Ty0)\n\t37: MoveLoc[4](loc3: &mut vector<Ty0>)\n\t38: MoveLoc[3](loc2: Ty0)\n\t39: VecPushBack(22)\n\t40: MoveLoc[7](loc6: u64)\n\t41: LdU64(1)\n\t42: Add\n\t43: StLoc[7](loc6: u64)\n\t44: Branch(14)\nB3:\n\t45: MoveLoc[12](loc11: &vector<Entry<Ty0, Ty1>>)\n\t46: Pop\n\t47: MoveLoc[9](loc8: vector<Ty0>)\n\t48: Ret\n}\n\npublic get_idx_opt<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>, Arg1: &Ty0): Option<u64> {\nL2:\tloc0: u64\nL3:\tloc1: Option<u64>\nL4:\tloc2: &Entry<Ty0, Ty1>\nL5:\tloc3: u64\nL6:\tloc4: u64\nL7:\tloc5: &Ty0\nL8:\tloc6: u64\nL9:\tloc7: &vector<Entry<Ty0, Ty1>>\nB0:\n\t0: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t2: StLoc[9](loc7: &vector<Entry<Ty0, Ty1>>)\n\t3: CopyLoc[9](loc7: &vector<Entry<Ty0, Ty1>>)\n\t4: VecLen(20)\n\t5: StLoc[2](loc0: u64)\n\t6: LdU64(0)\n\t7: StLoc[5](loc3: u64)\n\t8: MoveLoc[2](loc0: u64)\n\t9: StLoc[8](loc6: u64)\nB1:\n\t10: CopyLoc[5](loc3: u64)\n\t11: CopyLoc[8](loc6: u64)\n\t12: Lt\n\t13: BrFalse(43)\nB2:\n\t14: CopyLoc[5](loc3: u64)\n\t15: StLoc[6](loc4: u64)\n\t16: CopyLoc[9](loc7: &vector<Entry<Ty0, Ty1>>)\n\t17: CopyLoc[6](loc4: u64)\n\t18: VecImmBorrow(20)\n\t19: StLoc[4](loc2: &Entry<Ty0, Ty1>)\n\t20: CopyLoc[4](loc2: &Entry<Ty0, Ty1>)\n\t21: ImmBorrowFieldGeneric[2](Entry.key: Ty0)\n\t22: StLoc[7](loc5: &Ty0)\n\t23: MoveLoc[4](loc2: &Entry<Ty0, Ty1>)\n\t24: ImmBorrowFieldGeneric[1](Entry.value: Ty1)\n\t25: Pop\n\t26: MoveLoc[7](loc5: &Ty0)\n\t27: CopyLoc[1](Arg1: &Ty0)\n\t28: Eq\n\t29: BrFalse(38)\nB3:\n\t30: MoveLoc[9](loc7: &vector<Entry<Ty0, Ty1>>)\n\t31: Pop\n\t32: MoveLoc[1](Arg1: &Ty0)\n\t33: Pop\n\t34: MoveLoc[6](loc4: u64)\n\t35: Call option::some<u64>(u64): Option<u64>\n\t36: StLoc[3](loc1: Option<u64>)\n\t37: Branch(49)\nB4:\n\t38: MoveLoc[5](loc3: u64)\n\t39: LdU64(1)\n\t40: Add\n\t41: StLoc[5](loc3: u64)\n\t42: Branch(10)\nB5:\n\t43: MoveLoc[9](loc7: &vector<Entry<Ty0, Ty1>>)\n\t44: Pop\n\t45: MoveLoc[1](Arg1: &Ty0)\n\t46: Pop\n\t47: Call option::none<u64>(): Option<u64>\n\t48: StLoc[3](loc1: Option<u64>)\nB6:\n\t49: MoveLoc[3](loc1: Option<u64>)\n\t50: Ret\n}\n\npublic get_idx<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>, Arg1: &Ty0): u64 {\nL2:\tloc0: u64\nL3:\tloc1: Option<u64>\nL4:\tloc2: &Entry<Ty0, Ty1>\nL5:\tloc3: u64\nL6:\tloc4: u64\nL7:\tloc5: &Ty0\nL8:\tloc6: Option<u64>\nL9:\tloc7: u64\nL10:\tloc8: &vector<Entry<Ty0, Ty1>>\nB0:\n\t0: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t2: StLoc[10](loc8: &vector<Entry<Ty0, Ty1>>)\n\t3: CopyLoc[10](loc8: &vector<Entry<Ty0, Ty1>>)\n\t4: VecLen(20)\n\t5: StLoc[2](loc0: u64)\n\t6: LdU64(0)\n\t7: StLoc[5](loc3: u64)\n\t8: MoveLoc[2](loc0: u64)\n\t9: StLoc[9](loc7: u64)\nB1:\n\t10: CopyLoc[5](loc3: u64)\n\t11: CopyLoc[9](loc7: u64)\n\t12: Lt\n\t13: BrFalse(43)\nB2:\n\t14: CopyLoc[5](loc3: u64)\n\t15: StLoc[6](loc4: u64)\n\t16: CopyLoc[10](loc8: &vector<Entry<Ty0, Ty1>>)\n\t17: CopyLoc[6](loc4: u64)\n\t18: VecImmBorrow(20)\n\t19: StLoc[4](loc2: &Entry<Ty0, Ty1>)\n\t20: CopyLoc[4](loc2: &Entry<Ty0, Ty1>)\n\t21: ImmBorrowFieldGeneric[2](Entry.key: Ty0)\n\t22: StLoc[7](loc5: &Ty0)\n\t23: MoveLoc[4](loc2: &Entry<Ty0, Ty1>)\n\t24: ImmBorrowFieldGeneric[1](Entry.value: Ty1)\n\t25: Pop\n\t26: MoveLoc[7](loc5: &Ty0)\n\t27: CopyLoc[1](Arg1: &Ty0)\n\t28: Eq\n\t29: BrFalse(38)\nB3:\n\t30: MoveLoc[10](loc8: &vector<Entry<Ty0, Ty1>>)\n\t31: Pop\n\t32: MoveLoc[1](Arg1: &Ty0)\n\t33: Pop\n\t34: MoveLoc[6](loc4: u64)\n\t35: Call option::some<u64>(u64): Option<u64>\n\t36: StLoc[3](loc1: Option<u64>)\n\t37: Branch(49)\nB4:\n\t38: MoveLoc[5](loc3: u64)\n\t39: LdU64(1)\n\t40: Add\n\t41: StLoc[5](loc3: u64)\n\t42: Branch(10)\nB5:\n\t43: MoveLoc[10](loc8: &vector<Entry<Ty0, Ty1>>)\n\t44: Pop\n\t45: MoveLoc[1](Arg1: &Ty0)\n\t46: Pop\n\t47: Call option::none<u64>(): Option<u64>\n\t48: StLoc[3](loc1: Option<u64>)\nB6:\n\t49: MoveLoc[3](loc1: Option<u64>)\n\t50: StLoc[8](loc6: Option<u64>)\n\t51: ImmBorrowLoc[8](loc6: Option<u64>)\n\t52: Call option::is_some<u64>(&Option<u64>): bool\n\t53: BrFalse(55)\nB7:\n\t54: Branch(59)\nB8:\n\t55: MoveLoc[8](loc6: Option<u64>)\n\t56: Call option::destroy_none<u64>(Option<u64>)\n\t57: LdConst[1](u64: 1)\n\t58: Abort\nB9:\n\t59: MoveLoc[8](loc6: Option<u64>)\n\t60: Call option::destroy_some<u64>(Option<u64>): u64\n\t61: Ret\n}\n\npublic get_entry_by_idx<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>, Arg1: u64): &Ty0 * &Ty1 {\nL2:\tloc0: &Entry<Ty0, Ty1>\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: CopyLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t2: Call length<Ty0, Ty1>(&VecMap<Ty0, Ty1>): u64\n\t3: Lt\n\t4: BrFalse(6)\nB1:\n\t5: Branch(10)\nB2:\n\t6: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t7: Pop\n\t8: LdConst[3](u64: 3)\n\t9: Abort\nB3:\n\t10: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t11: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t12: MoveLoc[1](Arg1: u64)\n\t13: VecImmBorrow(20)\n\t14: StLoc[2](loc0: &Entry<Ty0, Ty1>)\n\t15: CopyLoc[2](loc0: &Entry<Ty0, Ty1>)\n\t16: ImmBorrowFieldGeneric[2](Entry.key: Ty0)\n\t17: MoveLoc[2](loc0: &Entry<Ty0, Ty1>)\n\t18: ImmBorrowFieldGeneric[1](Entry.value: Ty1)\n\t19: Ret\n}\n\npublic get_entry_by_idx_mut<Ty0: copy, Ty1>(Arg0: &mut VecMap<Ty0, Ty1>, Arg1: u64): &Ty0 * &mut Ty1 {\nL2:\tloc0: &mut Entry<Ty0, Ty1>\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: CopyLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t2: FreezeRef\n\t3: Call length<Ty0, Ty1>(&VecMap<Ty0, Ty1>): u64\n\t4: Lt\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t8: Pop\n\t9: LdConst[3](u64: 3)\n\t10: Abort\nB3:\n\t11: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t12: MutBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t13: MoveLoc[1](Arg1: u64)\n\t14: VecMutBorrow(20)\n\t15: StLoc[2](loc0: &mut Entry<Ty0, Ty1>)\n\t16: CopyLoc[2](loc0: &mut Entry<Ty0, Ty1>)\n\t17: ImmBorrowFieldGeneric[2](Entry.key: Ty0)\n\t18: MoveLoc[2](loc0: &mut Entry<Ty0, Ty1>)\n\t19: MutBorrowFieldGeneric[1](Entry.value: Ty1)\n\t20: Ret\n}\n\npublic remove_entry_by_idx<Ty0: copy, Ty1>(Arg0: &mut VecMap<Ty0, Ty1>, Arg1: u64): Ty0 * Ty1 {\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: CopyLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t2: FreezeRef\n\t3: Call length<Ty0, Ty1>(&VecMap<Ty0, Ty1>): u64\n\t4: Lt\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t8: Pop\n\t9: LdConst[3](u64: 3)\n\t10: Abort\nB3:\n\t11: MoveLoc[0](Arg0: &mut VecMap<Ty0, Ty1>)\n\t12: MutBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t13: MoveLoc[1](Arg1: u64)\n\t14: Call vector::remove<Entry<Ty0, Ty1>>(&mut vector<Entry<Ty0, Ty1>>, u64): Entry<Ty0, Ty1>\n\t15: UnpackGeneric[1](Entry<Ty0, Ty1>)\n\t16: Ret\n}\n\npublic size<Ty0: copy, Ty1>(Arg0: &VecMap<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &VecMap<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](VecMap.contents: vector<Entry<Ty0, Ty1>>)\n\t2: VecLen(20)\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u64: 5\n]\n}\n","vec_set":"// Move bytecode v6\nmodule 2.vec_set {\nuse 0000000000000000000000000000000000000000000000000000000000000001::option;\nuse 0000000000000000000000000000000000000000000000000000000000000001::vector;\n\nstruct VecSet<Ty0: copy + drop> has copy, drop, store {\n\tcontents: vector<Ty0>\n}\n\npublic empty<Ty0: copy + drop>(): VecSet<Ty0> {\nB0:\n\t0: VecPack(2, 0)\n\t1: PackGeneric[0](VecSet<Ty0>)\n\t2: Ret\n}\n\npublic singleton<Ty0: copy + drop>(Arg0: Ty0): VecSet<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: Ty0)\n\t1: VecPack(2, 1)\n\t2: PackGeneric[0](VecSet<Ty0>)\n\t3: Ret\n}\n\npublic insert<Ty0: copy + drop>(Arg0: &mut VecSet<Ty0>, Arg1: Ty0) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut VecSet<Ty0>)\n\t1: FreezeRef\n\t2: ImmBorrowLoc[1](Arg1: Ty0)\n\t3: Call contains<Ty0>(&VecSet<Ty0>, &Ty0): bool\n\t4: Not\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[0](Arg0: &mut VecSet<Ty0>)\n\t8: Pop\n\t9: LdConst[0](u64: 0)\n\t10: Abort\nB3:\n\t11: MoveLoc[0](Arg0: &mut VecSet<Ty0>)\n\t12: MutBorrowFieldGeneric[0](VecSet.contents: vector<Ty0>)\n\t13: MoveLoc[1](Arg1: Ty0)\n\t14: VecPushBack(2)\n\t15: Ret\n}\n\npublic remove<Ty0: copy + drop>(Arg0: &mut VecSet<Ty0>, Arg1: &Ty0) {\nL2:\tloc0: u64\nL3:\tloc1: Option<u64>\nL4:\tloc2: u64\nL5:\tloc3: u64\nL6:\tloc4: u64\nL7:\tloc5: Option<u64>\nL8:\tloc6: u64\nL9:\tloc7: &vector<Ty0>\nB0:\n\t0: CopyLoc[0](Arg0: &mut VecSet<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](VecSet.contents: vector<Ty0>)\n\t2: StLoc[9](loc7: &vector<Ty0>)\n\t3: CopyLoc[9](loc7: &vector<Ty0>)\n\t4: VecLen(2)\n\t5: StLoc[2](loc0: u64)\n\t6: LdU64(0)\n\t7: StLoc[4](loc2: u64)\n\t8: MoveLoc[2](loc0: u64)\n\t9: StLoc[8](loc6: u64)\nB1:\n\t10: CopyLoc[4](loc2: u64)\n\t11: CopyLoc[8](loc6: u64)\n\t12: Lt\n\t13: BrFalse(35)\nB2:\n\t14: CopyLoc[4](loc2: u64)\n\t15: StLoc[5](loc3: u64)\n\t16: CopyLoc[9](loc7: &vector<Ty0>)\n\t17: CopyLoc[5](loc3: u64)\n\t18: VecImmBorrow(2)\n\t19: CopyLoc[1](Arg1: &Ty0)\n\t20: Eq\n\t21: BrFalse(30)\nB3:\n\t22: MoveLoc[9](loc7: &vector<Ty0>)\n\t23: Pop\n\t24: MoveLoc[1](Arg1: &Ty0)\n\t25: Pop\n\t26: MoveLoc[5](loc3: u64)\n\t27: Call option::some<u64>(u64): Option<u64>\n\t28: StLoc[3](loc1: Option<u64>)\n\t29: Branch(41)\nB4:\n\t30: MoveLoc[4](loc2: u64)\n\t31: LdU64(1)\n\t32: Add\n\t33: StLoc[4](loc2: u64)\n\t34: Branch(10)\nB5:\n\t35: MoveLoc[9](loc7: &vector<Ty0>)\n\t36: Pop\n\t37: MoveLoc[1](Arg1: &Ty0)\n\t38: Pop\n\t39: Call option::none<u64>(): Option<u64>\n\t40: StLoc[3](loc1: Option<u64>)\nB6:\n\t41: MoveLoc[3](loc1: Option<u64>)\n\t42: StLoc[7](loc5: Option<u64>)\n\t43: ImmBorrowLoc[7](loc5: Option<u64>)\n\t44: Call option::is_some<u64>(&Option<u64>): bool\n\t45: BrFalse(47)\nB7:\n\t46: Branch(53)\nB8:\n\t47: MoveLoc[0](Arg0: &mut VecSet<Ty0>)\n\t48: Pop\n\t49: MoveLoc[7](loc5: Option<u64>)\n\t50: Call option::destroy_none<u64>(Option<u64>)\n\t51: LdConst[1](u64: 1)\n\t52: Abort\nB9:\n\t53: MoveLoc[7](loc5: Option<u64>)\n\t54: Call option::destroy_some<u64>(Option<u64>): u64\n\t55: StLoc[6](loc4: u64)\n\t56: MoveLoc[0](Arg0: &mut VecSet<Ty0>)\n\t57: MutBorrowFieldGeneric[0](VecSet.contents: vector<Ty0>)\n\t58: MoveLoc[6](loc4: u64)\n\t59: Call vector::remove<Ty0>(&mut vector<Ty0>, u64): Ty0\n\t60: Pop\n\t61: Ret\n}\n\npublic contains<Ty0: copy + drop>(Arg0: &VecSet<Ty0>, Arg1: &Ty0): bool {\nL2:\tloc0: u64\nL3:\tloc1: bool\nL4:\tloc2: u64\nL5:\tloc3: u64\nL6:\tloc4: u64\nL7:\tloc5: &vector<Ty0>\nB0:\n\t0: MoveLoc[0](Arg0: &VecSet<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](VecSet.contents: vector<Ty0>)\n\t2: StLoc[7](loc5: &vector<Ty0>)\n\t3: CopyLoc[7](loc5: &vector<Ty0>)\n\t4: VecLen(2)\n\t5: StLoc[2](loc0: u64)\n\t6: LdU64(0)\n\t7: StLoc[4](loc2: u64)\n\t8: MoveLoc[2](loc0: u64)\n\t9: StLoc[6](loc4: u64)\nB1:\n\t10: CopyLoc[4](loc2: u64)\n\t11: CopyLoc[6](loc4: u64)\n\t12: Lt\n\t13: BrFalse(34)\nB2:\n\t14: CopyLoc[4](loc2: u64)\n\t15: StLoc[5](loc3: u64)\n\t16: CopyLoc[7](loc5: &vector<Ty0>)\n\t17: MoveLoc[5](loc3: u64)\n\t18: VecImmBorrow(2)\n\t19: CopyLoc[1](Arg1: &Ty0)\n\t20: Eq\n\t21: BrFalse(29)\nB3:\n\t22: MoveLoc[7](loc5: &vector<Ty0>)\n\t23: Pop\n\t24: MoveLoc[1](Arg1: &Ty0)\n\t25: Pop\n\t26: LdTrue\n\t27: StLoc[3](loc1: bool)\n\t28: Branch(40)\nB4:\n\t29: MoveLoc[4](loc2: u64)\n\t30: LdU64(1)\n\t31: Add\n\t32: StLoc[4](loc2: u64)\n\t33: Branch(10)\nB5:\n\t34: MoveLoc[7](loc5: &vector<Ty0>)\n\t35: Pop\n\t36: MoveLoc[1](Arg1: &Ty0)\n\t37: Pop\n\t38: LdFalse\n\t39: StLoc[3](loc1: bool)\nB6:\n\t40: MoveLoc[3](loc1: bool)\n\t41: Ret\n}\n\npublic length<Ty0: copy + drop>(Arg0: &VecSet<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &VecSet<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](VecSet.contents: vector<Ty0>)\n\t2: VecLen(2)\n\t3: Ret\n}\n\npublic is_empty<Ty0: copy + drop>(Arg0: &VecSet<Ty0>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &VecSet<Ty0>)\n\t1: Call length<Ty0>(&VecSet<Ty0>): u64\n\t2: LdU64(0)\n\t3: Eq\n\t4: Ret\n}\n\npublic into_keys<Ty0: copy + drop>(Arg0: VecSet<Ty0>): vector<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: VecSet<Ty0>)\n\t1: UnpackGeneric[0](VecSet<Ty0>)\n\t2: Ret\n}\n\npublic from_keys<Ty0: copy + drop>(Arg0: vector<Ty0>): VecSet<Ty0> {\nL1:\tloc0: u64\nL2:\tloc1: u64\nL3:\tloc2: Ty0\nL4:\tloc3: VecSet<Ty0>\nL5:\tloc4: u64\nL6:\tloc5: vector<Ty0>\nB0:\n\t0: Call empty<Ty0>(): VecSet<Ty0>\n\t1: StLoc[4](loc3: VecSet<Ty0>)\n\t2: MoveLoc[0](Arg0: vector<Ty0>)\n\t3: StLoc[6](loc5: vector<Ty0>)\n\t4: MutBorrowLoc[6](loc5: vector<Ty0>)\n\t5: Call vector::reverse<Ty0>(&mut vector<Ty0>)\n\t6: ImmBorrowLoc[6](loc5: vector<Ty0>)\n\t7: VecLen(2)\n\t8: StLoc[1](loc0: u64)\n\t9: LdU64(0)\n\t10: StLoc[2](loc1: u64)\n\t11: MoveLoc[1](loc0: u64)\n\t12: StLoc[5](loc4: u64)\nB1:\n\t13: CopyLoc[2](loc1: u64)\n\t14: CopyLoc[5](loc4: u64)\n\t15: Lt\n\t16: BrFalse(30)\nB2:\n\t17: CopyLoc[2](loc1: u64)\n\t18: Pop\n\t19: MutBorrowLoc[6](loc5: vector<Ty0>)\n\t20: VecPopBack(2)\n\t21: StLoc[3](loc2: Ty0)\n\t22: MutBorrowLoc[4](loc3: VecSet<Ty0>)\n\t23: MoveLoc[3](loc2: Ty0)\n\t24: Call insert<Ty0>(&mut VecSet<Ty0>, Ty0)\n\t25: MoveLoc[2](loc1: u64)\n\t26: LdU64(1)\n\t27: Add\n\t28: StLoc[2](loc1: u64)\n\t29: Branch(13)\nB3:\n\t30: MoveLoc[6](loc5: vector<Ty0>)\n\t31: VecUnpack(2, 0)\n\t32: MoveLoc[4](loc3: VecSet<Ty0>)\n\t33: Ret\n}\n\npublic keys<Ty0: copy + drop>(Arg0: &VecSet<Ty0>): &vector<Ty0> {\nB0:\n\t0: MoveLoc[0](Arg0: &VecSet<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](VecSet.contents: vector<Ty0>)\n\t2: Ret\n}\n\npublic size<Ty0: copy + drop>(Arg0: &VecSet<Ty0>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &VecSet<Ty0>)\n\t1: ImmBorrowFieldGeneric[0](VecSet.contents: vector<Ty0>)\n\t2: VecLen(2)\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n]\n}\n","versioned":"// Move bytecode v6\nmodule 2.versioned {\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Versioned has store, key {\n\tid: UID,\n\tversion: u64\n}\n\nstruct VersionChangeCap {\n\tversioned_id: ID,\n\told_version: u64\n}\n\npublic create<Ty0: store>(Arg0: u64, Arg1: Ty0, Arg2: &mut TxContext): Versioned {\nL3:\tloc0: Versioned\nB0:\n\t0: MoveLoc[2](Arg2: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: CopyLoc[0](Arg0: u64)\n\t3: Pack[0](Versioned)\n\t4: StLoc[3](loc0: Versioned)\n\t5: MutBorrowLoc[3](loc0: Versioned)\n\t6: MutBorrowField[0](Versioned.id: UID)\n\t7: MoveLoc[0](Arg0: u64)\n\t8: MoveLoc[1](Arg1: Ty0)\n\t9: Call dynamic_field::add<u64, Ty0>(&mut UID, u64, Ty0)\n\t10: MoveLoc[3](loc0: Versioned)\n\t11: Ret\n}\n\npublic version(Arg0: &Versioned): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Versioned)\n\t1: ImmBorrowField[1](Versioned.version: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic load_value<Ty0: store>(Arg0: &Versioned): &Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: &Versioned)\n\t1: ImmBorrowField[0](Versioned.id: UID)\n\t2: MoveLoc[0](Arg0: &Versioned)\n\t3: ImmBorrowField[1](Versioned.version: u64)\n\t4: ReadRef\n\t5: Call dynamic_field::borrow<u64, Ty0>(&UID, u64): &Ty0\n\t6: Ret\n}\n\npublic load_value_mut<Ty0: store>(Arg0: &mut Versioned): &mut Ty0 {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Versioned)\n\t1: MutBorrowField[0](Versioned.id: UID)\n\t2: MoveLoc[0](Arg0: &mut Versioned)\n\t3: ImmBorrowField[1](Versioned.version: u64)\n\t4: ReadRef\n\t5: Call dynamic_field::borrow_mut<u64, Ty0>(&mut UID, u64): &mut Ty0\n\t6: Ret\n}\n\npublic remove_value_for_upgrade<Ty0: store>(Arg0: &mut Versioned): Ty0 * VersionChangeCap {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Versioned)\n\t1: MutBorrowField[0](Versioned.id: UID)\n\t2: CopyLoc[0](Arg0: &mut Versioned)\n\t3: ImmBorrowField[1](Versioned.version: u64)\n\t4: ReadRef\n\t5: Call dynamic_field::remove<u64, Ty0>(&mut UID, u64): Ty0\n\t6: CopyLoc[0](Arg0: &mut Versioned)\n\t7: FreezeRef\n\t8: Call object::id<Versioned>(&Versioned): ID\n\t9: MoveLoc[0](Arg0: &mut Versioned)\n\t10: ImmBorrowField[1](Versioned.version: u64)\n\t11: ReadRef\n\t12: Pack[1](VersionChangeCap)\n\t13: Ret\n}\n\npublic upgrade<Ty0: store>(Arg0: &mut Versioned, Arg1: u64, Arg2: Ty0, Arg3: VersionChangeCap) {\nL4:\tloc0: u64\nB0:\n\t0: MoveLoc[3](Arg3: VersionChangeCap)\n\t1: Unpack[1](VersionChangeCap)\n\t2: StLoc[4](loc0: u64)\n\t3: CopyLoc[0](Arg0: &mut Versioned)\n\t4: FreezeRef\n\t5: Call object::id<Versioned>(&Versioned): ID\n\t6: Eq\n\t7: BrFalse(9)\nB1:\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: &mut Versioned)\n\t10: Pop\n\t11: LdConst[0](u64: 0)\n\t12: Abort\nB3:\n\t13: MoveLoc[4](loc0: u64)\n\t14: CopyLoc[1](Arg1: u64)\n\t15: Lt\n\t16: BrFalse(18)\nB4:\n\t17: Branch(22)\nB5:\n\t18: MoveLoc[0](Arg0: &mut Versioned)\n\t19: Pop\n\t20: LdConst[0](u64: 0)\n\t21: Abort\nB6:\n\t22: CopyLoc[0](Arg0: &mut Versioned)\n\t23: MutBorrowField[0](Versioned.id: UID)\n\t24: CopyLoc[1](Arg1: u64)\n\t25: MoveLoc[2](Arg2: Ty0)\n\t26: Call dynamic_field::add<u64, Ty0>(&mut UID, u64, Ty0)\n\t27: MoveLoc[1](Arg1: u64)\n\t28: MoveLoc[0](Arg0: &mut Versioned)\n\t29: MutBorrowField[1](Versioned.version: u64)\n\t30: WriteRef\n\t31: Ret\n}\n\npublic destroy<Ty0: store>(Arg0: Versioned): Ty0 {\nL1:\tloc0: UID\nL2:\tloc1: Ty0\nL3:\tloc2: u64\nB0:\n\t0: MoveLoc[0](Arg0: Versioned)\n\t1: Unpack[0](Versioned)\n\t2: StLoc[3](loc2: u64)\n\t3: StLoc[1](loc0: UID)\n\t4: MutBorrowLoc[1](loc0: UID)\n\t5: MoveLoc[3](loc2: u64)\n\t6: Call dynamic_field::remove<u64, Ty0>(&mut UID, u64): Ty0\n\t7: StLoc[2](loc1: Ty0)\n\t8: MoveLoc[1](loc0: UID)\n\t9: Call object::delete(UID)\n\t10: MoveLoc[2](loc1: Ty0)\n\t11: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n","zklogin_verified_id":"// Move bytecode v6\nmodule 2.zklogin_verified_id {\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct VerifiedID has key {\n\tid: UID,\n\towner: address,\n\tkey_claim_name: String,\n\tkey_claim_value: String,\n\tissuer: String,\n\taudience: String\n}\n\npublic owner(Arg0: &VerifiedID): address {\nB0:\n\t0: MoveLoc[0](Arg0: &VerifiedID)\n\t1: ImmBorrowField[0](VerifiedID.owner: address)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic key_claim_name(Arg0: &VerifiedID): &String {\nB0:\n\t0: MoveLoc[0](Arg0: &VerifiedID)\n\t1: ImmBorrowField[1](VerifiedID.key_claim_name: String)\n\t2: Ret\n}\n\npublic key_claim_value(Arg0: &VerifiedID): &String {\nB0:\n\t0: MoveLoc[0](Arg0: &VerifiedID)\n\t1: ImmBorrowField[2](VerifiedID.key_claim_value: String)\n\t2: Ret\n}\n\npublic issuer(Arg0: &VerifiedID): &String {\nB0:\n\t0: MoveLoc[0](Arg0: &VerifiedID)\n\t1: ImmBorrowField[3](VerifiedID.issuer: String)\n\t2: Ret\n}\n\npublic audience(Arg0: &VerifiedID): &String {\nB0:\n\t0: MoveLoc[0](Arg0: &VerifiedID)\n\t1: ImmBorrowField[4](VerifiedID.audience: String)\n\t2: Ret\n}\n\npublic delete(Arg0: VerifiedID) {\nB0:\n\t0: MoveLoc[0](Arg0: VerifiedID)\n\t1: Unpack[0](VerifiedID)\n\t2: Pop\n\t3: Pop\n\t4: Pop\n\t5: Pop\n\t6: Pop\n\t7: Call object::delete(UID)\n\t8: Ret\n}\n\npublic verify_zklogin_id(Arg0: String, Arg1: String, Arg2: String, Arg3: String, Arg4: u256, Arg5: &mut TxContext) {\nB0:\n\t0: LdConst[0](u64: 0)\n\t1: Abort\n}\n\npublic check_zklogin_id(Arg0: address, Arg1: &String, Arg2: &String, Arg3: &String, Arg4: &String, Arg5: u256): bool {\nB0:\n\t0: LdConst[0](u64: 0)\n\t1: Abort\n}\n\nnative check_zklogin_id_internal(Arg0: address, Arg1: &vector<u8>, Arg2: &vector<u8>, Arg3: &vector<u8>, Arg4: &vector<u8>, Arg5: u256): bool;\n\nConstants [\n\t0 => u64: 0\n]\n}\n","zklogin_verified_issuer":"// Move bytecode v6\nmodule 2.zklogin_verified_issuer {\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct VerifiedIssuer has key {\n\tid: UID,\n\towner: address,\n\tissuer: String\n}\n\npublic owner(Arg0: &VerifiedIssuer): address {\nB0:\n\t0: MoveLoc[0](Arg0: &VerifiedIssuer)\n\t1: ImmBorrowField[0](VerifiedIssuer.owner: address)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic issuer(Arg0: &VerifiedIssuer): &String {\nB0:\n\t0: MoveLoc[0](Arg0: &VerifiedIssuer)\n\t1: ImmBorrowField[1](VerifiedIssuer.issuer: String)\n\t2: Ret\n}\n\npublic delete(Arg0: VerifiedIssuer) {\nB0:\n\t0: MoveLoc[0](Arg0: VerifiedIssuer)\n\t1: Unpack[0](VerifiedIssuer)\n\t2: Pop\n\t3: Pop\n\t4: Call object::delete(UID)\n\t5: Ret\n}\n\npublic verify_zklogin_issuer(Arg0: u256, Arg1: String, Arg2: &mut TxContext) {\nL3:\tloc0: address\nB0:\n\t0: CopyLoc[2](Arg2: &mut TxContext)\n\t1: FreezeRef\n\t2: Call tx_context::sender(&TxContext): address\n\t3: StLoc[3](loc0: address)\n\t4: CopyLoc[3](loc0: address)\n\t5: MoveLoc[0](Arg0: u256)\n\t6: ImmBorrowLoc[1](Arg1: String)\n\t7: Call check_zklogin_issuer(address, u256, &String): bool\n\t8: BrFalse(10)\nB1:\n\t9: Branch(14)\nB2:\n\t10: MoveLoc[2](Arg2: &mut TxContext)\n\t11: Pop\n\t12: LdConst[1](u64: 1)\n\t13: Abort\nB3:\n\t14: MoveLoc[2](Arg2: &mut TxContext)\n\t15: Call object::new(&mut TxContext): UID\n\t16: CopyLoc[3](loc0: address)\n\t17: MoveLoc[1](Arg1: String)\n\t18: Pack[0](VerifiedIssuer)\n\t19: MoveLoc[3](loc0: address)\n\t20: Call transfer::transfer<VerifiedIssuer>(VerifiedIssuer, address)\n\t21: Ret\n}\n\npublic check_zklogin_issuer(Arg0: address, Arg1: u256, Arg2: &String): bool {\nB0:\n\t0: MoveLoc[0](Arg0: address)\n\t1: MoveLoc[1](Arg1: u256)\n\t2: MoveLoc[2](Arg2: &String)\n\t3: Call string::as_bytes(&String): &vector<u8>\n\t4: Call check_zklogin_issuer_internal(address, u256, &vector<u8>): bool\n\t5: Ret\n}\n\nnative check_zklogin_issuer_internal(Arg0: address, Arg1: u256, Arg2: &vector<u8>): bool;\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n]\n}\n"}}}}}